<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.16.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>JH-Toolkit: jh::ranges Namespace Reference</title>
<link rel="icon" href="Jindallae.svg" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="Oree.svg"/></td>
  <td id="projectalign">
   <div id="projectname">JH-Toolkit<span id="projectnumber">&#160;v1.4.0</span>
   </div>
   <div id="projectbrief">An engineering-oriented C++20 toolkit with duck-typed concepts, static design, async coroutines, and semantic containers — header-only, RTTI-free, and concurrency-friendly.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.16.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('namespacejh_1_1ranges.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">jh::ranges Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:range_5Fadaptor" id="r_range_5Fadaptor"><td class="memItemLeft">class &#160;</td><td class="memItemRight"><a class="el" href="classjh_1_1ranges_1_1range__adaptor.html">range_adaptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lightweight adapter that exposes any sequence as a standard range.  <a href="classjh_1_1ranges_1_1range__adaptor.html#details">More...</a><br /></td></tr>
<tr class="memitem:collect_5Ffn" id="r_collect_5Ffn"><td class="memItemLeft">struct &#160;</td><td class="memItemRight"><a class="el" href="structjh_1_1ranges_1_1collect__fn.html">collect_fn</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object implementing <code><a class="el" href="#ae066e3cad87b5bec3c061fc290e8ad73" title="Global instance of the collect adaptor.">jh::ranges::collect</a></code>.  <a href="structjh_1_1ranges_1_1collect__fn.html#details">More...</a><br /></td></tr>
<tr class="memitem:to_5Ffn" id="r_to_5Ffn"><td class="memItemLeft">struct &#160;</td><td class="memItemRight"><a class="el" href="structjh_1_1ranges_1_1to__fn.html">to_fn</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object implementing <code><a class="el" href="#a722e1bdb5632bc636715eb47ed666b15" title="Global instance of the to adaptor.">jh::ranges::to</a></code>.  <a href="structjh_1_1ranges_1_1to__fn.html#details">More...</a><br /></td></tr>
<tr class="memitem:vis_5Ftransform_5Fview" id="r_vis_5Ftransform_5Fview"><td class="memItemLeft">class &#160;</td><td class="memItemRight"><a class="el" href="classjh_1_1ranges_1_1vis__transform__view.html">vis_transform_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A non-consuming transform view preserving reentrancy.  <a href="classjh_1_1ranges_1_1vis__transform__view.html#details">More...</a><br /></td></tr>
<tr class="memitem:zip_5Freference_5Fproxy" id="r_zip_5Freference_5Fproxy"><td class="memItemLeft">struct &#160;</td><td class="memItemRight"><a class="el" href="structjh_1_1ranges_1_1zip__reference__proxy.html">zip_reference_proxy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aggregates element references for a single tuple in <code><a class="el" href="classjh_1_1ranges_1_1zip__view.html" title="A C++20-compatible implementation of std::ranges::zip_view.">jh::ranges::zip_view</a></code>.  <a href="structjh_1_1ranges_1_1zip__reference__proxy.html#details">More...</a><br /></td></tr>
<tr class="memitem:is_5Fzip_5Fproxy" id="r_is_5Fzip_5Fproxy"><td class="memItemLeft">struct &#160;</td><td class="memItemRight"><a class="el" href="structjh_1_1ranges_1_1is__zip__proxy.html">is_zip_proxy</a></td></tr>
<tr class="memitem:is_5Fzip_5Fproxy_3C_20class_20zip_5Freference_5Fproxy_3C_20Ts_2E_2E_2E_20_3E_20_3E" id="r_is_5Fzip_5Fproxy_3C_20class_20zip_5Freference_5Fproxy_3C_20Ts_2E_2E_2E_20_3E_20_3E"><td class="memItemLeft">struct &#160;</td><td class="memItemRight"><a class="el" href="structjh_1_1ranges_1_1is__zip__proxy_3_01class_01zip__reference__proxy_3_01Ts_8_8_8_01_4_01_4.html">is_zip_proxy&lt; class zip_reference_proxy&lt; Ts... &gt; &gt;</a></td></tr>
<tr class="memitem:zip_5Fproxy_5Fvalue_5Ftuple" id="r_zip_5Fproxy_5Fvalue_5Ftuple"><td class="memItemLeft">struct &#160;</td><td class="memItemRight"><a class="el" href="structjh_1_1ranges_1_1zip__proxy__value__tuple.html">zip_proxy_value_tuple</a></td></tr>
<tr class="memitem:zip_5Fproxy_5Fvalue_5Ftuple_3C_20class_20zip_5Freference_5Fproxy_3C_20Ts_2E_2E_2E_20_3E_20_3E" id="r_zip_5Fproxy_5Fvalue_5Ftuple_3C_20class_20zip_5Freference_5Fproxy_3C_20Ts_2E_2E_2E_20_3E_20_3E"><td class="memItemLeft">struct &#160;</td><td class="memItemRight"><a class="el" href="structjh_1_1ranges_1_1zip__proxy__value__tuple_3_01class_01zip__reference__proxy_3_01Ts_8_8_8_01_4_01_4.html">zip_proxy_value_tuple&lt; class zip_reference_proxy&lt; Ts... &gt; &gt;</a></td></tr>
<tr class="memitem:zip_5Fsentinel" id="r_zip_5Fsentinel"><td class="memItemLeft">struct &#160;</td><td class="memItemRight"><a class="el" href="structjh_1_1ranges_1_1zip__sentinel.html">zip_sentinel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sentinel type for <code><a class="el" href="classjh_1_1ranges_1_1zip__view.html" title="A C++20-compatible implementation of std::ranges::zip_view.">jh::ranges::zip_view</a></code>.  <a href="structjh_1_1ranges_1_1zip__sentinel.html#details">More...</a><br /></td></tr>
<tr class="memitem:zip_5Fiterator" id="r_zip_5Fiterator"><td class="memItemLeft">struct &#160;</td><td class="memItemRight"><a class="el" href="structjh_1_1ranges_1_1zip__iterator.html">zip_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator type for <code><a class="el" href="classjh_1_1ranges_1_1zip__view.html" title="A C++20-compatible implementation of std::ranges::zip_view.">jh::ranges::zip_view</a></code>.  <a href="structjh_1_1ranges_1_1zip__iterator.html#details">More...</a><br /></td></tr>
<tr class="memitem:zip_5Fview" id="r_zip_5Fview"><td class="memItemLeft">class &#160;</td><td class="memItemRight"><a class="el" href="classjh_1_1ranges_1_1zip__view.html">zip_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A C++20-compatible implementation of <code>std::ranges::zip_view</code>.  <a href="classjh_1_1ranges_1_1zip__view.html#details">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-typedef-members" class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a351859de0dfbb04945668fc1495ca61d" id="r_a351859de0dfbb04945668fc1495ca61d"><td class="memTemplParams" colspan="2"><a id="a351859de0dfbb04945668fc1495ca61d" name="a351859de0dfbb04945668fc1495ca61d"></a>
template&lt;typename T&gt; </td></tr>
<tr class="memitem:a351859de0dfbb04945668fc1495ca61d template"><td class="memItemLeft">using&#160;</td><td class="memItemRight"><b>zip_proxy_value_tuple_t</b> = typename <a class="el" href="structjh_1_1ranges_1_1zip__proxy__value__tuple.html">zip_proxy_value_tuple</a>&lt;T&gt;::type</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a62858fdf3ffdbf398a0819f002e5b4eb" id="r_a62858fdf3ffdbf398a0819f002e5b4eb"><td class="memTemplParams" colspan="2"><a id="a62858fdf3ffdbf398a0819f002e5b4eb" name="a62858fdf3ffdbf398a0819f002e5b4eb"></a>
template&lt;typename Seq&gt; </td></tr>
<tr class="memitem:a62858fdf3ffdbf398a0819f002e5b4eb template"><td class="memItemLeft">&#160;</td><td class="memItemRight"><b>range_adaptor</b> (Seq &amp;&amp;) -&gt; range_adaptor&lt; Seq &gt;</td></tr>
<tr class="memitem:a4fa041b6ca91a41909afcbf0251cadfd" id="r_a4fa041b6ca91a41909afcbf0251cadfd"><td class="memTemplParams" colspan="2">template&lt;typename C, std::ranges::range R&gt; </td></tr>
<tr class="memitem:a4fa041b6ca91a41909afcbf0251cadfd template"><td class="memItemLeft">constexpr auto&#160;</td><td class="memItemRight"><a class="el" href="#a4fa041b6ca91a41909afcbf0251cadfd">collect_adaptor</a> (R &amp;&amp;r)</td></tr>
<tr class="memdesc:a4fa041b6ca91a41909afcbf0251cadfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Core implementation for <code><a class="el" href="#ae066e3cad87b5bec3c061fc290e8ad73" title="Global instance of the collect adaptor.">jh::ranges::collect</a></code> adaptor.  <br /></td></tr>
<tr class="memitem:ae5e54c0ba31518c3451ad297dc995d15" id="r_ae5e54c0ba31518c3451ad297dc995d15"><td class="memTemplParams" colspan="2">template&lt;typename C, std::ranges::range R, typename... Args&gt; </td></tr>
<tr class="memitem:ae5e54c0ba31518c3451ad297dc995d15 template"><td class="memItemLeft">constexpr auto&#160;</td><td class="memItemRight"><a class="el" href="#ae5e54c0ba31518c3451ad297dc995d15">to_adaptor</a> (R &amp;&amp;r, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ae5e54c0ba31518c3451ad297dc995d15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Core implementation for <code><a class="el" href="#a722e1bdb5632bc636715eb47ed666b15" title="Global instance of the to adaptor.">jh::ranges::to</a></code> adaptor.  <br /></td></tr>
<tr class="memitem:a05581d290ef41cda4a0eaf7f0e458c28" id="r_a05581d290ef41cda4a0eaf7f0e458c28"><td class="memTemplParams" colspan="2"><a id="a05581d290ef41cda4a0eaf7f0e458c28" name="a05581d290ef41cda4a0eaf7f0e458c28"></a>
template&lt;typename R, typename F&gt; </td></tr>
<tr class="memitem:a05581d290ef41cda4a0eaf7f0e458c28 template"><td class="memItemLeft">&#160;</td><td class="memItemRight"><b>vis_transform_view</b> (R &amp;&amp;, F) -&gt; vis_transform_view&lt; std::views::all_t&lt; R &gt;, F &gt;</td></tr>
<tr class="memdesc:a05581d290ef41cda4a0eaf7f0e458c28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction guide for <code><a class="el" href="classjh_1_1ranges_1_1vis__transform__view.html" title="A non-consuming transform view preserving reentrancy.">vis_transform_view</a></code>. <br /></td></tr>
<tr class="memitem:ac6fdf84e31fa9f3144043534b5bdd61d" id="r_ac6fdf84e31fa9f3144043534b5bdd61d"><td class="memTemplParams" colspan="2">template&lt;typename F, typename Tuple&gt; </td></tr>
<tr class="memitem:ac6fdf84e31fa9f3144043534b5bdd61d template"><td class="memItemLeft">constexpr auto&#160;</td><td class="memItemRight"><a class="el" href="#ac6fdf84e31fa9f3144043534b5bdd61d">tuple_transform</a> (F &amp;&amp;f, Tuple &amp;&amp;t)</td></tr>
<tr class="memdesc:ac6fdf84e31fa9f3144043534b5bdd61d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a callable to each element of a <code>std::tuple</code>.  <br /></td></tr>
<tr class="memitem:a45b7964db45e11008ed857894b797b1f" id="r_a45b7964db45e11008ed857894b797b1f"><td class="memTemplParams" colspan="2">template&lt;std::size_t I, typename... Elems&gt; </td></tr>
<tr class="memitem:a45b7964db45e11008ed857894b797b1f template"><td class="memItemLeft">constexpr decltype(auto)&#160;</td><td class="memItemRight"><a class="el" href="#a45b7964db45e11008ed857894b797b1f">get</a> (const <a class="el" href="structjh_1_1ranges_1_1zip__reference__proxy.html">zip_reference_proxy</a>&lt; Elems... &gt; &amp;p) noexcept</td></tr>
<tr class="memdesc:a45b7964db45e11008ed857894b797b1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the <code>I</code>-th element from a <code><a class="el" href="structjh_1_1ranges_1_1zip__reference__proxy.html" title="Aggregates element references for a single tuple in jh::ranges::zip_view.">zip_reference_proxy</a></code>.  <br /></td></tr>
<tr class="memitem:a79fd20711198ec06a3358bf8bcf2a698" id="r_a79fd20711198ec06a3358bf8bcf2a698"><td class="memTemplParams" colspan="2"><a id="a79fd20711198ec06a3358bf8bcf2a698" name="a79fd20711198ec06a3358bf8bcf2a698"></a>
template&lt;typename... Iters, typename... Sentinels&gt; </td></tr>
<tr class="memitem:a79fd20711198ec06a3358bf8bcf2a698 template"><td class="memItemLeft">constexpr bool&#160;</td><td class="memItemRight"><b>operator==</b> (const <a class="el" href="structjh_1_1ranges_1_1zip__sentinel.html">zip_sentinel</a>&lt; Sentinels... &gt; &amp;s, const <a class="el" href="structjh_1_1ranges_1_1zip__iterator.html">zip_iterator</a>&lt; Iters... &gt; &amp;it)</td></tr>
<tr class="memitem:aacfa7f1b3b9af2a1e72abfa8099bdd16" id="r_aacfa7f1b3b9af2a1e72abfa8099bdd16"><td class="memTemplParams" colspan="2"><a id="aacfa7f1b3b9af2a1e72abfa8099bdd16" name="aacfa7f1b3b9af2a1e72abfa8099bdd16"></a>
template&lt;typename... Iters, typename... Sentinels&gt; </td></tr>
<tr class="memitem:aacfa7f1b3b9af2a1e72abfa8099bdd16 template"><td class="memItemLeft">constexpr bool&#160;</td><td class="memItemRight"><b>operator!=</b> (const <a class="el" href="structjh_1_1ranges_1_1zip__sentinel.html">zip_sentinel</a>&lt; Sentinels... &gt; &amp;s, const <a class="el" href="structjh_1_1ranges_1_1zip__iterator.html">zip_iterator</a>&lt; Iters... &gt; &amp;it)</td></tr>
<tr class="memitem:a6e3ad6d23ddde4e8bf0027ba266b09c2" id="r_a6e3ad6d23ddde4e8bf0027ba266b09c2"><td class="memTemplParams" colspan="2">template&lt;std::ranges::viewable_range... Rs&gt; </td></tr>
<tr class="memitem:a6e3ad6d23ddde4e8bf0027ba266b09c2 template"><td class="memItemLeft">&#160;</td><td class="memItemRight"><a class="el" href="#a6e3ad6d23ddde4e8bf0027ba266b09c2">zip_view</a> (Rs &amp;&amp;...) -&gt; zip_view&lt; std::views::all_t&lt; Rs &gt;... &gt;</td></tr>
<tr class="memdesc:a6e3ad6d23ddde4e8bf0027ba266b09c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction guide for <code><a class="el" href="classjh_1_1ranges_1_1zip__view.html" title="A C++20-compatible implementation of std::ranges::zip_view.">jh::ranges::zip_view</a></code>.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-var-members" class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a149715b8becce19a693513225186d1ca" id="r_a149715b8becce19a693513225186d1ca"><td class="memItemLeft">constexpr detail::adapt_fn&#160;</td><td class="memItemRight"><a class="el" href="#a149715b8becce19a693513225186d1ca">adapt</a> {}</td></tr>
<tr class="memdesc:a149715b8becce19a693513225186d1ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">The user-facing <code>adapt</code> adaptor.  <br /></td></tr>
<tr class="memitem:ae066e3cad87b5bec3c061fc290e8ad73" id="r_ae066e3cad87b5bec3c061fc290e8ad73"><td class="memTemplParams" colspan="2">template&lt;typename C&gt; </td></tr>
<tr class="memitem:ae066e3cad87b5bec3c061fc290e8ad73 template"><td class="memItemLeft">constexpr <a class="el" href="structjh_1_1ranges_1_1collect__fn.html">collect_fn</a>&lt; C &gt;&#160;</td><td class="memItemRight"><a class="el" href="#ae066e3cad87b5bec3c061fc290e8ad73">collect</a> {}</td></tr>
<tr class="memdesc:ae066e3cad87b5bec3c061fc290e8ad73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global instance of the <code>collect</code> adaptor.  <br /></td></tr>
<tr class="memitem:a722e1bdb5632bc636715eb47ed666b15" id="r_a722e1bdb5632bc636715eb47ed666b15"><td class="memTemplParams" colspan="2">template&lt;typename C&gt; </td></tr>
<tr class="memitem:a722e1bdb5632bc636715eb47ed666b15 template"><td class="memItemLeft">constexpr <a class="el" href="structjh_1_1ranges_1_1to__fn.html">to_fn</a>&lt; C &gt;&#160;</td><td class="memItemRight"><a class="el" href="#a722e1bdb5632bc636715eb47ed666b15">to</a> {}</td></tr>
<tr class="memdesc:a722e1bdb5632bc636715eb47ed666b15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global instance of the <code>to</code> adaptor.  <br /></td></tr>
<tr class="memitem:a34fe98567b300ea74ce6bc43820b80f1" id="r_a34fe98567b300ea74ce6bc43820b80f1"><td class="memTemplParams" colspan="2"><a id="a34fe98567b300ea74ce6bc43820b80f1" name="a34fe98567b300ea74ce6bc43820b80f1"></a>
template&lt;typename T&gt; </td></tr>
<tr class="memitem:a34fe98567b300ea74ce6bc43820b80f1 template"><td class="memItemLeft">constexpr bool&#160;</td><td class="memItemRight"><b>is_zip_proxy_v</b> = <a class="el" href="structjh_1_1ranges_1_1is__zip__proxy.html">is_zip_proxy</a>&lt;T&gt;::value</td></tr>
</table>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="a4fa041b6ca91a41909afcbf0251cadfd" name="a4fa041b6ca91a41909afcbf0251cadfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fa041b6ca91a41909afcbf0251cadfd">&#9670;&#160;</a></span>collect_adaptor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C, std::ranges::range R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto jh::ranges::collect_adaptor </td>
          <td>(</td>
          <td class="paramtype">R &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>r</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Core implementation for <code><a class="el" href="#ae066e3cad87b5bec3c061fc290e8ad73" title="Global instance of the collect adaptor.">jh::ranges::collect</a></code> adaptor. </p>
<p>Performs eager materialization of a range <code>R</code> into container <code>C</code>.</p>
<p>If <code>C</code> and <code>R</code> satisfy <code><a class="el" href="conceptjh_1_1concepts_1_1closable__container__for.html" title="Concept checking whether a container C can be directly constructed (&quot;closed&quot;) from a range R.">jh::concepts::closable_container_for&lt;C, R&gt;</a></code>, the operation directly delegates to <code><a class="el" href="#ae5e54c0ba31518c3451ad297dc995d15" title="Core implementation for jh::ranges::to adaptor.">jh::ranges::to_adaptor&lt;C&gt;</a></code> for optimal construction. Otherwise, it iterates through the range and fills <code>C</code> using one of the available mechanisms: </p>
<ul>
<li>
<b>insert()</b> — for associative containers (e.g. <code>std::set</code>). </li>
<li>
<b>emplace()</b> — for emplace-enabled containers (e.g. <code>std::unordered_set</code>). </li>
<li>
<b>emplace_back()</b> — for sequence containers (e.g. <code>std::vector</code>, <code>std::deque</code>). </li>
</ul>
<p>If the container supports <code>reserve()</code> and the range models <code>sized_range</code>, capacity is preallocated automatically. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">C</td><td>The target container type to be constructed. </td></tr>
    <tr><td class="paramname">R</td><td>The input range type to be materialized. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>The input range instance to be collected. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A fully constructed container <code>C</code> containing all elements from <code>r</code>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function forms the core of the <code>collect</code> pipeline adaptor. In most user code, it is preferable to use <code><a class="el" href="#ae066e3cad87b5bec3c061fc290e8ad73" title="Global instance of the collect adaptor.">jh::ranges::collect&lt;C&gt;</a></code> directly instead of invoking this function manually. </dd></dl>

</div>
</div>
<a id="a45b7964db45e11008ed857894b797b1f" name="a45b7964db45e11008ed857894b797b1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45b7964db45e11008ed857894b797b1f">&#9670;&#160;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t I, typename... Elems&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) jh::ranges::get </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structjh_1_1ranges_1_1zip__reference__proxy.html">zip_reference_proxy</a>&lt; Elems... &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the <code>I</code>-th element from a <code><a class="el" href="structjh_1_1ranges_1_1zip__reference__proxy.html" title="Aggregates element references for a single tuple in jh::ranges::zip_view.">zip_reference_proxy</a></code>. </p>
<p>This free function provides tuple-like access to elements within a <code><a class="el" href="structjh_1_1ranges_1_1zip__reference__proxy.html" title="Aggregates element references for a single tuple in jh::ranges::zip_view.">zip_reference_proxy</a></code>, enabling structured bindings and compatibility with <code>std::get</code> and <code>std::tuple_element</code>. </p>
<p>Internally, this simply forwards to <code>p.get&lt;I&gt;()</code>, preserving reference semantics and ensuring that both direct and wrapped elements yield proper references. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">I</td><td>The index of the element to retrieve. </td></tr>
    <tr><td class="paramname">Elems</td><td>Parameter pack of stored element types. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The <code><a class="el" href="structjh_1_1ranges_1_1zip__reference__proxy.html" title="Aggregates element references for a single tuple in jh::ranges::zip_view.">zip_reference_proxy</a></code> instance to access. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <code>I</code>-th element reference from the proxy.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structjh_1_1ranges_1_1zip__reference__proxy.html" title="Aggregates element references for a single tuple in jh::ranges::zip_view.">jh::ranges::zip_reference_proxy</a> </dd>
<dd>
std::get </dd></dl>

</div>
</div>
<a id="ae5e54c0ba31518c3451ad297dc995d15" name="ae5e54c0ba31518c3451ad297dc995d15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5e54c0ba31518c3451ad297dc995d15">&#9670;&#160;</a></span>to_adaptor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C, std::ranges::range R, typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto jh::ranges::to_adaptor </td>
          <td>(</td>
          <td class="paramtype">R &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>r</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Core implementation for <code><a class="el" href="#a722e1bdb5632bc636715eb47ed666b15" title="Global instance of the to adaptor.">jh::ranges::to</a></code> adaptor. </p>
<p>Constructs a container <code>C</code> from range <code>R</code> when the pair satisfies the <code>closable_container_for</code> concept. This includes direct iterator constructors, move iterators, vector bridging, and adapter-based composition (e.g. <code>std::stack&lt;std::deque&lt;T&gt;&gt;</code>).</p>
<p>This function is selected only if the relationship between <code>C</code> and <code>R</code> can be established at compile time. Otherwise, use <code><a class="el" href="#ae066e3cad87b5bec3c061fc290e8ad73" title="Global instance of the collect adaptor.">jh::ranges::collect</a></code> as a more permissive fallback. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">C</td><td>The target container type. </td></tr>
    <tr><td class="paramname">R</td><td>The input range type. </td></tr>
    <tr><td class="paramname">Args</td><td>Additional constructor argument types for <code>C</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>The source range. </td></tr>
    <tr><td class="paramname">args</td><td>Optional forwarded constructor arguments for <code>C</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A fully constructed container <code>C</code>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function forms the core implementation used by both direct calls and the pipe-style <code><a class="el" href="#a722e1bdb5632bc636715eb47ed666b15" title="Global instance of the to adaptor.">to&lt;C&gt;()</a></code> adaptor. </dd></dl>

</div>
</div>
<a id="ac6fdf84e31fa9f3144043534b5bdd61d" name="ac6fdf84e31fa9f3144043534b5bdd61d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6fdf84e31fa9f3144043534b5bdd61d">&#9670;&#160;</a></span>tuple_transform()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F, typename Tuple&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto jh::ranges::tuple_transform </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tuple &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies a callable to each element of a <code>std::tuple</code>. </p>
<p>This helper function iterates over all elements of a tuple and applies the provided callable <code>f</code> to each element, returning a new <code>std::tuple</code> containing the transformed results. </p>
<p>It is implemented using <code>std::index_sequence</code> expansion and perfect forwarding. This utility serves as a C++20-compatible equivalent to <code>std::apply</code> for element-wise transformation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>Callable type — must be invocable with each element of <code>Tuple</code>. </td></tr>
    <tr><td class="paramname">Tuple</td><td>The tuple-like type to be transformed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The callable to apply to each element. </td></tr>
    <tr><td class="paramname">t</td><td>The tuple whose elements are to be transformed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new <code>std::tuple</code> containing <code>f(get&lt;i&gt;(t))</code> for each element.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function preserves value category: <ul>
<li>
Lvalue elements are forwarded as references. </li>
<li>
Rvalue elements are moved when possible. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a6e3ad6d23ddde4e8bf0027ba266b09c2" name="a6e3ad6d23ddde4e8bf0027ba266b09c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e3ad6d23ddde4e8bf0027ba266b09c2">&#9670;&#160;</a></span>zip_view()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::ranges::viewable_range... Rs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">jh::ranges::zip_view </td>
          <td>(</td>
          <td class="paramtype">Rs &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>...</em></span></td><td>)</td>
          <td> -&gt;  zip_view&lt; std::views::all_t&lt; Rs &gt;... &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deduction guide for <code><a class="el" href="classjh_1_1ranges_1_1zip__view.html" title="A C++20-compatible implementation of std::ranges::zip_view.">jh::ranges::zip_view</a></code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Rs</td><td>The range types to be zipped.</td></tr>
  </table>
  </dd>
</dl>
<p>Allows automatic template argument deduction when constructing a <code><a class="el" href="classjh_1_1ranges_1_1zip__view.html" title="A C++20-compatible implementation of std::ranges::zip_view.">zip_view</a></code> directly. </p>

</div>
</div>
<a name="doc-var-members" id="doc-var-members"></a><h2 id="header-doc-var-members" class="groupheader">Variable Documentation</h2>
<a id="a149715b8becce19a693513225186d1ca" name="a149715b8becce19a693513225186d1ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a149715b8becce19a693513225186d1ca">&#9670;&#160;</a></span>adapt</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">detail::adapt_fn jh::ranges::adapt {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The user-facing <code>adapt</code> adaptor. </p>
<p>Provides both direct and pipeline conversion of any <code><a class="el" href="conceptjh_1_1concepts_1_1sequence.html" title="Concept that checks whether a type provides at least const (non-destructive) iteration.">jh::concepts::sequence</a></code> into a viewable range.</p>
<ul>
<li>
<code>auto r = <a class="el" href="#a149715b8becce19a693513225186d1ca" title="The user-facing adapt adaptor.">jh::ranges::adapt(seq)</a>;</code> </li>
<li>
<code>auto r = seq | <a class="el" href="#a149715b8becce19a693513225186d1ca" title="The user-facing adapt adaptor.">jh::ranges::adapt()</a>;</code> </li>
</ul>
<p>Acts as a bridge between <code><a class="el" href="conceptjh_1_1concepts_1_1sequence.html" title="Concept that checks whether a type provides at least const (non-destructive) iteration.">jh::concepts::sequence</a></code> and the C++23 <code><a class="el" href="namespacestd_1_1ranges.html">std::ranges</a></code> ecosystem.</p>
<dl class="section note"><dt>Note</dt><dd>Some types already model <code>std::ranges::range</code> but are <b>non-copyable</b> or <b>non-movable</b>. Such ranges cannot satisfy <code>std::ranges::viewable_range</code>, and thus cannot be used directly with <code>std::views::*</code> adaptors. <br  />
 Passing <b>non-copyable</b> or <b>non-movable</b> <span class="tt"><a class="el" href="namespacejh_1_1ranges.html">ranges</a></span> or any <b>non-standard</b> <span class="tt">sequences</span> through <code>adapt</code> (or equivalently <code><a class="el" href="namespacejh.html#a58aa95803840fb814bf92dd4954fb44c" title="Converts a generator factory (lambda or function) into a repeatable range.">jh::to_range()</a></code>) constructs a safe proxy — typically a <code>std::ranges::subrange</code> or <code><a class="el" href="classjh_1_1ranges_1_1range__adaptor.html" title="Lightweight adapter that exposes any sequence as a standard range.">jh::ranges::range_adaptor</a></code> — that <b>restores viewable_range compatibility</b>. <br  />
 Once adapted, these ranges can participate freely in <code>std::views</code> pipelines or <code><a class="el" href="namespacejh_1_1ranges_1_1views.html">jh::ranges::views</a></code> adaptors.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacejh.html#a58aa95803840fb814bf92dd4954fb44c" title="Converts a generator factory (lambda or function) into a repeatable range.">jh::to_range</a> </dd>
<dd>
<a class="el" href="conceptjh_1_1concepts_1_1sequence.html" title="Concept that checks whether a type provides at least const (non-destructive) iteration.">jh::concepts::sequence</a> </dd></dl>

</div>
</div>
<a id="ae066e3cad87b5bec3c061fc290e8ad73" name="ae066e3cad87b5bec3c061fc290e8ad73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae066e3cad87b5bec3c061fc290e8ad73">&#9670;&#160;</a></span>collect</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structjh_1_1ranges_1_1collect__fn.html">collect_fn</a>&lt;C&gt; jh::ranges::collect {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Global instance of the <code>collect</code> adaptor. </p>
<p>This is the primary user-facing interface for range materialization. It supports both direct and pipe usage styles:</p>
<p>Supports both <b>direct</b> and <b>pipe</b> usage forms: </p><ul>
<li>
<b>Direct form:</b> <code>auto v = <a class="el" href="#ae066e3cad87b5bec3c061fc290e8ad73" title="Global instance of the collect adaptor.">jh::ranges::collect&lt;std::vector&lt;int&gt;&gt;(input)</a>;</code> </li>
<li>
<b>Pipe form:</b> <code>auto v = range | <a class="el" href="#ae066e3cad87b5bec3c061fc290e8ad73" title="Global instance of the collect adaptor.">jh::ranges::collect&lt;std::vector&lt;int&gt;&gt;()</a>;</code> </li>
</ul>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<p><b>Recommendation:</b></p>
<p>If your goal is to explicitly materialize a lazy pipeline, <code>std::vector</code> is usually the best target container — it provides optimal contiguous storage and can be seamlessly passed to a subsequent <code>to&lt;C&gt;</code> stage for further conversion.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">C</td><td>The container type to collect into. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a722e1bdb5632bc636715eb47ed666b15" title="Global instance of the to adaptor.">jh::ranges::to</a> </dd>
<dd>
<a class="el" href="structjh_1_1ranges_1_1collect__fn.html" title="Function object implementing jh::ranges::collect.">jh::ranges::collect_fn</a> </dd></dl>

</div>
</div>
<a id="a722e1bdb5632bc636715eb47ed666b15" name="a722e1bdb5632bc636715eb47ed666b15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a722e1bdb5632bc636715eb47ed666b15">&#9670;&#160;</a></span>to</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structjh_1_1ranges_1_1to__fn.html">to_fn</a>&lt;C&gt; jh::ranges::to {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Global instance of the <code>to</code> adaptor. </p>
<p>This is the primary user-facing entry point for constructing containers from compatible ranges. It supports both direct and pipe invocation forms:</p>
<ul>
<li>
<b>Direct form:</b> <code>auto s = <a class="el" href="#a722e1bdb5632bc636715eb47ed666b15" title="Global instance of the to adaptor.">jh::ranges::to&lt;std::set&lt;int&gt;&gt;(v)</a>;</code> </li>
<li>
<b>Pipe form:</b> <code>auto dq = v | <a class="el" href="#a722e1bdb5632bc636715eb47ed666b15" title="Global instance of the to adaptor.">jh::ranges::to&lt;std::deque&lt;int&gt;&gt;()</a>;</code> </li>
</ul>
<p>The adaptor automatically distinguishes between these two forms by analyzing the argument category: when the first argument is a range, it performs an immediate container construction; otherwise, it returns a lightweight closure object suitable for pipe composition. </p>
<p>This behavior is <b>intentional and specification-safe</b> — no valid standard container constructor ever accepts two independent ranges, therefore this heuristic introduces no ambiguity for normal user code. </p>
<dl class="section note"><dt>Note</dt><dd>Use <code><a class="el" href="#ae066e3cad87b5bec3c061fc290e8ad73" title="Global instance of the collect adaptor.">jh::ranges::collect</a></code> instead if the range is not directly closable to the target container or involves non-copyable proxy views.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">C</td><td>The container type to construct. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ae066e3cad87b5bec3c061fc290e8ad73" title="Global instance of the collect adaptor.">jh::ranges::collect</a> </dd>
<dd>
<a class="el" href="structjh_1_1ranges_1_1to__fn.html" title="Function object implementing jh::ranges::to.">jh::ranges::to_fn</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
</div> <!-- top -->
<hr class="footer"/>
<div class="footer">
    <img class="footer-logo" src="Ojing.svg" alt="Ojing"/>
    <div class="footer-text">
        JH-Toolkit v1.4.0 · Generated by Doxygen
    </div>
    <div class="footer-note">
        We primarily support embedded documentation views in IDEs (classic CLion).
        To ensure compatibility with embedded rendering, some example code in this
        documentation intentionally contains HTML entities.
        In certain cases, Doxygen does not unescape these entities correctly.
        This is a known limitation and currently has no workaround.
    </div>
</div>
</body>
</html>
