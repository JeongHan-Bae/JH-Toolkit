<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.16.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>JH-Toolkit: jh::avl::tree_map&lt; K, V, Alloc &gt;::iterator Struct Reference</title>
<link rel="icon" href="Jindallae.svg" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="Oree.svg"/></td>
  <td id="projectalign">
   <div id="projectname">JH-Toolkit<span id="projectnumber">&#160;v1.4.0</span>
   </div>
   <div id="projectbrief">An engineering-oriented C++20 toolkit with duck-typed concepts, static design, async coroutines, and semantic containers — header-only, RTTI-free, and concurrency-friendly.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.16.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('structjh_1_1avl_1_1tree__map_1_1iterator.html','','structjh_1_1avl_1_1tree__map_1_1iterator-members'); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">jh::avl::tree_map&lt; K, V, Alloc &gt;::iterator Struct Reference<span class="mlabels"><span class="mlabel final">final</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>Bidirectional iterator providing in-order traversal.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="">jh/core/ordered_map.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-types" class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a77b348e9a9f86190095682e8516ba062" id="r_a77b348e9a9f86190095682e8516ba062"><td class="memItemLeft"><a id="a77b348e9a9f86190095682e8516ba062" name="a77b348e9a9f86190095682e8516ba062"></a>
using&#160;</td><td class="memItemRight"><b>base_type</b> = <a class="el" href="classjh_1_1avl_1_1tree__map.html#a6c85f80ca9075223b0812883d6032f24">tree_map</a></td></tr>
<tr class="memdesc:a77b348e9a9f86190095682e8516ba062"><td class="mdescLeft">&#160;</td><td class="mdescRight">Owning tree type. <br /></td></tr>
<tr class="memitem:a59baa77ab55492ad635d615a49992a44" id="r_a59baa77ab55492ad635d615a49992a44"><td class="memItemLeft"><a id="a59baa77ab55492ad635d615a49992a44" name="a59baa77ab55492ad635d615a49992a44"></a>
using&#160;</td><td class="memItemRight"><b>node_type</b> = detail::node_t&lt;K, V&gt;</td></tr>
<tr class="memdesc:a59baa77ab55492ad635d615a49992a44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Canonical node type used internally. <br /></td></tr>
<tr class="memitem:afc3dd96e75f8f45f6c6f2544aac85151" id="r_afc3dd96e75f8f45f6c6f2544aac85151"><td class="memItemLeft"><a id="afc3dd96e75f8f45f6c6f2544aac85151" name="afc3dd96e75f8f45f6c6f2544aac85151"></a>
using&#160;</td><td class="memItemRight"><b>iterator_concept</b> = std::bidirectional_iterator_tag</td></tr>
<tr class="memdesc:afc3dd96e75f8f45f6c6f2544aac85151"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator concept tag (bidirectional). <br /></td></tr>
<tr class="memitem:a51135314d4b4e96f1a71559b72ce1cd4" id="r_a51135314d4b4e96f1a71559b72ce1cd4"><td class="memItemLeft"><a id="a51135314d4b4e96f1a71559b72ce1cd4" name="a51135314d4b4e96f1a71559b72ce1cd4"></a>
using&#160;</td><td class="memItemRight"><b>value_type</b> = detail::base_t&lt;K, V&gt;</td></tr>
<tr class="memdesc:a51135314d4b4e96f1a71559b72ce1cd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value type exposed by dereferencing. <br /></td></tr>
<tr class="memitem:acf9e720874eca9c640a7e5bf7406df45" id="r_acf9e720874eca9c640a7e5bf7406df45"><td class="memItemLeft"><a id="acf9e720874eca9c640a7e5bf7406df45" name="acf9e720874eca9c640a7e5bf7406df45"></a>
using&#160;</td><td class="memItemRight"><b>reference</b> = detail::reference_t&lt;K, V&gt;</td></tr>
<tr class="memdesc:acf9e720874eca9c640a7e5bf7406df45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference type: const for set, mutable for map. <br /></td></tr>
<tr class="memitem:afade40c6d9135aa957991d975e53604d" id="r_afade40c6d9135aa957991d975e53604d"><td class="memItemLeft"><a id="afade40c6d9135aa957991d975e53604d" name="afade40c6d9135aa957991d975e53604d"></a>
using&#160;</td><td class="memItemRight"><b>pointer</b> = detail::pointer_t&lt;K, V&gt;</td></tr>
<tr class="memdesc:afade40c6d9135aa957991d975e53604d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer type: const for set, mutable for map. <br /></td></tr>
<tr class="memitem:a00e90e7f4ecbc739bcb44a77d5ca7425" id="r_a00e90e7f4ecbc739bcb44a77d5ca7425"><td class="memItemLeft"><a id="a00e90e7f4ecbc739bcb44a77d5ca7425" name="a00e90e7f4ecbc739bcb44a77d5ca7425"></a>
using&#160;</td><td class="memItemRight"><b>difference_type</b> = std::int64_t</td></tr>
<tr class="memdesc:a00e90e7f4ecbc739bcb44a77d5ca7425"><td class="mdescLeft">&#160;</td><td class="mdescRight">Difference type used for iterator arithmetic. <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:afd1e8c76ce7c78623c4e27e266c568e7" id="r_afd1e8c76ce7c78623c4e27e266c568e7"><td class="memItemLeft">&#160;</td><td class="memItemRight"><a class="el" href="#afd1e8c76ce7c78623c4e27e266c568e7">iterator</a> ()=default</td></tr>
<tr class="memdesc:afd1e8c76ce7c78623c4e27e266c568e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default-construct an iterator in a singular state.  <br /></td></tr>
<tr class="memitem:a9e3581fc2da6e2f7f0a018681421800c" id="r_a9e3581fc2da6e2f7f0a018681421800c"><td class="memItemLeft">&#160;</td><td class="memItemRight"><a class="el" href="#a9e3581fc2da6e2f7f0a018681421800c">iterator</a> (<a class="el" href="#a77b348e9a9f86190095682e8516ba062">base_type</a> *t, std::size_t i)</td></tr>
<tr class="memdesc:a9e3581fc2da6e2f7f0a018681421800c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an iterator referring to a specific node index.  <br /></td></tr>
<tr class="memitem:a493f4f85646a887a37838c734cb86fde" id="r_a493f4f85646a887a37838c734cb86fde"><td class="memItemLeft"><a class="el" href="#acf9e720874eca9c640a7e5bf7406df45">reference</a>&#160;</td><td class="memItemRight"><a class="el" href="#a493f4f85646a887a37838c734cb86fde">operator*</a> ()</td></tr>
<tr class="memdesc:a493f4f85646a887a37838c734cb86fde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dereference the iterator and obtain the referenced value.  <br /></td></tr>
<tr class="memitem:a534a6172f44e20b8b712614a38408316" id="r_a534a6172f44e20b8b712614a38408316"><td class="memItemLeft"><a class="el" href="#afade40c6d9135aa957991d975e53604d">pointer</a>&#160;</td><td class="memItemRight"><a class="el" href="#a534a6172f44e20b8b712614a38408316">operator-&gt;</a> ()</td></tr>
<tr class="memdesc:a534a6172f44e20b8b712614a38408316"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dereference the iterator and obtain a pointer to the value.  <br /></td></tr>
<tr class="memitem:a11bc505cf4723b21e9fd989f7d8bdd09" id="r_a11bc505cf4723b21e9fd989f7d8bdd09"><td class="memItemLeft"><a class="el" href="#acf9e720874eca9c640a7e5bf7406df45">reference</a>&#160;</td><td class="memItemRight"><a class="el" href="#a11bc505cf4723b21e9fd989f7d8bdd09">operator*</a> () const</td></tr>
<tr class="memdesc:a11bc505cf4723b21e9fd989f7d8bdd09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const-qualified dereference.  <br /></td></tr>
<tr class="memitem:abce8294c18464ea7a121342dcfe29349" id="r_abce8294c18464ea7a121342dcfe29349"><td class="memItemLeft"><a class="el" href="#afade40c6d9135aa957991d975e53604d">pointer</a>&#160;</td><td class="memItemRight"><a class="el" href="#abce8294c18464ea7a121342dcfe29349">operator-&gt;</a> () const</td></tr>
<tr class="memdesc:abce8294c18464ea7a121342dcfe29349"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const-qualified pointer dereference.  <br /></td></tr>
<tr class="memitem:affc56d3fc955cae59e72df17ad12323c" id="r_affc56d3fc955cae59e72df17ad12323c"><td class="memItemLeft">const <a class="el" href="structjh_1_1avl_1_1avl__node.html#aa0264e8debb087c2f5f3a000960b32f9">node_type::key_type</a> &amp;&#160;</td><td class="memItemRight"><a class="el" href="#affc56d3fc955cae59e72df17ad12323c">key</a> () const</td></tr>
<tr class="memdesc:affc56d3fc955cae59e72df17ad12323c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the key associated with the current node.  <br /></td></tr>
<tr class="memitem:adabf2edd5ed04f8678c86e5af3cbe69a" id="r_adabf2edd5ed04f8678c86e5af3cbe69a"><td class="memItemLeft"><a class="el" href="#afd1e8c76ce7c78623c4e27e266c568e7">iterator</a> &amp;&#160;</td><td class="memItemRight"><a class="el" href="#adabf2edd5ed04f8678c86e5af3cbe69a">operator++</a> ()</td></tr>
<tr class="memdesc:adabf2edd5ed04f8678c86e5af3cbe69a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advance to the in-order successor.  <br /></td></tr>
<tr class="memitem:a84007a67226a317c30a392fbc936ef52" id="r_a84007a67226a317c30a392fbc936ef52"><td class="memItemLeft"><a class="el" href="#afd1e8c76ce7c78623c4e27e266c568e7">iterator</a>&#160;</td><td class="memItemRight"><a class="el" href="#a84007a67226a317c30a392fbc936ef52">operator++</a> (int)</td></tr>
<tr class="memdesc:a84007a67226a317c30a392fbc936ef52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Post-increment: return the previous iterator value and advance to the in-order successor.  <br /></td></tr>
<tr class="memitem:a4503d635bc3ba2ef457aa5cffa18e17a" id="r_a4503d635bc3ba2ef457aa5cffa18e17a"><td class="memItemLeft"><a class="el" href="#afd1e8c76ce7c78623c4e27e266c568e7">iterator</a> &amp;&#160;</td><td class="memItemRight"><a class="el" href="#a4503d635bc3ba2ef457aa5cffa18e17a">operator--</a> ()</td></tr>
<tr class="memdesc:a4503d635bc3ba2ef457aa5cffa18e17a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move to the in-order predecessor.  <br /></td></tr>
<tr class="memitem:aab01268c2418c1b61308840d761b06f8" id="r_aab01268c2418c1b61308840d761b06f8"><td class="memItemLeft"><a class="el" href="#afd1e8c76ce7c78623c4e27e266c568e7">iterator</a>&#160;</td><td class="memItemRight"><a class="el" href="#aab01268c2418c1b61308840d761b06f8">operator--</a> (int)</td></tr>
<tr class="memdesc:aab01268c2418c1b61308840d761b06f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Post-decrement: return the previous iterator value and move to the in-order predecessor.  <br /></td></tr>
<tr class="memitem:ac0f03cd58772f6394c86934484d9cfbb" id="r_ac0f03cd58772f6394c86934484d9cfbb"><td class="memItemLeft">bool&#160;</td><td class="memItemRight"><a class="el" href="#ac0f03cd58772f6394c86934484d9cfbb">operator==</a> (const <a class="el" href="#afd1e8c76ce7c78623c4e27e266c568e7">iterator</a> &amp;other) const</td></tr>
<tr class="memdesc:ac0f03cd58772f6394c86934484d9cfbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two iterators for equality.  <br /></td></tr>
<tr class="memitem:ae1bb7516cd0f0898fca29d4fb5fa1539" id="r_ae1bb7516cd0f0898fca29d4fb5fa1539"><td class="memItemLeft">bool&#160;</td><td class="memItemRight"><a class="el" href="#ae1bb7516cd0f0898fca29d4fb5fa1539">operator!=</a> (const <a class="el" href="#afd1e8c76ce7c78623c4e27e266c568e7">iterator</a> &amp;other) const</td></tr>
<tr class="memdesc:ae1bb7516cd0f0898fca29d4fb5fa1539"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two iterators for inequality.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-attribs" class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a6ba4070e0714a9411db2c44ea1c61694" id="r_a6ba4070e0714a9411db2c44ea1c61694"><td class="memItemLeft"><a id="a6ba4070e0714a9411db2c44ea1c61694" name="a6ba4070e0714a9411db2c44ea1c61694"></a>
<a class="el" href="#a77b348e9a9f86190095682e8516ba062">base_type</a> *&#160;</td><td class="memItemRight"><b>tree</b> = nullptr</td></tr>
<tr class="memdesc:a6ba4070e0714a9411db2c44ea1c61694"><td class="mdescLeft">&#160;</td><td class="mdescRight">Owning tree instance (never nullptr except for default-constructed iterator). <br /></td></tr>
<tr class="memitem:a7fb61e8ed2b9e415f0d3e55c2c23f42a" id="r_a7fb61e8ed2b9e415f0d3e55c2c23f42a"><td class="memItemLeft"><a id="a7fb61e8ed2b9e415f0d3e55c2c23f42a" name="a7fb61e8ed2b9e415f0d3e55c2c23f42a"></a>
std::size_t&#160;</td><td class="memItemRight"><b>idx</b> = static_cast&lt;std::size_t&gt;(-1)</td></tr>
<tr class="memdesc:a7fb61e8ed2b9e415f0d3e55c2c23f42a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index of the referenced node, or <code>-1</code> for <code><a class="el" href="classjh_1_1avl_1_1tree__map.html#a8a853f97d468ebc517ae421526a31b42" title="Return the past-the-end iterator.">end()</a></code>. <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename K, typename V, typename Alloc = std::allocator&lt;detail::value_t&lt;K, V&gt;&gt;&gt;<br />
struct jh::avl::tree_map&lt; K, V, Alloc &gt;::iterator</div><p>Bidirectional iterator providing in-order traversal. </p>
<p>Iterator validity follows standard associative-container semantics:</p>
<ul>
<li>
<p class="startli"><code>erase(pos)</code> returns an iterator referring to the element that follows the erased one in sorted order. If no such element exists, the returned iterator is <code><a class="el" href="classjh_1_1avl_1_1tree__map.html#a8a853f97d468ebc517ae421526a31b42" title="Return the past-the-end iterator.">end()</a></code>. </p>
<p class="endli"></p>
</li>
<li>
<p class="startli">The returned iterator is the only one whose continued use is well-defined. All other iterators obtained before the erase operation must be considered invalid. </p>
<p class="endli"></p>
</li>
<li>
Insertions and erasures may relocate internal nodes to maintain contiguous storage. Therefore no iterator stability guarantees exist except for the iterator returned by <code><a class="el" href="classjh_1_1avl_1_1tree__map.html#a847de47716ae40afdd7ddbdd67d194f5" title="Erase the element referenced by the given iterator.">erase()</a></code>.  </li>
</ul>
<p>Dereferencing a valid iterator yields the stored element. Increment and decrement perform in-order successor/predecessor traversal with amortized constant cost. </p>
</div><a name="doc-constructors" id="doc-constructors"></a><h2 id="header-doc-constructors" class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="afd1e8c76ce7c78623c4e27e266c568e7" name="afd1e8c76ce7c78623c4e27e266c568e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd1e8c76ce7c78623c4e27e266c568e7">&#9670;&#160;</a></span>iterator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename Alloc = std::allocator&lt;detail::value_t&lt;K, V&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classjh_1_1avl_1_1tree__map.html">jh::avl::tree_map</a>&lt; K, V, Alloc &gt;::iterator::iterator </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel default">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default-construct an iterator in a singular state. </p>
<p>A default-constructed iterator does not refer to any tree and is therefore singular. It must not be compared, incremented, decremented, or dereferenced. The only valid operations on a singular iterator are assignment and destruction.</p>
<p>Note that this state is distinct from <code><a class="el" href="classjh_1_1avl_1_1tree__map.html#a8a853f97d468ebc517ae421526a31b42" title="Return the past-the-end iterator.">end()</a></code>: an end iterator is associated with a specific container and can be decremented to obtain the last element, whereas a singular iterator cannot participate in any traversal. </p>

</div>
</div>
<a id="a9e3581fc2da6e2f7f0a018681421800c" name="a9e3581fc2da6e2f7f0a018681421800c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e3581fc2da6e2f7f0a018681421800c">&#9670;&#160;</a></span>iterator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename Alloc = std::allocator&lt;detail::value_t&lt;K, V&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classjh_1_1avl_1_1tree__map.html">jh::avl::tree_map</a>&lt; K, V, Alloc &gt;::iterator::iterator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a77b348e9a9f86190095682e8516ba062">base_type</a> *</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>i</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an iterator referring to a specific node index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Pointer to the owning tree. </td></tr>
    <tr><td class="paramname">i</td><td>Node index, or <code>-1</code> to represent <code><a class="el" href="classjh_1_1avl_1_1tree__map.html#a8a853f97d468ebc517ae421526a31b42" title="Return the past-the-end iterator.">end()</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<p>This constructor is primarily used internally when producing <code><a class="el" href="classjh_1_1avl_1_1tree__map.html#a5b8d6f0d9e6bd7c196e825cba002b646" title="Return an iterator to the smallest element.">begin()</a></code>, <code><a class="el" href="classjh_1_1avl_1_1tree__map.html#a8a853f97d468ebc517ae421526a31b42" title="Return the past-the-end iterator.">end()</a></code>, and traversal results. Users normally do not instantiate iterators directly. </p>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="affc56d3fc955cae59e72df17ad12323c" name="affc56d3fc955cae59e72df17ad12323c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affc56d3fc955cae59e72df17ad12323c">&#9670;&#160;</a></span>key()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename Alloc = std::allocator&lt;detail::value_t&lt;K, V&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structjh_1_1avl_1_1avl__node.html#aa0264e8debb087c2f5f3a000960b32f9">node_type::key_type</a> &amp; <a class="el" href="classjh_1_1avl_1_1tree__map.html">jh::avl::tree_map</a>&lt; K, V, Alloc &gt;::iterator::key </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain the key associated with the current node. </p>
<dl class="section return"><dt>Returns</dt><dd>Constant reference to the key of the referenced element.</dd></dl>
<p>Provided as a convenience for callers that require direct access to the ordering key. Undefined behavior if the iterator equals <code><a class="el" href="classjh_1_1avl_1_1tree__map.html#a8a853f97d468ebc517ae421526a31b42" title="Return the past-the-end iterator.">end()</a></code>. </p>

</div>
</div>
<a id="ae1bb7516cd0f0898fca29d4fb5fa1539" name="ae1bb7516cd0f0898fca29d4fb5fa1539"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1bb7516cd0f0898fca29d4fb5fa1539">&#9670;&#160;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename Alloc = std::allocator&lt;detail::value_t&lt;K, V&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classjh_1_1avl_1_1tree__map.html">jh::avl::tree_map</a>&lt; K, V, Alloc &gt;::iterator::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#afd1e8c76ce7c78623c4e27e266c568e7">iterator</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare two iterators for inequality. </p>
<p>Equivalent to <code>!(a == b)</code>.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the iterators are not equal. </dd></dl>

</div>
</div>
<a id="a493f4f85646a887a37838c734cb86fde" name="a493f4f85646a887a37838c734cb86fde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a493f4f85646a887a37838c734cb86fde">&#9670;&#160;</a></span>operator*() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename Alloc = std::allocator&lt;detail::value_t&lt;K, V&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#acf9e720874eca9c640a7e5bf7406df45">reference</a> <a class="el" href="classjh_1_1avl_1_1tree__map.html">jh::avl::tree_map</a>&lt; K, V, Alloc &gt;::iterator::operator* </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dereference the iterator and obtain the referenced value. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the value stored at the current position.</dd></dl>
<p>Undefined behavior occurs if the iterator does not refer to a valid element (e.g., it equals <code><a class="el" href="classjh_1_1avl_1_1tree__map.html#a8a853f97d468ebc517ae421526a31b42" title="Return the past-the-end iterator.">end()</a></code>). </p>

</div>
</div>
<a id="a11bc505cf4723b21e9fd989f7d8bdd09" name="a11bc505cf4723b21e9fd989f7d8bdd09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11bc505cf4723b21e9fd989f7d8bdd09">&#9670;&#160;</a></span>operator*() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename Alloc = std::allocator&lt;detail::value_t&lt;K, V&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#acf9e720874eca9c640a7e5bf7406df45">reference</a> <a class="el" href="classjh_1_1avl_1_1tree__map.html">jh::avl::tree_map</a>&lt; K, V, Alloc &gt;::iterator::operator* </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Const-qualified dereference. </p>
<dl class="section return"><dt>Returns</dt><dd>Const reference to the stored value.</dd></dl>
<p>Undefined behavior if the iterator equals <code><a class="el" href="classjh_1_1avl_1_1tree__map.html#a8a853f97d468ebc517ae421526a31b42" title="Return the past-the-end iterator.">end()</a></code>. </p>

</div>
</div>
<a id="adabf2edd5ed04f8678c86e5af3cbe69a" name="adabf2edd5ed04f8678c86e5af3cbe69a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adabf2edd5ed04f8678c86e5af3cbe69a">&#9670;&#160;</a></span>operator++() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename Alloc = std::allocator&lt;detail::value_t&lt;K, V&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#afd1e8c76ce7c78623c4e27e266c568e7">iterator</a> &amp; <a class="el" href="classjh_1_1avl_1_1tree__map.html">jh::avl::tree_map</a>&lt; K, V, Alloc &gt;::iterator::operator++ </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Advance to the in-order successor. </p>
<p>Performs an in-order successor step. The behavior follows standard bidirectional-iterator rules:</p>
<ul>
<li>
If the iterator is <code><a class="el" href="classjh_1_1avl_1_1tree__map.html#a8a853f97d468ebc517ae421526a31b42" title="Return the past-the-end iterator.">end()</a></code>, incrementing leaves it unchanged.  </li>
<li>
Otherwise, the iterator moves to the next element in sorted key order.  </li>
<li>
Undefined behavior results if the iterator is in a singular state (e.g., default-constructed).  </li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>Reference to <code>*this</code>. </dd></dl>

</div>
</div>
<a id="a84007a67226a317c30a392fbc936ef52" name="a84007a67226a317c30a392fbc936ef52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84007a67226a317c30a392fbc936ef52">&#9670;&#160;</a></span>operator++() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename Alloc = std::allocator&lt;detail::value_t&lt;K, V&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#afd1e8c76ce7c78623c4e27e266c568e7">iterator</a> <a class="el" href="classjh_1_1avl_1_1tree__map.html">jh::avl::tree_map</a>&lt; K, V, Alloc &gt;::iterator::operator++ </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Post-increment: return the previous iterator value and advance to the in-order successor. </p>
<p>Equivalent to creating a copy, performing <code>++(*this)</code>, and returning the saved copy. Follows the same semantic rules as <code><a class="el" href="#adabf2edd5ed04f8678c86e5af3cbe69a" title="Advance to the in-order successor.">operator++()</a></code>.</p>
<dl class="section return"><dt>Returns</dt><dd>A copy of the iterator before incrementing. </dd></dl>

</div>
</div>
<a id="a4503d635bc3ba2ef457aa5cffa18e17a" name="a4503d635bc3ba2ef457aa5cffa18e17a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4503d635bc3ba2ef457aa5cffa18e17a">&#9670;&#160;</a></span>operator--() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename Alloc = std::allocator&lt;detail::value_t&lt;K, V&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#afd1e8c76ce7c78623c4e27e266c568e7">iterator</a> &amp; <a class="el" href="classjh_1_1avl_1_1tree__map.html">jh::avl::tree_map</a>&lt; K, V, Alloc &gt;::iterator::operator-- </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move to the in-order predecessor. </p>
<p>Performs an in-order predecessor step. Bidirectional-iterator semantics apply:</p>
<ul>
<li>
<p class="startli">If the iterator is <code><a class="el" href="classjh_1_1avl_1_1tree__map.html#a8a853f97d468ebc517ae421526a31b42" title="Return the past-the-end iterator.">end()</a></code>, decrementing moves it to the last element (the greatest key), or leaves it unchanged if the container is empty. </p>
<p class="endli"></p>
</li>
<li>
<p class="startli">If the iterator refers to the first element (<code><a class="el" href="classjh_1_1avl_1_1tree__map.html#a5b8d6f0d9e6bd7c196e825cba002b646" title="Return an iterator to the smallest element.">begin()</a></code>), decrementing moves it to <code><a class="el" href="classjh_1_1avl_1_1tree__map.html#a8a853f97d468ebc517ae421526a31b42" title="Return the past-the-end iterator.">end()</a></code>. </p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Otherwise, the iterator moves to the previous element in sorted key order. </p>
<p class="endli"></p>
</li>
<li>
Undefined behavior results if the iterator is singular (e.g., default-constructed).  </li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>Reference to <code>*this</code>. </dd></dl>

</div>
</div>
<a id="aab01268c2418c1b61308840d761b06f8" name="aab01268c2418c1b61308840d761b06f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab01268c2418c1b61308840d761b06f8">&#9670;&#160;</a></span>operator--() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename Alloc = std::allocator&lt;detail::value_t&lt;K, V&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#afd1e8c76ce7c78623c4e27e266c568e7">iterator</a> <a class="el" href="classjh_1_1avl_1_1tree__map.html">jh::avl::tree_map</a>&lt; K, V, Alloc &gt;::iterator::operator-- </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Post-decrement: return the previous iterator value and move to the in-order predecessor. </p>
<p>Equivalent to creating a copy, performing <code>&ndash;(*this)</code>, and returning the saved copy. Follows the same semantic rules as <code><a class="el" href="#a4503d635bc3ba2ef457aa5cffa18e17a" title="Move to the in-order predecessor.">operator--()</a></code>.</p>
<dl class="section return"><dt>Returns</dt><dd>A copy of the iterator before decrementing. </dd></dl>

</div>
</div>
<a id="a534a6172f44e20b8b712614a38408316" name="a534a6172f44e20b8b712614a38408316"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a534a6172f44e20b8b712614a38408316">&#9670;&#160;</a></span>operator-&gt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename Alloc = std::allocator&lt;detail::value_t&lt;K, V&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#afade40c6d9135aa957991d975e53604d">pointer</a> <a class="el" href="classjh_1_1avl_1_1tree__map.html">jh::avl::tree_map</a>&lt; K, V, Alloc &gt;::iterator::operator-&gt; </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dereference the iterator and obtain a pointer to the value. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the referenced element.</dd></dl>
<p>Undefined behavior if the iterator equals <code><a class="el" href="classjh_1_1avl_1_1tree__map.html#a8a853f97d468ebc517ae421526a31b42" title="Return the past-the-end iterator.">end()</a></code>. </p>

</div>
</div>
<a id="abce8294c18464ea7a121342dcfe29349" name="abce8294c18464ea7a121342dcfe29349"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abce8294c18464ea7a121342dcfe29349">&#9670;&#160;</a></span>operator-&gt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename Alloc = std::allocator&lt;detail::value_t&lt;K, V&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#afade40c6d9135aa957991d975e53604d">pointer</a> <a class="el" href="classjh_1_1avl_1_1tree__map.html">jh::avl::tree_map</a>&lt; K, V, Alloc &gt;::iterator::operator-&gt; </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Const-qualified pointer dereference. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the constant stored value.</dd></dl>
<p>Undefined behavior if the iterator equals <code><a class="el" href="classjh_1_1avl_1_1tree__map.html#a8a853f97d468ebc517ae421526a31b42" title="Return the past-the-end iterator.">end()</a></code>. </p>

</div>
</div>
<a id="ac0f03cd58772f6394c86934484d9cfbb" name="ac0f03cd58772f6394c86934484d9cfbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0f03cd58772f6394c86934484d9cfbb">&#9670;&#160;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename Alloc = std::allocator&lt;detail::value_t&lt;K, V&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classjh_1_1avl_1_1tree__map.html">jh::avl::tree_map</a>&lt; K, V, Alloc &gt;::iterator::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#afd1e8c76ce7c78623c4e27e266c568e7">iterator</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare two iterators for equality. </p>
<p>Two iterators are equal only if they refer to the same container and the same logical position. Singular iterators compare equal only if both are singular.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if both iterators are equal. </dd></dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>include/jh/core/<a class="el" href="">ordered_map.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
</div> <!-- top -->
<hr class="footer"/>
<div class="footer">
    <img class="footer-logo" src="Ojing.svg" alt="Ojing"/>
    <div class="footer-text">
        JH-Toolkit v1.4.0 · Generated by Doxygen
    </div>
    <div class="footer-note">
        We primarily support embedded documentation views in IDEs (classic CLion).
        To ensure compatibility with embedded rendering, some example code in this
        documentation intentionally contains HTML entities.
        In certain cases, Doxygen does not unescape these entities correctly.
        This is a known limitation and currently has no workaround.
    </div>
</div>
</body>
</html>
