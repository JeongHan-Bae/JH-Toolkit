<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.16.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>JH-Toolkit: jh::async::generator&lt; T, U &gt; Class Template Reference</title>
<link rel="icon" href="Jindallae.svg" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="Oree.svg"/></td>
  <td id="projectalign">
   <div id="projectname">JH-Toolkit<span id="projectnumber">&#160;v1.4.0</span>
   </div>
   <div id="projectbrief">An engineering-oriented C++20 toolkit with duck-typed concepts, static design, async coroutines, and semantic containers — header-only, RTTI-free, and concurrency-friendly.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.16.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('classjh_1_1async_1_1generator.html','','classjh_1_1async_1_1generator-members'); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">jh::async::generator&lt; T, U &gt; Class Template Reference<span class="mlabels"><span class="mlabel final">final</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>Coroutine-based generator supporting both yielding and receiving values.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="">jh/asynchronous/generator.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:iterator" id="r_iterator"><td class="memItemLeft">struct &#160;</td><td class="memItemRight"><a class="el" href="structjh_1_1async_1_1generator_1_1iterator.html">iterator</a></td></tr>
<tr class="memitem:promise_5Ftype" id="r_promise_5Ftype"><td class="memItemLeft">struct &#160;</td><td class="memItemRight"><a class="el" href="structjh_1_1async_1_1generator_1_1promise__type.html">promise_type</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-types" class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a39a9dd39b8d1784e9d0981271df5a3f7" id="r_a39a9dd39b8d1784e9d0981271df5a3f7"><td class="memItemLeft">using&#160;</td><td class="memItemRight"><a class="el" href="#a39a9dd39b8d1784e9d0981271df5a3f7">value_type</a> = T</td></tr>
<tr class="memdesc:a39a9dd39b8d1784e9d0981271df5a3f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias for the value type produced by the generator.  <br /></td></tr>
<tr class="memitem:acc00a6b144d0e970529b6b1b924c0b7f" id="r_acc00a6b144d0e970529b6b1b924c0b7f"><td class="memItemLeft"><a id="acc00a6b144d0e970529b6b1b924c0b7f" name="acc00a6b144d0e970529b6b1b924c0b7f"></a>
using&#160;</td><td class="memItemRight"><b>send_type</b> = U</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae80600cfd6a9766f6d8e95bb8b5783c4" id="r_ae80600cfd6a9766f6d8e95bb8b5783c4"><td class="memItemLeft">&#160;</td><td class="memItemRight"><a class="el" href="#ae80600cfd6a9766f6d8e95bb8b5783c4">generator</a> (const generator &amp;)=delete</td></tr>
<tr class="memdesc:ae80600cfd6a9766f6d8e95bb8b5783c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deleted copy constructor.  <br /></td></tr>
<tr class="memitem:aed3219555ec237b762bc073381e7332d" id="r_aed3219555ec237b762bc073381e7332d"><td class="memItemLeft"><a class="el" href="#ae80600cfd6a9766f6d8e95bb8b5783c4">generator</a> &amp;&#160;</td><td class="memItemRight"><a class="el" href="#aed3219555ec237b762bc073381e7332d">operator=</a> (const <a class="el" href="#ae80600cfd6a9766f6d8e95bb8b5783c4">generator</a> &amp;)=delete</td></tr>
<tr class="memdesc:aed3219555ec237b762bc073381e7332d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deleted copy assignment operator.  <br /></td></tr>
<tr class="memitem:aea4c5ef34110f36b27f1b7675c0a28d1" id="r_aea4c5ef34110f36b27f1b7675c0a28d1"><td class="memItemLeft">&#160;</td><td class="memItemRight"><a class="el" href="#aea4c5ef34110f36b27f1b7675c0a28d1">generator</a> (generator &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:aea4c5ef34110f36b27f1b7675c0a28d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor.  <br /></td></tr>
<tr class="memitem:af36e5af85d528a1a14317a2d4c75fa44" id="r_af36e5af85d528a1a14317a2d4c75fa44"><td class="memItemLeft"><a class="el" href="#ae80600cfd6a9766f6d8e95bb8b5783c4">generator</a> &amp;&#160;</td><td class="memItemRight"><a class="el" href="#af36e5af85d528a1a14317a2d4c75fa44">operator=</a> (<a class="el" href="#ae80600cfd6a9766f6d8e95bb8b5783c4">generator</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:af36e5af85d528a1a14317a2d4c75fa44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator.  <br /></td></tr>
<tr class="memitem:a25356e4aa7f684e26e36cfe31e3b153d" id="r_a25356e4aa7f684e26e36cfe31e3b153d"><td class="memItemLeft">&#160;</td><td class="memItemRight"><a class="el" href="#a25356e4aa7f684e26e36cfe31e3b153d">generator</a> (std::coroutine_handle&lt; <a class="el" href="structjh_1_1async_1_1generator_1_1promise__type.html">promise_type</a> &gt; h)</td></tr>
<tr class="memdesc:a25356e4aa7f684e26e36cfe31e3b153d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <code>generator</code> directly from its coroutine handle.  <br /></td></tr>
<tr class="memitem:a87c9dd875e47593f114df3609894b28c" id="r_a87c9dd875e47593f114df3609894b28c"><td class="memItemLeft"><a id="a87c9dd875e47593f114df3609894b28c" name="a87c9dd875e47593f114df3609894b28c"></a>
&#160;</td><td class="memItemRight"><b>~generator</b> ()</td></tr>
<tr class="memdesc:a87c9dd875e47593f114df3609894b28c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the coroutine handle if it exists. <br /></td></tr>
<tr class="memitem:a9ddd3617dfd063ff8250bc919569fad2" id="r_a9ddd3617dfd063ff8250bc919569fad2"><td class="memItemLeft">bool&#160;</td><td class="memItemRight"><a class="el" href="#a9ddd3617dfd063ff8250bc919569fad2">next</a> ()</td></tr>
<tr class="memdesc:a9ddd3617dfd063ff8250bc919569fad2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advances the generator to the next value.  <br /></td></tr>
<tr class="memitem:a6ba6bbc31f7846d3c36e287c66e22c3d" id="r_a6ba6bbc31f7846d3c36e287c66e22c3d"><td class="memItemLeft">bool&#160;</td><td class="memItemRight"><a class="el" href="#a6ba6bbc31f7846d3c36e287c66e22c3d">done</a> () const noexcept</td></tr>
<tr class="memdesc:a6ba6bbc31f7846d3c36e287c66e22c3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the generator has completed execution.  <br /></td></tr>
<tr class="memitem:a32723357595fa1b4288e472e0b7b1ea1" id="r_a32723357595fa1b4288e472e0b7b1ea1"><td class="memItemLeft">bool&#160;</td><td class="memItemRight"><a class="el" href="#a32723357595fa1b4288e472e0b7b1ea1">send</a> (send_type <a class="el" href="#a4683d1bb9875f9919228bfaa288645ba">value</a>)</td></tr>
<tr class="memdesc:a32723357595fa1b4288e472e0b7b1ea1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a value to the generator and resumes execution.  <br /></td></tr>
<tr class="memitem:a59f3bdd3bff5c7cca3aced632872a930" id="r_a59f3bdd3bff5c7cca3aced632872a930"><td class="memItemLeft">bool&#160;</td><td class="memItemRight"><a class="el" href="#a59f3bdd3bff5c7cca3aced632872a930">send_ite</a> (send_type <a class="el" href="#a4683d1bb9875f9919228bfaa288645ba">value</a>)</td></tr>
<tr class="memdesc:a59f3bdd3bff5c7cca3aced632872a930"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advances the generator and sends a value in one step.  <br /></td></tr>
<tr class="memitem:a4683d1bb9875f9919228bfaa288645ba" id="r_a4683d1bb9875f9919228bfaa288645ba"><td class="memItemLeft">std::optional&lt; <a class="el" href="#a39a9dd39b8d1784e9d0981271df5a3f7">value_type</a> &gt;&#160;</td><td class="memItemRight"><a class="el" href="#a4683d1bb9875f9919228bfaa288645ba">value</a> () const noexcept</td></tr>
<tr class="memdesc:a4683d1bb9875f9919228bfaa288645ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the currently yielded value.  <br /></td></tr>
<tr class="memitem:a4cb85e765fdead38d75352a884719872" id="r_a4cb85e765fdead38d75352a884719872"><td class="memItemLeft">std::optional&lt; send_type &gt;&#160;</td><td class="memItemRight"><a class="el" href="#a4cb85e765fdead38d75352a884719872">last_sent_value</a> () const noexcept</td></tr>
<tr class="memdesc:a4cb85e765fdead38d75352a884719872"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the last value sent to the generator.  <br /></td></tr>
<tr class="memitem:aab5b5530136c783150c2da5cb0e6d115" id="r_aab5b5530136c783150c2da5cb0e6d115"><td class="memItemLeft"><a id="aab5b5530136c783150c2da5cb0e6d115" name="aab5b5530136c783150c2da5cb0e6d115"></a>
void&#160;</td><td class="memItemRight"><b>stop</b> ()</td></tr>
<tr class="memdesc:aab5b5530136c783150c2da5cb0e6d115"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops the generator and destroys the coroutine. <br /></td></tr>
<tr class="memitem:ae106494a9c8e1a0fec3a9d89f1af5c57" id="r_ae106494a9c8e1a0fec3a9d89f1af5c57"><td class="memItemLeft"><a class="el" href="structjh_1_1async_1_1generator_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight"><a class="el" href="#ae106494a9c8e1a0fec3a9d89f1af5c57">begin</a> ()</td></tr>
<tr class="memdesc:ae106494a9c8e1a0fec3a9d89f1af5c57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator for ranged-for loops.  <br /></td></tr>
<tr class="memitem:a572fbf9f8fe9e38a8567a9659521b18d" id="r_a572fbf9f8fe9e38a8567a9659521b18d"><td class="memItemLeft"><a class="el" href="structjh_1_1async_1_1generator_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight"><a class="el" href="#a572fbf9f8fe9e38a8567a9659521b18d">begin</a> () const =delete</td></tr>
<tr class="memdesc:a572fbf9f8fe9e38a8567a9659521b18d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deleted <code>const</code> overload of <code><a class="el" href="#ae106494a9c8e1a0fec3a9d89f1af5c57" title="Returns an iterator for ranged-for loops.">begin()</a></code>.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-static-methods" class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ad1ddf7282fa548247ee9567938ac1e5f" id="r_ad1ddf7282fa548247ee9567938ac1e5f"><td class="memItemLeft">static <a class="el" href="structjh_1_1async_1_1generator_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight"><a class="el" href="#ad1ddf7282fa548247ee9567938ac1e5f">end</a> ()</td></tr>
<tr class="memdesc:ad1ddf7282fa548247ee9567938ac1e5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a sentinel iterator representing the end of the generator sequence.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-attribs" class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a2fb7224621c0037b9fae9dec80cb7526" id="r_a2fb7224621c0037b9fae9dec80cb7526"><td class="memItemLeft"><a id="a2fb7224621c0037b9fae9dec80cb7526" name="a2fb7224621c0037b9fae9dec80cb7526"></a>
std::coroutine_handle&lt; <a class="el" href="structjh_1_1async_1_1generator_1_1promise__type.html">promise_type</a> &gt;&#160;</td><td class="memItemRight"><b>co_ro</b></td></tr>
<tr class="memdesc:a2fb7224621c0037b9fae9dec80cb7526"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle to the coroutine. <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename T, typename U = typed::monostate&gt;<br />
requires std::is_copy_constructible_v&lt;T&gt;<br />
class jh::async::generator&lt; T, U &gt;</div><p>Coroutine-based generator supporting both yielding and receiving values. </p>
<p>This class implements a coroutine-driven sequence producer, conceptually equivalent to Python's <span class="tt">Generator[T, U, None]</span>. It provides a clear and type-safe interface for two-way coroutine communication: </p><ul>
<li>
<b>Yield</b> — values are produced via <code>co_yield</code>. </li>
<li>
<b>Await</b> — inputs are received via <code>co_await</code>, corresponding to <code><a class="el" href="#a32723357595fa1b4288e472e0b7b1ea1" title="Sends a value to the generator and resumes execution.">send()</a></code>. </li>
</ul>
<p>A generator is a <b>consumable object</b> — each call to <code><a class="el" href="#a9ddd3617dfd063ff8250bc919569fad2" title="Advances the generator to the next value.">next()</a></code> or <code><a class="el" href="#a32723357595fa1b4288e472e0b7b1ea1" title="Sends a value to the generator and resumes execution.">send()</a></code> advances its internal coroutine state. Once advanced, previously yielded values cannot be revisited.</p>
<p>Values produced by <code>co_yield</code> are retrieved via <code>.<a class="el" href="#a4683d1bb9875f9919228bfaa288645ba" title="Retrieves the currently yielded value.">value()</a></code>, which returns <code>std::optional&lt;T&gt;</code>. Before the first <code><a class="el" href="#a9ddd3617dfd063ff8250bc919569fad2" title="Advances the generator to the next value.">next()</a></code> call or after completion, this optional contains <code>std::nullopt</code>.</p>
<p><b>When consuming generator outputs:</b></p>
<ul>
<li>
Use <code>.<a class="el" href="#a4683d1bb9875f9919228bfaa288645ba" title="Retrieves the currently yielded value.">value()</a>.<a class="el" href="#a4683d1bb9875f9919228bfaa288645ba" title="Retrieves the currently yielded value.">value()</a></code> when you are certain a value exists (i.e. immediately after a successful <code><a class="el" href="#a9ddd3617dfd063ff8250bc919569fad2" title="Advances the generator to the next value.">next()</a></code>). </li>
<li>
Check <code>.<a class="el" href="#a4683d1bb9875f9919228bfaa288645ba" title="Retrieves the currently yielded value.">value()</a>.has_value()</code> before dereferencing if unsure. </li>
<li>
Convert to containers via <code><a class="el" href="namespacejh_1_1async.html#a17777ad53ec96266cfc3e5d7abe763c8" title="Collects all yielded values from a generator into a std::vector.">jh::async::to_vector()</a></code> or <code><a class="el" href="namespacejh_1_1async.html#aa136f6ea5f81fa00a4f1bf070cd8ff97" title="Collects all yielded values from a generator into a std::deque.">jh::async::to_deque()</a></code>. </li>
<li>
For repeatable iteration, wrap a <em>generator-producing function</em> (e.g. a lambda returning a new generator) using <code><a class="el" href="namespacejh.html#a58aa95803840fb814bf92dd4954fb44c" title="Converts a generator factory (lambda or function) into a repeatable range.">jh::to_range()</a></code>, instead of passing a generator instance directly. </li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The yielded value type (produced by <code>co_yield</code>). Must be copy-constructible since it is stored within <code>std::optional&lt;T&gt;</code>. Prefer trivially copyable or POD-like types for best performance: <ul>
<li>
POD types such as <code>int</code>, <code>float</code>, <code><a class="el" href="structjh_1_1pod_1_1pair.html" title="POD-compatible aggregate of two values, equivalent in layout to a plain struct.">jh::pod::pair</a></code>. </li>
<li>
Trivial objects such as <code>std::array</code>, <code>std::string</code>. </li>
</ul>
</td></tr>
    <tr><td class="paramname">U</td><td>The input type sent to the generator (via <code><a class="el" href="#a32723357595fa1b4288e472e0b7b1ea1" title="Sends a value to the generator and resumes execution.">send()</a></code> or <code><a class="el" href="#a59f3bdd3bff5c7cca3aced632872a930" title="Advances the generator and sends a value in one step.">send_ite()</a></code>). Corresponds to values received by <code>co_await</code> inside the coroutine. Defaults to <code><a class="el" href="structjh_1_1typed_1_1monostate.html" title="Trivial empty type representing &quot;no value&quot;.">typed::monostate</a></code>, making the generator a pure output sequence.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Move-only types (e.g. <code>std::unique_ptr&lt;T&gt;</code>) are not supported by default because the implementation relies on <code>std::optional&lt;T&gt;</code>. To support them, implement a custom buffering or ownership model. </dd></dl>
</div><a name="doc-typedef-members" id="doc-typedef-members"></a><h2 id="header-doc-typedef-members" class="groupheader">Member Typedef Documentation</h2>
<a id="a39a9dd39b8d1784e9d0981271df5a3f7" name="a39a9dd39b8d1784e9d0981271df5a3f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39a9dd39b8d1784e9d0981271df5a3f7">&#9670;&#160;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename U = typed::monostate&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classjh_1_1async_1_1generator.html">jh::async::generator</a>&lt; T, U &gt;::value_type = T</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type alias for the value type produced by the generator. </p>
<p>Type alias for the value type sent to the generator. </p>

</div>
</div>
<a name="doc-constructors" id="doc-constructors"></a><h2 id="header-doc-constructors" class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ae80600cfd6a9766f6d8e95bb8b5783c4" name="ae80600cfd6a9766f6d8e95bb8b5783c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae80600cfd6a9766f6d8e95bb8b5783c4">&#9670;&#160;</a></span>generator() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename U = typed::monostate&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classjh_1_1async_1_1generator.html">jh::async::generator</a>&lt; T, U &gt;::generator </td>
          <td>(</td>
          <td class="paramtype">const generator&lt; T, U &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel delete">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deleted copy constructor. </p>
<p>Since <code><a class="el" href="classjh_1_1async_1_1generator.html">generator&lt;T, U&gt;</a></code> manages a coroutine handle (<code>std::coroutine_handle&lt;promise_type&gt;</code>), copying the generator would lead to double ownership issues.</p>
<p>To prevent accidental copies, the copy constructor is explicitly deleted.</p>

</div>
</div>
<a id="aea4c5ef34110f36b27f1b7675c0a28d1" name="aea4c5ef34110f36b27f1b7675c0a28d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea4c5ef34110f36b27f1b7675c0a28d1">&#9670;&#160;</a></span>generator() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename U = typed::monostate&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classjh_1_1async_1_1generator.html">jh::async::generator</a>&lt; T, U &gt;::generator </td>
          <td>(</td>
          <td class="paramtype">generator&lt; T, U &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor. </p>
<p>Transfers ownership of the coroutine handle from <span class="tt">other</span> to <span class="tt">this</span>. </p><ul>
<li>
The <code>other</code> generator is set to <code>nullptr</code> to prevent double destruction. </li>
<li>
This ensures safe movement of generator instances. </li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The generator to move from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a25356e4aa7f684e26e36cfe31e3b153d" name="a25356e4aa7f684e26e36cfe31e3b153d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25356e4aa7f684e26e36cfe31e3b153d">&#9670;&#160;</a></span>generator() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename U = typed::monostate&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classjh_1_1async_1_1generator.html">jh::async::generator</a>&lt; T, U &gt;::generator </td>
          <td>(</td>
          <td class="paramtype">std::coroutine_handle&lt; <a class="el" href="structjh_1_1async_1_1generator_1_1promise__type.html">promise_type</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>h</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel explicit">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a <code>generator</code> directly from its coroutine handle. </p>
<p>This constructor is the linkage point between the coroutine's <code><a class="el" href="structjh_1_1async_1_1generator_1_1promise__type.html">promise_type</a></code> and its corresponding <code><a class="el" href="classjh_1_1async_1_1generator.html">jh::async::generator&lt;T, U&gt;</a></code> object. It is invoked automatically by the compiler when a coroutine function returning a generator is defined and called. </p>
<p>This enables Python-like semantics for defining and using coroutine generators: </p><ul>
<li>
<code><a class="el" href="classjh_1_1async_1_1generator.html">jh::async::generator&lt;T, U&gt;</a> Func(Args...) { scope_with_co_yield(); }</code> — defines a coroutine generator. </li>
<li>
<code>Func(args...)</code> — directly obtains a generator instance, without explicitly handling <code>std::coroutine_handle</code>. </li>
<li>
<code><a class="el" href="namespacejh.html#a58aa95803840fb814bf92dd4954fb44c" title="Converts a generator factory (lambda or function) into a repeatable range.">jh::to_range</a>([...] { Func(args...); })</code> — wraps the generator-producing function into a reusable, re-entrant range. </li>
</ul>
<p>Thus, <code><a class="el" href="classjh_1_1async_1_1generator.html">jh::async::generator&lt;T, U&gt;</a></code> aligns closely with Python's <span class="tt">Generator[T, U, None]</span> semantics, making coroutine-based data pipelines natural and concise in C++. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>The coroutine handle to be managed by this generator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="ae106494a9c8e1a0fec3a9d89f1af5c57" name="ae106494a9c8e1a0fec3a9d89f1af5c57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae106494a9c8e1a0fec3a9d89f1af5c57">&#9670;&#160;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename U = typed::monostate&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structjh_1_1async_1_1generator_1_1iterator.html">iterator</a> <a class="el" href="classjh_1_1async_1_1generator.html">jh::async::generator</a>&lt; T, U &gt;::begin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator for ranged-for loops. </p>
<p>Enables use of the generator in a C++ range-based loop: <code>for (auto x : gen)</code>. This overload is available only when <code>U == <a class="el" href="structjh_1_1typed_1_1monostate.html" title="Trivial empty type representing &quot;no value&quot;.">typed::monostate</a></code>, meaning the generator does not expect any input values.</p>
<p>Each iteration step advances the coroutine and <b>consumes its internal state</b>. Unlike standard ranges, a generator cannot be treated as a view or re-iterated, because iteration directly resumes and mutates the underlying coroutine frame. </p>
<p>A <code>const</code> version of <code><a class="el" href="#ae106494a9c8e1a0fec3a9d89f1af5c57" title="Returns an iterator for ranged-for loops.">begin()</a></code> is <b>intentionally deleted</b> because invoking iteration on a constant generator would violate logical immutability: advancing the coroutine inherently modifies its promise object and execution context. </p>
<dl class="section return"><dt>Returns</dt><dd>An iterator positioned at the beginning of the generator sequence. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ad1ddf7282fa548247ee9567938ac1e5f">generator::end</a> </dd></dl>

</div>
</div>
<a id="a572fbf9f8fe9e38a8567a9659521b18d" name="a572fbf9f8fe9e38a8567a9659521b18d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a572fbf9f8fe9e38a8567a9659521b18d">&#9670;&#160;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename U = typed::monostate&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structjh_1_1async_1_1generator_1_1iterator.html">iterator</a> <a class="el" href="classjh_1_1async_1_1generator.html">jh::async::generator</a>&lt; T, U &gt;::begin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel delete">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deleted <code>const</code> overload of <code><a class="el" href="#ae106494a9c8e1a0fec3a9d89f1af5c57" title="Returns an iterator for ranged-for loops.">begin()</a></code>. </p>
<p>Generator iteration is a <b>stateful and consuming</b> operation. Allowing a <code>const</code> overload would incorrectly imply immutability, even though every iteration step mutates the coroutine's suspended frame.</p>
<p>This deletion enforces the invariant that <code><a class="el" href="classjh_1_1async_1_1generator.html">jh::async::generator&lt;T, U&gt;</a></code> may only be iterated when held as a mutable instance. </p>

</div>
</div>
<a id="a6ba6bbc31f7846d3c36e287c66e22c3d" name="a6ba6bbc31f7846d3c36e287c66e22c3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ba6bbc31f7846d3c36e287c66e22c3d">&#9670;&#160;</a></span>done()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename U = typed::monostate&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classjh_1_1async_1_1generator.html">jh::async::generator</a>&lt; T, U &gt;::done </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the generator has completed execution. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the generator has finished, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ad1ddf7282fa548247ee9567938ac1e5f" name="ad1ddf7282fa548247ee9567938ac1e5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1ddf7282fa548247ee9567938ac1e5f">&#9670;&#160;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename U = typed::monostate&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structjh_1_1async_1_1generator_1_1iterator.html">iterator</a> <a class="el" href="classjh_1_1async_1_1generator.html">jh::async::generator</a>&lt; T, U &gt;::end </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a sentinel iterator representing the end of the generator sequence. </p>
<p>This function provides the canonical <b>past-the-end sentinel</b> for use in range-based iteration. Unlike <code><a class="el" href="#ae106494a9c8e1a0fec3a9d89f1af5c57" title="Returns an iterator for ranged-for loops.">begin()</a></code>, calling <code><a class="el" href="#ad1ddf7282fa548247ee9567938ac1e5f" title="Returns a sentinel iterator representing the end of the generator sequence.">end()</a></code> never resumes or interacts with the underlying coroutine; it simply returns a default-constructed <code>iterator</code> object used to mark the termination of iteration.</p>
<p>Because it performs no coroutine access, <code><a class="el" href="#ad1ddf7282fa548247ee9567938ac1e5f" title="Returns a sentinel iterator representing the end of the generator sequence.">end()</a></code> is <b>idempotent</b> — it can be safely invoked multiple times without affecting the generator state. </p>
<p>This overload is available only when <code>U == <a class="el" href="structjh_1_1typed_1_1monostate.html" title="Trivial empty type representing &quot;no value&quot;.">typed::monostate</a></code>, meaning the generator is purely output-driven and does not require input through <code><a class="el" href="#a32723357595fa1b4288e472e0b7b1ea1" title="Sends a value to the generator and resumes execution.">send()</a></code>. </p>
<dl class="section return"><dt>Returns</dt><dd>A default-constructed iterator serving as the logical end sentinel. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ae106494a9c8e1a0fec3a9d89f1af5c57">generator::begin</a> </dd></dl>

</div>
</div>
<a id="a4cb85e765fdead38d75352a884719872" name="a4cb85e765fdead38d75352a884719872"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cb85e765fdead38d75352a884719872">&#9670;&#160;</a></span>last_sent_value()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename U = typed::monostate&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; send_type &gt; <a class="el" href="classjh_1_1async_1_1generator.html">jh::async::generator</a>&lt; T, U &gt;::last_sent_value </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the last value sent to the generator. </p>
<dl class="section return"><dt>Returns</dt><dd>An optional containing the most recent input value transmitted via <code><a class="el" href="#a32723357595fa1b4288e472e0b7b1ea1" title="Sends a value to the generator and resumes execution.">send()</a></code> or <code><a class="el" href="#a59f3bdd3bff5c7cca3aced632872a930" title="Advances the generator and sends a value in one step.">send_ite()</a></code>.</dd></dl>
<p>This accessor returns the most recent value (<code>U</code>) that was sent into the coroutine through <code><a class="el" href="#a32723357595fa1b4288e472e0b7b1ea1" title="Sends a value to the generator and resumes execution.">send()</a></code> or <code><a class="el" href="#a59f3bdd3bff5c7cca3aced632872a930" title="Advances the generator and sends a value in one step.">send_ite()</a></code>. The stored value is preserved until the next input or coroutine resumption. If no input has been sent yet, the returned <code>std::optional</code> is empty.</p>
<p>The returned value is a <b>copy</b> of the last sent element. This guarantees safety after coroutine resumption. If pointer semantics or shared ownership are required, use <b>copyable reference-counted types</b> such as <code>std::shared_ptr<u> instead of move-only handles.
</u></code></p>
<p><code><u></u></code></p>
<p><code><u></u></code></p>
<p><code><u>
When <code>U == <a class="el" href="structjh_1_1typed_1_1monostate.html" title="Trivial empty type representing &quot;no value&quot;.">typed::monostate</a></code>, the generator does not consume inputs at all. In such cases, this accessor has <b>no semantic meaning</b> and always yields an empty <code>std::optional</code>. </u></code></p>
<p><code><u>
</u></code></p>

</div>
</div>
<a id="a9ddd3617dfd063ff8250bc919569fad2" name="a9ddd3617dfd063ff8250bc919569fad2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ddd3617dfd063ff8250bc919569fad2">&#9670;&#160;</a></span>next()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename U = typed::monostate&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classjh_1_1async_1_1generator.html">jh::async::generator</a>&lt; T, U &gt;::next </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Advances the generator to the next value. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if a new value is available, <code>false</code> if the coroutine has finished. </dd></dl>

</div>
</div>
<a id="aed3219555ec237b762bc073381e7332d" name="aed3219555ec237b762bc073381e7332d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed3219555ec237b762bc073381e7332d">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename U = typed::monostate&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ae80600cfd6a9766f6d8e95bb8b5783c4">generator</a> &amp; <a class="el" href="classjh_1_1async_1_1generator.html">jh::async::generator</a>&lt; T, U &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#ae80600cfd6a9766f6d8e95bb8b5783c4">generator</a>&lt; T, U &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel delete">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deleted copy assignment operator. </p>
<p>Like the copy constructor, the copy assignment operator is deleted to ensure that the coroutine handle is not duplicated, which would lead to undefined behavior. </p>

</div>
</div>
<a id="af36e5af85d528a1a14317a2d4c75fa44" name="af36e5af85d528a1a14317a2d4c75fa44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af36e5af85d528a1a14317a2d4c75fa44">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename U = typed::monostate&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ae80600cfd6a9766f6d8e95bb8b5783c4">generator</a> &amp; <a class="el" href="classjh_1_1async_1_1generator.html">jh::async::generator</a>&lt; T, U &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ae80600cfd6a9766f6d8e95bb8b5783c4">generator</a>&lt; T, U &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment operator. </p>
<ol>
<li>
First, it stops the current coroutine if it exists. </li>
<li>
Then, it transfers ownership of the coroutine handle from <span class="tt">other</span> to <span class="tt">this</span>. </li>
<li>
The <code>other</code> generator is set to <code>nullptr</code> to prevent double destruction. </li>
<li>
This ensures safe assignment of generator instances. </li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The generator to move from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to <code>this</code> generator after assignment. </dd></dl>

</div>
</div>
<a id="a32723357595fa1b4288e472e0b7b1ea1" name="a32723357595fa1b4288e472e0b7b1ea1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32723357595fa1b4288e472e0b7b1ea1">&#9670;&#160;</a></span>send()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename U = typed::monostate&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classjh_1_1async_1_1generator.html">jh::async::generator</a>&lt; T, U &gt;::send </td>
          <td>(</td>
          <td class="paramtype">send_type</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends a value to the generator and resumes execution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="#a4683d1bb9875f9919228bfaa288645ba" title="Retrieves the currently yielded value.">value</a></td><td>The value to send. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the coroutine is still active, <code>false</code> otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>When <code>U == <a class="el" href="structjh_1_1typed_1_1monostate.html" title="Trivial empty type representing &quot;no value&quot;.">typed::monostate</a></code>, this function becomes a no-op. Since there is no <code>co_await</code> to receive input, the call does not advance the coroutine or affect its state. Use <code><a class="el" href="#a9ddd3617dfd063ff8250bc919569fad2" title="Advances the generator to the next value.">next()</a></code> or <code><a class="el" href="#a59f3bdd3bff5c7cca3aced632872a930" title="Advances the generator and sends a value in one step.">send_ite()</a></code> instead to progress the generator. </dd></dl>

</div>
</div>
<a id="a59f3bdd3bff5c7cca3aced632872a930" name="a59f3bdd3bff5c7cca3aced632872a930"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59f3bdd3bff5c7cca3aced632872a930">&#9670;&#160;</a></span>send_ite()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename U = typed::monostate&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classjh_1_1async_1_1generator.html">jh::async::generator</a>&lt; T, U &gt;::send_ite </td>
          <td>(</td>
          <td class="paramtype">send_type</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Advances the generator and sends a value in one step. </p>
<p>This function combines <code><a class="el" href="#a9ddd3617dfd063ff8250bc919569fad2" title="Advances the generator to the next value.">next()</a></code> and <code><a class="el" href="#a32723357595fa1b4288e472e0b7b1ea1" title="Sends a value to the generator and resumes execution.">send()</a></code>, eliminating the need for a separate <code><a class="el" href="#a9ddd3617dfd063ff8250bc919569fad2" title="Advances the generator to the next value.">next()</a></code> call. It first advances the generator, and if successful, sends the provided value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="#a4683d1bb9875f9919228bfaa288645ba" title="Retrieves the currently yielded value.">value</a></td><td>The value to send to the generator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the generator successfully advances and accepts the value, <code>false</code> if the generator has finished.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>When <code>U == <a class="el" href="structjh_1_1typed_1_1monostate.html" title="Trivial empty type representing &quot;no value&quot;.">typed::monostate</a></code>, this behaves identically to <code><a class="el" href="#a9ddd3617dfd063ff8250bc919569fad2" title="Advances the generator to the next value.">next()</a></code>, since no input is transmitted and the send stage is inert. </dd></dl>

</div>
</div>
<a id="a4683d1bb9875f9919228bfaa288645ba" name="a4683d1bb9875f9919228bfaa288645ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4683d1bb9875f9919228bfaa288645ba">&#9670;&#160;</a></span>value()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename U = typed::monostate&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="#a39a9dd39b8d1784e9d0981271df5a3f7">value_type</a> &gt; <a class="el" href="classjh_1_1async_1_1generator.html">jh::async::generator</a>&lt; T, U &gt;::value </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the currently yielded value. </p>
<dl class="section return"><dt>Returns</dt><dd>An optional containing the current value.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The returned value is a <b>copy</b> of the last yielded element. This ensures that each access is memory-safe and independent of coroutine resumption, avoiding dangling references. <br  />
 If your generator needs to yield pointer-like data, use a <b>copyable smart pointer</b> such as <code>std::shared_ptr&lt;T&gt;</code> or any equivalent reference-counted handle type.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd><code>std::unique_ptr&lt;T&gt;</code> and other move-only types are not supported because the generator requires <code>T</code> to be copy-constructible for <code>std::optional&lt;T&gt;</code> storage. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/jh/asynchronous/<a class="el" href="">generator.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
</div> <!-- top -->
<hr class="footer"/>
<div class="footer">
    <img class="footer-logo" src="Ojing.svg" alt="Ojing"/>
    <div class="footer-text">
        JH-Toolkit v1.4.0 · Generated by Doxygen
    </div>
    <div class="footer-note">
        We primarily support embedded documentation views in IDEs (classic CLion).
        To ensure compatibility with embedded rendering, some example code in this
        documentation intentionally contains HTML entities.
        In certain cases, Doxygen does not unescape these entities correctly.
        This is a known limitation and currently has no workaround.
    </div>
</div>
</body>
</html>
