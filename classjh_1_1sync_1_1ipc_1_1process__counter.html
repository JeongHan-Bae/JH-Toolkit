<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.16.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>JH-Toolkit: jh::sync::ipc::process_counter&lt; S, HighPriv &gt; Class Template Reference</title>
<link rel="icon" href="Jindallae.svg" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="Oree.svg"/></td>
  <td id="projectalign">
   <div id="projectname">JH-Toolkit<span id="projectnumber">&#160;v1.4.0</span>
   </div>
   <div id="projectbrief">An engineering-oriented C++20 toolkit with duck-typed concepts, static design, async coroutines, and semantic containers — header-only, RTTI-free, and concurrency-friendly.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.16.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('classjh_1_1sync_1_1ipc_1_1process__counter.html','','classjh_1_1sync_1_1ipc_1_1process__counter-members'); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">jh::sync::ipc::process_counter&lt; S, HighPriv &gt; Class Template Reference<span class="mlabels"><span class="mlabel final">final</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>Cross-process integer counter stored in shared memory (POSIX / Win32).  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="">jh/synchronous/ipc/process_counter.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a8b419eb354f89bed0df03e849ee6b327" id="r_a8b419eb354f89bed0df03e849ee6b327"><td class="memItemLeft"><a id="a8b419eb354f89bed0df03e849ee6b327" name="a8b419eb354f89bed0df03e849ee6b327"></a>
&#160;</td><td class="memItemRight"><b>process_counter</b> (const process_counter &amp;)=delete</td></tr>
<tr class="memitem:a5b8ca51792956c72091a53617dc96d54" id="r_a5b8ca51792956c72091a53617dc96d54"><td class="memItemLeft"><a id="a5b8ca51792956c72091a53617dc96d54" name="a5b8ca51792956c72091a53617dc96d54"></a>
process_counter &amp;&#160;</td><td class="memItemRight"><b>operator=</b> (const process_counter &amp;)=delete</td></tr>
<tr class="memitem:a6bf32a81086d82d8526bc07143c6ee4d" id="r_a6bf32a81086d82d8526bc07143c6ee4d"><td class="memItemLeft">std::uint64_t&#160;</td><td class="memItemRight"><a class="el" href="#a6bf32a81086d82d8526bc07143c6ee4d">load</a> () noexcept</td></tr>
<tr class="memdesc:a6bf32a81086d82d8526bc07143c6ee4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lightweight relaxed load.  <br /></td></tr>
<tr class="memitem:a17d0ad11c8e22190a147388da34a51c4" id="r_a17d0ad11c8e22190a147388da34a51c4"><td class="memItemLeft">std::uint64_t&#160;</td><td class="memItemRight"><a class="el" href="#a17d0ad11c8e22190a147388da34a51c4">load_strong</a> () noexcept</td></tr>
<tr class="memdesc:a17d0ad11c8e22190a147388da34a51c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Strong, sequentially consistent load.  <br /></td></tr>
<tr class="memitem:a0a26df64eacfeece2c49c49f6523f6fc" id="r_a0a26df64eacfeece2c49c49f6523f6fc"><td class="memItemLeft">std::uint64_t&#160;</td><td class="memItemRight"><a class="el" href="#a0a26df64eacfeece2c49c49f6523f6fc">load_force</a> () noexcept</td></tr>
<tr class="memdesc:a0a26df64eacfeece2c49c49f6523f6fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Locked and synchronized load.  <br /></td></tr>
<tr class="memitem:aa407de33594d1cf72f2432ae34f3e4db" id="r_aa407de33594d1cf72f2432ae34f3e4db"><td class="memItemLeft">void&#160;</td><td class="memItemRight"><a class="el" href="#aa407de33594d1cf72f2432ae34f3e4db">store</a> (std::uint64_t v) noexcept</td></tr>
<tr class="memdesc:aa407de33594d1cf72f2432ae34f3e4db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically replace the counter value.  <br /></td></tr>
<tr class="memitem:ac05532ac135497165c3d8340faff7b0b" id="r_ac05532ac135497165c3d8340faff7b0b"><td class="memItemLeft">std::uint64_t&#160;</td><td class="memItemRight"><a class="el" href="#ac05532ac135497165c3d8340faff7b0b">fetch_add</a> (std::uint64_t delta=1) noexcept</td></tr>
<tr class="memdesc:ac05532ac135497165c3d8340faff7b0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically add to the counter.  <br /></td></tr>
<tr class="memitem:a77a20a16f42d361ceb4982d018d3b4da" id="r_a77a20a16f42d361ceb4982d018d3b4da"><td class="memItemLeft">std::uint64_t&#160;</td><td class="memItemRight"><a class="el" href="#a77a20a16f42d361ceb4982d018d3b4da">fetch_sub</a> (std::uint64_t delta=1) noexcept</td></tr>
<tr class="memdesc:a77a20a16f42d361ceb4982d018d3b4da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically subtract from the counter.  <br /></td></tr>
<tr class="memitem:a97c84180cc329c1ad81721e6902aaff5" id="r_a97c84180cc329c1ad81721e6902aaff5"><td class="memTemplParams" colspan="2">template&lt;typename F&gt; </td></tr>
<tr class="memitem:a97c84180cc329c1ad81721e6902aaff5 template"><td class="memItemLeft">std::uint64_t&#160;</td><td class="memItemRight"><a class="el" href="#a97c84180cc329c1ad81721e6902aaff5">fetch_apply</a> (F &amp;&amp;func) noexcept(noexcept(std::invoke(std::forward&lt; F &gt;(func), std::uint64_t{})))</td></tr>
<tr class="memdesc:a97c84180cc329c1ad81721e6902aaff5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a custom transformation atomically.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-static-methods" class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a6b74ba65b17629cbdfa029fa1539dfbc" id="r_a6b74ba65b17629cbdfa029fa1539dfbc"><td class="memItemLeft"><a id="a6b74ba65b17629cbdfa029fa1539dfbc" name="a6b74ba65b17629cbdfa029fa1539dfbc"></a>
static process_counter &amp;&#160;</td><td class="memItemRight"><b>instance</b> ()</td></tr>
<tr class="memdesc:a6b74ba65b17629cbdfa029fa1539dfbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Singleton instance. <br /></td></tr>
<tr class="memitem:ab5f634881720326674867e01b16943dc" id="r_ab5f634881720326674867e01b16943dc"><td class="memItemLeft">static void&#160;</td><td class="memItemRight"><a class="el" href="#ab5f634881720326674867e01b16943dc">unlink</a> ()</td></tr>
<tr class="memdesc:ab5f634881720326674867e01b16943dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the counter's shared-memory object from the namespace (POSIX only).  <br /></td></tr>
<tr class="memitem:a64da939d010e1eea3f7bef5bff80e8f8" id="r_a64da939d010e1eea3f7bef5bff80e8f8"><td class="memItemLeft"><a id="a64da939d010e1eea3f7bef5bff80e8f8" name="a64da939d010e1eea3f7bef5bff80e8f8"></a>
static void&#160;</td><td class="memItemRight"><b>unlink</b> ()=delete</td></tr>
<tr class="memdesc:a64da939d010e1eea3f7bef5bff80e8f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disabled if HighPriv == false. Non-privileged variants cannot call <a class="el" href="#ab5f634881720326674867e01b16943dc" title="Remove the counter&#39;s shared-memory object from the namespace (POSIX only).">unlink()</a>. <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;jh::meta::TStr S, bool HighPriv = false&gt;<br />
requires (<a class="el" href="namespacejh_1_1sync_1_1ipc_1_1limits.html#ac9d6d7cefc59eb289082b37bca1603b9">limits::valid_object_name</a>&lt;S, limits::max_name_length - 4&gt;())<br />
class jh::sync::ipc::process_counter&lt; S, HighPriv &gt;</div><p>Cross-process integer counter stored in shared memory (POSIX / Win32). </p>
<p>Provides process-visible integer storage with lock-protected modification. Uses OS-named shared memory (POSIX shm or Win32 file mapping) and a dedicated <code><a class="el" href="classjh_1_1sync_1_1ipc_1_1process__mutex.html" title="Cross-platform named process-wide mutex primitive.">process_mutex</a>&lt;S + ".loc"&gt;</code> for consistency.</p>
<h4>Design goals</h4>
<ul>
<li>
Safe across processes and threads. </li>
<li>
Consistent behavior between POSIX (<code>shm_open</code>) and Windows (<code>CreateFileMapping</code>). </li>
<li>
Lock-protected read-modify-write semantics. </li>
</ul>
<h4>Read semantics</h4>
<ul>
<li>
<code><a class="el" href="#a6bf32a81086d82d8526bc07143c6ee4d" title="Lightweight relaxed load.">load()</a></code> — lightweight, relaxed read. Does <b>not</b> guarantee visibility of concurrent updates, but is sufficient when reading slightly stale values is harmless (e.g. in <code><a class="el" href="classjh_1_1sync_1_1ipc_1_1shared__process__mutex.html" title="Cross-process shared/exclusive timed mutex with optional upgrade support.">shared_process_mutex</a></code> to check reader counts). </li>
<li>
<code><a class="el" href="#a17d0ad11c8e22190a147388da34a51c4" title="Strong, sequentially consistent load.">load_strong()</a></code> — sequentially consistent read (full memory fence). Suitable for transactional reads requiring visibility of all preceding writes in any process. </li>
<li>
<code><a class="el" href="#a0a26df64eacfeece2c49c49f6523f6fc" title="Locked and synchronized load.">load_force()</a></code> — acquires the internal mutex before reading. Ensures full synchronization with all writers; used when strict atomicity or serialized state inspection is required. </li>
</ul>
<h4>Write semantics</h4>
<ul>
<li>
All modification methods (<code>store</code>, <code>fetch_add</code>, <code>fetch_sub</code>, <code>fetch_apply</code>) acquire the same mutex to ensure atomicity across processes. </li>
<li>
Operations are linearized globally within the named counter scope. </li>
</ul>
<h4>Semantic clarification</h4>
<p>The API intentionally mimics <code>std::atomic&lt;uint64_t&gt;</code>, but this class is <b>not an atomic type</b> in the C++ memory model. On non-Linux systems, there is no standard facility for <em>memory-mapped atomics</em>; therefore, atomicity across processes must be provided explicitly via a lightweight inter-process mutex. </p>
<p>From a design standpoint, <code><a class="el" href="classjh_1_1sync_1_1ipc_1_1process__counter.html" title="Cross-process integer counter stored in shared memory (POSIX / Win32).">process_counter</a></code> remains a <b>primitive</b> rather than a composite abstraction — it encapsulates synchronization internally and exposes a simple read-modify-write interface suitable for inter-process coordination. </p>
<h4>Internal synchronization objects</h4>
<ul>
<li>
<b>Main mutex</b>: <code><a class="el" href="classjh_1_1sync_1_1ipc_1_1process__mutex.html" title="Cross-platform named process-wide mutex primitive.">process_mutex</a>&lt;S + ".loc"&gt;</code> — protects all read-modify-write operations on the counter value. </li>
<li>
<b>Initialization mutex</b>: <code><a class="el" href="classjh_1_1sync_1_1ipc_1_1process__mutex.html" title="Cross-platform named process-wide mutex primitive.">process_mutex</a><s> — guards the
      one-time initialization of the shared memory region (ensures that
      <code>initialized</code> flag and <code>value</code> are safely set by the first process that creates the object). </s></code></li>
</ul>
<p><code><s></s></code></p>
<p><code><s>
Both mutexes are created in the same namespace as the counter, which means
that if a user manually defines a <code><a class="el" href="classjh_1_1sync_1_1ipc_1_1process__mutex.html" title="Cross-platform named process-wide mutex primitive.">process_mutex</a><s> or
<code><a class="el" href="classjh_1_1sync_1_1ipc_1_1process__mutex.html" title="Cross-platform named process-wide mutex primitive.">process_mutex</a>&lt;S + ".loc"&gt;</code> elsewhere, it will conflict with the internal synchronization of <code><a class="el" href="classjh_1_1sync_1_1ipc_1_1process__counter.html" title="Cross-process integer counter stored in shared memory (POSIX / Win32).">process_counter</a><s>.
Therefore, avoid declaring any <code><a class="el" href="classjh_1_1sync_1_1ipc_1_1process__mutex.html" title="Cross-platform named process-wide mutex primitive.">process_mutex</a></code> with the same template literal <code>S</code> or its <code>".loc"</code> suffix. </s></code></s></code></s></code></p>
<p><code><s><code><s><code><s></s></code></s></code></s></code></p>
<p><code><s><code><s><code><s></p><h4>Usage notes</h4>
<p></s></code></s></code></s></code></p>
<p><code><s><code><s><code><s>
</p><ul>
<li>
Acts as a globally shared 64-bit counter.
  </li>
<li>
All accesses within the same template literal <code>S</code> map to the same shared-memory region across all processes. </li>
<li>
The counter is lazily initialized once per namespace; subsequent accesses reuse the same shared mapping. </li>
</ul>
<p></s></code></s></code></s></code></p>
</div><a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="ac05532ac135497165c3d8340faff7b0b" name="ac05532ac135497165c3d8340faff7b0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac05532ac135497165c3d8340faff7b0b">&#9670;&#160;</a></span>fetch_add()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;jh::meta::TStr S, bool HighPriv = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::uint64_t <a class="el" href="classjh_1_1sync_1_1ipc_1_1process__counter.html">jh::sync::ipc::process_counter</a>&lt; S, HighPriv &gt;::fetch_add </td>
          <td>(</td>
          <td class="paramtype">std::uint64_t</td>          <td class="paramname"><span class="paramname"><em>delta</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically add to the counter. </p>
<p>Increments the counter by <code>delta</code> under lock protection.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">delta</td><td>Increment amount (default 1). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Previous counter value before addition. </dd></dl>

</div>
</div>
<a id="a97c84180cc329c1ad81721e6902aaff5" name="a97c84180cc329c1ad81721e6902aaff5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97c84180cc329c1ad81721e6902aaff5">&#9670;&#160;</a></span>fetch_apply()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;jh::meta::TStr S, bool HighPriv = false&gt; </div>
<div class="memtemplate">
template&lt;typename F&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::uint64_t <a class="el" href="classjh_1_1sync_1_1ipc_1_1process__counter.html">jh::sync::ipc::process_counter</a>&lt; S, HighPriv &gt;::fetch_apply </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>func</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply a custom transformation atomically. </p>
<p>Executes <code>func(old_value)</code> under exclusive lock, replaces the stored value with the result, and returns the previous value.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>Callable type with signature <code>uint64_t(uint64_t)</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Transformation function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The previous counter value before transformation. </dd></dl>

</div>
</div>
<a id="a77a20a16f42d361ceb4982d018d3b4da" name="a77a20a16f42d361ceb4982d018d3b4da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77a20a16f42d361ceb4982d018d3b4da">&#9670;&#160;</a></span>fetch_sub()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;jh::meta::TStr S, bool HighPriv = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::uint64_t <a class="el" href="classjh_1_1sync_1_1ipc_1_1process__counter.html">jh::sync::ipc::process_counter</a>&lt; S, HighPriv &gt;::fetch_sub </td>
          <td>(</td>
          <td class="paramtype">std::uint64_t</td>          <td class="paramname"><span class="paramname"><em>delta</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically subtract from the counter. </p>
<p>Decrements the counter by <code>delta</code> under lock protection.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">delta</td><td>Decrement amount (default 1). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Previous counter value before subtraction. </dd></dl>

</div>
</div>
<a id="a6bf32a81086d82d8526bc07143c6ee4d" name="a6bf32a81086d82d8526bc07143c6ee4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bf32a81086d82d8526bc07143c6ee4d">&#9670;&#160;</a></span>load()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;jh::meta::TStr S, bool HighPriv = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::uint64_t <a class="el" href="classjh_1_1sync_1_1ipc_1_1process__counter.html">jh::sync::ipc::process_counter</a>&lt; S, HighPriv &gt;::load </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lightweight relaxed load. </p>
<p>Performs an acquire-fenced read of the shared value. May return a slightly stale value if another process updates concurrently, but guarantees no tearing or partial reads.</p>
<h4>Usage</h4>
<ul>
<li>
Use in performance-sensitive paths where exact freshness is not required. </li>
<li>
Typical use: reader-count check or approximate monitoring. </li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>Current (possibly slightly outdated) counter value. </dd></dl>

</div>
</div>
<a id="a0a26df64eacfeece2c49c49f6523f6fc" name="a0a26df64eacfeece2c49c49f6523f6fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a26df64eacfeece2c49c49f6523f6fc">&#9670;&#160;</a></span>load_force()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;jh::meta::TStr S, bool HighPriv = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::uint64_t <a class="el" href="classjh_1_1sync_1_1ipc_1_1process__counter.html">jh::sync::ipc::process_counter</a>&lt; S, HighPriv &gt;::load_force </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Locked and synchronized load. </p>
<p>Acquires the internal process-wide mutex before reading, guaranteeing full serialization with all concurrent writers.</p>
<h4>Usage</h4>
<ul>
<li>
Use for diagnostic or critical-path reads that must reflect an exact, globally synchronized value. </li>
<li>
Typically used for invariant checks or transactional control logic. </li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>The exact counter value after synchronization with all writers. </dd></dl>

</div>
</div>
<a id="a17d0ad11c8e22190a147388da34a51c4" name="a17d0ad11c8e22190a147388da34a51c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17d0ad11c8e22190a147388da34a51c4">&#9670;&#160;</a></span>load_strong()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;jh::meta::TStr S, bool HighPriv = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::uint64_t <a class="el" href="classjh_1_1sync_1_1ipc_1_1process__counter.html">jh::sync::ipc::process_counter</a>&lt; S, HighPriv &gt;::load_strong </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Strong, sequentially consistent load. </p>
<p>Performs a full sequential-consistency fence before reading. Ensures visibility of all preceding writes across processes that use the same shared memory region.</p>
<h4>Usage</h4>
<ul>
<li>
Use when a transactionally accurate view is required. </li>
<li>
Guarantees visibility order equivalent to <code>std::atomic&lt;T&gt;::load(memory_order_seq_cst)</code>. </li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>The most recent globally visible counter value. </dd></dl>

</div>
</div>
<a id="aa407de33594d1cf72f2432ae34f3e4db" name="aa407de33594d1cf72f2432ae34f3e4db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa407de33594d1cf72f2432ae34f3e4db">&#9670;&#160;</a></span>store()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;jh::meta::TStr S, bool HighPriv = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classjh_1_1sync_1_1ipc_1_1process__counter.html">jh::sync::ipc::process_counter</a>&lt; S, HighPriv &gt;::store </td>
          <td>(</td>
          <td class="paramtype">std::uint64_t</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically replace the counter value. </p>
<p>Acquires the internal lock, writes the new value, and enforces release and sequential consistency ordering.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>New value to store. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab5f634881720326674867e01b16943dc" name="ab5f634881720326674867e01b16943dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5f634881720326674867e01b16943dc">&#9670;&#160;</a></span>unlink()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;jh::meta::TStr S, bool HighPriv = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classjh_1_1sync_1_1ipc_1_1process__counter.html">jh::sync::ipc::process_counter</a>&lt; S, HighPriv &gt;::unlink </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove the counter's shared-memory object from the namespace (POSIX only). </p>
<h4>Semantics</h4>
<ul>
<li>
On POSIX systems, calls <code>shm_unlink()</code> for the counter name, and then delegates to <code><a class="el" href="classjh_1_1sync_1_1ipc_1_1process__mutex.html#aeb148339b1070c848afc5bd37cde040e" title="Remove the semaphore name from the namespace (POSIX only).">process_mutex&lt;S&gt;::unlink()</a></code> and <code><a class="el" href="classjh_1_1sync_1_1ipc_1_1process__mutex.html" title="Cross-platform named process-wide mutex primitive.">process_mutex</a>&lt;S + ".loc"&gt;::unlink()</code>. </li>
<li>
If the object does not exist (<code>errno == ENOENT</code>), the call is silently ignored. </li>
<li>
If unlinking fails for other reasons, a <code>std::runtime_error</code> is thrown. </li>
</ul>
<h4>Idempotency</h4>
<p>The operation is idempotent: calling <code><a class="el" href="#ab5f634881720326674867e01b16943dc" title="Remove the counter&#39;s shared-memory object from the namespace (POSIX only).">unlink()</a></code> multiple times is safe. Once removed, subsequent calls are treated as no-ops. </p>
<h4>Windows</h4>
<p>On Windows / MSYS2, there is no explicit unlink concept. Shared memory and synchronization handles are destroyed automatically when the last process closes them. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/jh/synchronous/ipc/<a class="el" href="">process_counter.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
</div> <!-- top -->
<hr class="footer"/>
<div class="footer">
    <img class="footer-logo" src="Ojing.svg" alt="Ojing"/>
    <div class="footer-text">
        JH-Toolkit v1.4.0 · Generated by Doxygen
    </div>
    <div class="footer-note">
        We primarily support embedded documentation views in IDEs (classic CLion).
        To ensure compatibility with embedded rendering, some example code in this
        documentation intentionally contains HTML entities.
        In certain cases, Doxygen does not unescape these entities correctly.
        This is a known limitation and currently has no workaround.
    </div>
</div>
</body>
</html>
