<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.16.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>JH-Toolkit: jh::async::slot Class Reference</title>
<link rel="icon" href="Jindallae.svg" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="Oree.svg"/></td>
  <td id="projectalign">
   <div id="projectname">JH-Toolkit<span id="projectnumber">&#160;v1.4.0</span>
   </div>
   <div id="projectbrief">An engineering-oriented C++20 toolkit with duck-typed concepts, static design, async coroutines, and semantic containers — header-only, RTTI-free, and concurrency-friendly.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.16.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('classjh_1_1async_1_1slot.html','','classjh_1_1async_1_1slot-members'); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">jh::async::slot Class Reference<span class="mlabels"><span class="mlabel final">final</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>Coroutine representing the user-defined asynchronous state machine.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="">jh/asynchronous/slot.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:promise_5Ftype" id="r_promise_5Ftype"><td class="memItemLeft">struct &#160;</td><td class="memItemRight"><a class="el" href="structjh_1_1async_1_1slot_1_1promise__type.html">promise_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Slot coroutine promise type.  <a href="structjh_1_1async_1_1slot_1_1promise__type.html#details">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa5ea9fd6fefea41a94b4dfcfe8bb0165" id="r_aa5ea9fd6fefea41a94b4dfcfe8bb0165"><td class="memItemLeft"><a id="aa5ea9fd6fefea41a94b4dfcfe8bb0165" name="aa5ea9fd6fefea41a94b4dfcfe8bb0165"></a>
&#160;</td><td class="memItemRight"><b>slot</b> ()=default</td></tr>
<tr class="memdesc:aa5ea9fd6fefea41a94b4dfcfe8bb0165"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor for slot. <br /></td></tr>
<tr class="memitem:a0d8a0e6cdc3239960c27fa887bc1a4a3" id="r_a0d8a0e6cdc3239960c27fa887bc1a4a3"><td class="memItemLeft"><a id="a0d8a0e6cdc3239960c27fa887bc1a4a3" name="a0d8a0e6cdc3239960c27fa887bc1a4a3"></a>
&#160;</td><td class="memItemRight"><b>slot</b> (slot &amp;&amp;o) noexcept</td></tr>
<tr class="memdesc:a0d8a0e6cdc3239960c27fa887bc1a4a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor transferring coroutine handle ownership. <br /></td></tr>
<tr class="memitem:a4b9d926eba214baca76f7d3f720abd15" id="r_a4b9d926eba214baca76f7d3f720abd15"><td class="memItemLeft"><a id="a4b9d926eba214baca76f7d3f720abd15" name="a4b9d926eba214baca76f7d3f720abd15"></a>
<a class="el" href="#aa5ea9fd6fefea41a94b4dfcfe8bb0165">slot</a> &amp;&#160;</td><td class="memItemRight"><b>operator=</b> (<a class="el" href="#aa5ea9fd6fefea41a94b4dfcfe8bb0165">slot</a> &amp;&amp;o) noexcept</td></tr>
<tr class="memdesc:a4b9d926eba214baca76f7d3f720abd15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator transferring coroutine handle ownership. <br /></td></tr>
<tr class="memitem:a8c9263238d7f54aecac0396eaa716d7c" id="r_a8c9263238d7f54aecac0396eaa716d7c"><td class="memItemLeft"><a id="a8c9263238d7f54aecac0396eaa716d7c" name="a8c9263238d7f54aecac0396eaa716d7c"></a>
&#160;</td><td class="memItemRight"><b>slot</b> (const slot &amp;)=delete</td></tr>
<tr class="memdesc:a8c9263238d7f54aecac0396eaa716d7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor is deleted to prevent duplication of coroutine handle. <br /></td></tr>
<tr class="memitem:a3d789b655052f1247761615ce395f5c5" id="r_a3d789b655052f1247761615ce395f5c5"><td class="memItemLeft"><a id="a3d789b655052f1247761615ce395f5c5" name="a3d789b655052f1247761615ce395f5c5"></a>
<a class="el" href="#aa5ea9fd6fefea41a94b4dfcfe8bb0165">slot</a> &amp;&#160;</td><td class="memItemRight"><b>operator=</b> (const <a class="el" href="#aa5ea9fd6fefea41a94b4dfcfe8bb0165">slot</a> &amp;)=delete</td></tr>
<tr class="memdesc:a3d789b655052f1247761615ce395f5c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment is deleted to prevent unsafe copying of coroutine handle. <br /></td></tr>
<tr class="memitem:a573f3725cbe0f3ea772b3baf16e92d14" id="r_a573f3725cbe0f3ea772b3baf16e92d14"><td class="memItemLeft">void&#160;</td><td class="memItemRight"><a class="el" href="#a573f3725cbe0f3ea772b3baf16e92d14">spawn</a> ()</td></tr>
<tr class="memdesc:a573f3725cbe0f3ea772b3baf16e92d14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start the coroutine associated with this slot.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-friends" class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:ac2e74bfcc1b211d75b2132f1d61c3dc0" id="r_ac2e74bfcc1b211d75b2132f1d61c3dc0"><td class="memTemplParams" colspan="2"><a id="ac2e74bfcc1b211d75b2132f1d61c3dc0" name="ac2e74bfcc1b211d75b2132f1d61c3dc0"></a>
template&lt;typename T&gt; </td></tr>
<tr class="memitem:ac2e74bfcc1b211d75b2132f1d61c3dc0 template"><td class="memItemLeft">class&#160;</td><td class="memItemRight"><b>listener</b></td></tr>
<tr class="memdesc:ac2e74bfcc1b211d75b2132f1d61c3dc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Grants listener&lt;T&gt; access to internal slot members. <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Coroutine representing the user-defined asynchronous state machine. </p>
<p>A <code>slot</code> is the <b>only</b> execution context of the entire "slot-listener-signal" system. It defines the state machine, phase switching, routing, filtering, and fan-out logic. A <code>slot</code> always runs on the thread where <code><a class="el" href="#a573f3725cbe0f3ea772b3baf16e92d14" title="Start the coroutine associated with this slot.">spawn()</a></code> is invoked. </p>
<h4>Strong Synchronization Semantics</h4>
<p>A <code>slot</code> may suspend on <em>exactly one</em> listener at any time. Each <code>co_await</code> represents one logical synchronous step. </p>
<p><b>Awaiting multiple listeners inside the same loop is technically idempotent per iteration but semantically meaningless</b>, because this requires the external event sources to be <em>strictly time-aligned</em>. If external producers drift in timing (which is unavoidable in real-time systems), the synchronous semantics break immediately. </p>
<p>In other words, the following pattern is strongly discouraged: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> a = <span class="keyword">co_await</span> A;</div>
<div class="line"><span class="keyword">auto</span> b = <span class="keyword">co_await</span> B;</div>
</div><!-- fragment --><p> This is irrelevant to our implementation. Semantically, asynchronous operations always perform triggering and consuming. </p>
<p>In other words, the discouraged behavior implies a sync-barrier semantic. This means that if any listener is advancing too rapidly and resumes two or more times before the other listener resumes even once in the same iteration, the state machine is broken. </p>
<p>According to the C++20 coroutine model, if you want to guarantee the correctness of this behavior, then you need external synchronization; that maps to sync-barrier rather than async-resuming. </p>
<p>However, If a user truly has perfectly time-aligned external timing, then the recommended design is: </p><ul>
<li>
<b>Use one <code><a class="el" href="classjh_1_1async_1_1event__signal.html" title="Lightweight push-only event emitter.">event_signal</a></code> to emit a <code>tuple</code></b> containing all values needed for that round. </li>
<li>
Do <b>not</b> await multiple listeners in the same phase. </li>
</ul>
<p>In summary, this behavior is semantically determined and implementation-independent. If you need to observe multiple input sources in the same logical step, then it's fan-in, see <code>listener</code>.</p>
<h4>Correct Usage of Multiple Listeners</h4>
<p>Multiple <code>listener</code>s exist <b>for different phases or different conditions</b>, not for parallel waiting. A <code>slot</code> typically performs: </p>
<div class="fragment"><div class="line"><span class="comment">// Phase 1</span></div>
<div class="line"><span class="keywordflow">for</span> (;;) {</div>
<div class="line">    <span class="keyword">auto</span> v = <span class="keyword">co_await</span> listener_A;</div>
<div class="line">    <span class="keywordflow">if</span> (v == STOP) <span class="keywordflow">break</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Phase 2</span></div>
<div class="line"><span class="keywordflow">for</span> (;;) {</div>
<div class="line">    <span class="keyword">auto</span> s = <span class="keyword">co_await</span> listener_B;</div>
<div class="line">}</div>
</div><!-- fragment --><h4>Lifetime</h4>
<ul>
<li>
Must not be moved after binding to a hub. </li>
<li>
<code>slot</code>, <code><a class="el" href="classjh_1_1async_1_1slot__hub.html" title="Synchronization domain managing timed mutex acquisition and binding exactly one slot.">slot_hub</a></code>, and <code>listener</code>s must share unified lifetime. </li>
</ul>
<dl class="section note"><dt>Note</dt><dd><code>co_yield {}</code> returns an empty sentinel value (<code><a class="el" href="structjh_1_1typed_1_1monostate.html" title="Trivial empty type representing &quot;no value&quot;.">jh::typed::monostate</a></code>). This is not necessarily needed, but ensures consistency on non-main threads. It can also be used as a jump point (similar to <code>return</code> in a regular function). <br  />
 Otherwise, the actual execution body is equivalent to the interval between the input <code>co_await listener</code> and the next declared <code>co_await another_listener</code>. </dd></dl>
</div><a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="a573f3725cbe0f3ea772b3baf16e92d14" name="a573f3725cbe0f3ea772b3baf16e92d14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a573f3725cbe0f3ea772b3baf16e92d14">&#9670;&#160;</a></span>spawn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void jh::async::slot::spawn </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Start the coroutine associated with this slot. </p>
<p>Transitions the coroutine from the initial suspended state to active execution. It binds the coroutine to the current thread permanently. This function is only effective once. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/jh/asynchronous/<a class="el" href="">slot.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
</div> <!-- top -->
<hr class="footer"/>
<div class="footer">
    <img class="footer-logo" src="Ojing.svg" alt="Ojing"/>
    <div class="footer-text">
        JH-Toolkit v1.4.0 · Generated by Doxygen
    </div>
    <div class="footer-note">
        We primarily support embedded documentation views in IDEs (classic CLion).
        To ensure compatibility with embedded rendering, some example code in this
        documentation intentionally contains HTML entities.
        In certain cases, Doxygen does not unescape these entities correctly.
        This is a known limitation and currently has no workaround.
    </div>
</div>
</body>
</html>
