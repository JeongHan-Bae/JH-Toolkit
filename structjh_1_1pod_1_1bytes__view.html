<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.16.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>JH-Toolkit: jh::pod::bytes_view Struct Reference</title>
<link rel="icon" href="Jindallae.svg" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="Oree.svg"/></td>
  <td id="projectalign">
   <div id="projectname">JH-Toolkit<span id="projectnumber">&#160;v1.4.0</span>
   </div>
   <div id="projectbrief">An engineering-oriented C++20 toolkit with duck-typed concepts, static design, async coroutines, and semantic containers — header-only, RTTI-free, and concurrency-friendly.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.16.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('structjh_1_1pod_1_1bytes__view.html','','structjh_1_1pod_1_1bytes__view-members'); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">jh::pod::bytes_view Struct Reference<span class="mlabels"><span class="mlabel final">final</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>A read-only view over a block of raw bytes.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="">jh/pods/bytes_view.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-types" class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a04273e3efc2c240a39fbe18ef1607927" id="r_a04273e3efc2c240a39fbe18ef1607927"><td class="memItemLeft"><a id="a04273e3efc2c240a39fbe18ef1607927" name="a04273e3efc2c240a39fbe18ef1607927"></a>
using&#160;</td><td class="memItemRight"><b>value_type</b> = std::byte</td></tr>
<tr class="memdesc:a04273e3efc2c240a39fbe18ef1607927"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value type alias. <br /></td></tr>
<tr class="memitem:a622f516091c4c1d405df6fe52cea3fac" id="r_a622f516091c4c1d405df6fe52cea3fac"><td class="memItemLeft"><a id="a622f516091c4c1d405df6fe52cea3fac" name="a622f516091c4c1d405df6fe52cea3fac"></a>
using&#160;</td><td class="memItemRight"><b>size_type</b> = std::uint64_t</td></tr>
<tr class="memdesc:a622f516091c4c1d405df6fe52cea3fac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size type alias (64-bit). <br /></td></tr>
<tr class="memitem:a8296733b2055c653e755a467546181b1" id="r_a8296733b2055c653e755a467546181b1"><td class="memItemLeft"><a id="a8296733b2055c653e755a467546181b1" name="a8296733b2055c653e755a467546181b1"></a>
using&#160;</td><td class="memItemRight"><b>difference_type</b> = std::ptrdiff_t</td></tr>
<tr class="memdesc:a8296733b2055c653e755a467546181b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Difference type alias. <br /></td></tr>
<tr class="memitem:aa36bfb789d6c8035c5bab48fe764793c" id="r_aa36bfb789d6c8035c5bab48fe764793c"><td class="memItemLeft"><a id="aa36bfb789d6c8035c5bab48fe764793c" name="aa36bfb789d6c8035c5bab48fe764793c"></a>
using&#160;</td><td class="memItemRight"><b>reference</b> = <a class="el" href="#a04273e3efc2c240a39fbe18ef1607927">value_type</a> &amp;</td></tr>
<tr class="memdesc:aa36bfb789d6c8035c5bab48fe764793c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference type. <br /></td></tr>
<tr class="memitem:aba33447c590912a594815fdfa096c7a9" id="r_aba33447c590912a594815fdfa096c7a9"><td class="memItemLeft"><a id="aba33447c590912a594815fdfa096c7a9" name="aba33447c590912a594815fdfa096c7a9"></a>
using&#160;</td><td class="memItemRight"><b>const_reference</b> = const <a class="el" href="#a04273e3efc2c240a39fbe18ef1607927">value_type</a> &amp;</td></tr>
<tr class="memdesc:aba33447c590912a594815fdfa096c7a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const reference type. <br /></td></tr>
<tr class="memitem:a84d79a37ff5f7f22c6d108c31da09ebd" id="r_a84d79a37ff5f7f22c6d108c31da09ebd"><td class="memItemLeft"><a id="a84d79a37ff5f7f22c6d108c31da09ebd" name="a84d79a37ff5f7f22c6d108c31da09ebd"></a>
using&#160;</td><td class="memItemRight"><b>pointer</b> = <a class="el" href="#a04273e3efc2c240a39fbe18ef1607927">value_type</a> *</td></tr>
<tr class="memdesc:a84d79a37ff5f7f22c6d108c31da09ebd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer type. <br /></td></tr>
<tr class="memitem:a58d15eba06ec209e9c27a7318b5b5f9e" id="r_a58d15eba06ec209e9c27a7318b5b5f9e"><td class="memItemLeft"><a id="a58d15eba06ec209e9c27a7318b5b5f9e" name="a58d15eba06ec209e9c27a7318b5b5f9e"></a>
using&#160;</td><td class="memItemRight"><b>const_pointer</b> = const <a class="el" href="#a04273e3efc2c240a39fbe18ef1607927">value_type</a> *</td></tr>
<tr class="memdesc:a58d15eba06ec209e9c27a7318b5b5f9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const pointer type. <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac6f8210dc8f01ade114e7832d3c79795" id="r_ac6f8210dc8f01ade114e7832d3c79795"><td class="memItemLeft">constexpr <a class="el" href="#a622f516091c4c1d405df6fe52cea3fac">size_type</a>&#160;</td><td class="memItemRight"><a class="el" href="#ac6f8210dc8f01ade114e7832d3c79795">size</a> () const noexcept</td></tr>
<tr class="memdesc:ac6f8210dc8f01ade114e7832d3c79795"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of bytes in the view.  <br /></td></tr>
<tr class="memitem:af1233364f6831b80860d5d7d24f4ac23" id="r_af1233364f6831b80860d5d7d24f4ac23"><td class="memTemplParams" colspan="2">template&lt;trivial_bytes T&gt; </td></tr>
<tr class="memitem:af1233364f6831b80860d5d7d24f4ac23 template"><td class="memItemLeft">constexpr const T &amp;&#160;</td><td class="memItemRight"><a class="el" href="#af1233364f6831b80860d5d7d24f4ac23">at</a> (const std::uint64_t offset=0) const noexcept</td></tr>
<tr class="memdesc:af1233364f6831b80860d5d7d24f4ac23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reinterpret a subregion of the view as a reference to <code>T</code>.  <br /></td></tr>
<tr class="memitem:a08c4732e1383abb479d7415981257466" id="r_a08c4732e1383abb479d7415981257466"><td class="memTemplParams" colspan="2">template&lt;trivial_bytes T&gt; </td></tr>
<tr class="memitem:a08c4732e1383abb479d7415981257466 template"><td class="memItemLeft">constexpr const T *&#160;</td><td class="memItemRight"><a class="el" href="#a08c4732e1383abb479d7415981257466">fetch</a> (const std::uint64_t offset=0) const noexcept</td></tr>
<tr class="memdesc:a08c4732e1383abb479d7415981257466"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safely fetch a pointer to a <code>T</code> from the view.  <br /></td></tr>
<tr class="memitem:ae2f2bf289653c7d50aec85a7e12bd55e" id="r_ae2f2bf289653c7d50aec85a7e12bd55e"><td class="memTemplParams" colspan="2">template&lt;cv_free_pod_like T&gt; </td></tr>
<tr class="memitem:ae2f2bf289653c7d50aec85a7e12bd55e template"><td class="memItemLeft">constexpr T&#160;</td><td class="memItemRight"><a class="el" href="#ae2f2bf289653c7d50aec85a7e12bd55e">clone</a> () const noexcept</td></tr>
<tr class="memdesc:ae2f2bf289653c7d50aec85a7e12bd55e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clone the entire view contents into a value of type <code>T</code> on the stack.  <br /></td></tr>
<tr class="memitem:acfcdb6f4e5ab057f76a6ef9e90adaa88" id="r_acfcdb6f4e5ab057f76a6ef9e90adaa88"><td class="memItemLeft">constexpr std::uint64_t&#160;</td><td class="memItemRight"><a class="el" href="#acfcdb6f4e5ab057f76a6ef9e90adaa88">hash</a> (<a class="el" href="namespacejh_1_1meta.html#a7ea475ab0421edb9edb93189740da707">jh::meta::c_hash</a> hash_method=<a class="el" href="namespacejh_1_1meta.html#a7ea475ab0421edb9edb93189740da707aca0466d3124e039f7442eccafc2fd891">jh::meta::c_hash::fnv1a64</a>) const noexcept</td></tr>
<tr class="memdesc:acfcdb6f4e5ab057f76a6ef9e90adaa88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a deterministic 64-bit hash of the view contents.  <br /></td></tr>
<tr class="memitem:ada79125b6b639d5adfb077a44ecca76b" id="r_ada79125b6b639d5adfb077a44ecca76b"><td class="memItemLeft">constexpr bool&#160;</td><td class="memItemRight"><a class="el" href="#ada79125b6b639d5adfb077a44ecca76b">operator==</a> (const <a class="el" href="structjh_1_1pod_1_1bytes__view.html">bytes_view</a> &amp;rhs) const noexcept</td></tr>
<tr class="memdesc:ada79125b6b639d5adfb077a44ecca76b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two views for byte-wise equality.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-static-methods" class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a1a6cd61a75bfe8969d4bea9da6443a6d" id="r_a1a6cd61a75bfe8969d4bea9da6443a6d"><td class="memTemplParams" colspan="2">template&lt;trivial_bytes T&gt; </td></tr>
<tr class="memitem:a1a6cd61a75bfe8969d4bea9da6443a6d template"><td class="memItemLeft">static constexpr <a class="el" href="structjh_1_1pod_1_1bytes__view.html">bytes_view</a>&#160;</td><td class="memItemRight"><a class="el" href="#a1a6cd61a75bfe8969d4bea9da6443a6d">from</a> (const T &amp;obj) noexcept</td></tr>
<tr class="memdesc:a1a6cd61a75bfe8969d4bea9da6443a6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <code><a class="el" href="structjh_1_1pod_1_1bytes__view.html" title="A read-only view over a block of raw bytes.">bytes_view</a></code> from a trivially laid-out object.  <br /></td></tr>
<tr class="memitem:a3ff927c65b8682a232b4bed6f298bd66" id="r_a3ff927c65b8682a232b4bed6f298bd66"><td class="memTemplParams" colspan="2">template&lt;trivial_bytes T&gt; </td></tr>
<tr class="memitem:a3ff927c65b8682a232b4bed6f298bd66 template"><td class="memItemLeft">static constexpr <a class="el" href="structjh_1_1pod_1_1bytes__view.html">bytes_view</a>&#160;</td><td class="memItemRight"><a class="el" href="#a3ff927c65b8682a232b4bed6f298bd66">from</a> (const T *arr, const std::uint64_t <a class="el" href="#ac6f8210dc8f01ade114e7832d3c79795">size</a>) noexcept</td></tr>
<tr class="memdesc:a3ff927c65b8682a232b4bed6f298bd66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <code><a class="el" href="structjh_1_1pod_1_1bytes__view.html" title="A read-only view over a block of raw bytes.">bytes_view</a></code> from a contiguous array of objects.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-attribs" class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ac3931fa9db85ecd588ad8e6ca88ac9cb" id="r_ac3931fa9db85ecd588ad8e6ca88ac9cb"><td class="memItemLeft"><a id="ac3931fa9db85ecd588ad8e6ca88ac9cb" name="ac3931fa9db85ecd588ad8e6ca88ac9cb"></a>
const std::byte *&#160;</td><td class="memItemRight"><b>data</b></td></tr>
<tr class="memdesc:ac3931fa9db85ecd588ad8e6ca88ac9cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to the start of the byte range. <br /></td></tr>
<tr class="memitem:a0cd714ed695d3de338d0a7f57f88fdd3" id="r_a0cd714ed695d3de338d0a7f57f88fdd3"><td class="memItemLeft"><a id="a0cd714ed695d3de338d0a7f57f88fdd3" name="a0cd714ed695d3de338d0a7f57f88fdd3"></a>
std::uint64_t&#160;</td><td class="memItemRight"><b>len</b></td></tr>
<tr class="memdesc:a0cd714ed695d3de338d0a7f57f88fdd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of bytes in the view. <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A read-only view over a block of raw bytes. </p>
<p>This struct holds a pointer + length representing a memory region. It supports reinterpretation as POD types, safe view extraction, and object-level clone utilities.</p>
<h4>Clone Safety Model</h4>
<p>The <code><a class="el" href="#ae2f2bf289653c7d50aec85a7e12bd55e" title="Clone the entire view contents into a value of type T on the stack.">clone&lt;T&gt;()</a></code> method is only available for <code><a class="el" href="conceptjh_1_1pod_1_1pod__like.html" title="Concept for types that are safe to treat as plain old data (POD).">pod_like</a></code> types. This ensures: </p><ul>
<li>
Bitwise copies are semantically valid (no heap ownership, no reference count) </li>
<li>
Cloned objects do not require custom destructors or resource management </li>
<li>
Structures reconstructed from raw bytes behave identically to their originals </li>
</ul>
<h4>Formal constraints</h4>
<p>In essence, this maps to: </p><ul>
<li>
<code>std::is_standard_layout_v&lt;T&gt;</code> </li>
<li>
<code>std::is_trivially_constructible_v&lt;T&gt;</code> </li>
<li>
<code>std::is_trivially_copyable_v&lt;T&gt;</code> </li>
<li>
<code>std::is_trivially_destructible_v&lt;T&gt;</code> </li>
</ul>
<p>Which is exactly what <code><a class="el" href="conceptjh_1_1pod_1_1pod__like.html" title="Concept for types that are safe to treat as plain old data (POD).">jh::pod::pod_like&lt;T&gt;</a></code> ensures.</p>
<dl class="section note"><dt>Note</dt><dd>The functions <code>from</code>, <code>at</code>, <code>fetch</code>, and <code>clone</code> are declared <code>constexpr</code> primarily to enable aggressive compiler optimizations. However, because they internally use <code>reinterpret_cast</code>, they cannot be evaluated in <code>consteval</code> contexts. If you need to copy POD objects or construct one POD from another at compile time, write the copy or constructor manually instead of relying on these helpers. </dd></dl>
</div><a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="af1233364f6831b80860d5d7d24f4ac23" name="af1233364f6831b80860d5d7d24f4ac23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1233364f6831b80860d5d7d24f4ac23">&#9670;&#160;</a></span>at()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;trivial_bytes T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T &amp; jh::pod::bytes_view::at </td>
          <td>(</td>
          <td class="paramtype">const std::uint64_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reinterpret a subregion of the view as a reference to <code>T</code>. </p>
<p>This function provides POD-safe reinterpretation of the underlying bytes. The type <code>T</code> must satisfy <code><a class="el" href="conceptjh_1_1pod_1_1trivial__bytes.html" title="Concept for trivially layout-compatible types (POD-compatible memory view).">trivial_bytes</a></code>, ensuring the result is well-defined for POD-like memory.</p>
<p>Internally it uses <code>std::launder</code> to avoid undefined behavior when reinterpreting object representations. The operation is marked <code>noexcept</code> and is guaranteed not to throw.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Must satisfy <code><a class="el" href="conceptjh_1_1pod_1_1trivial__bytes.html" title="Concept for trivially layout-compatible types (POD-compatible memory view).">trivial_bytes</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>Offset in bytes into the view (default 0). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the reinterpreted value at the specified offset.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The caller must ensure <code>offset + sizeof(T) &lt;= <a class="el" href="#ac6f8210dc8f01ade114e7832d3c79795" title="Returns the number of bytes in the view.">size()</a></code>. No bounds checking is performed; out-of-bounds access remains the caller's responsibility. </dd></dl>

</div>
</div>
<a id="ae2f2bf289653c7d50aec85a7e12bd55e" name="ae2f2bf289653c7d50aec85a7e12bd55e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2f2bf289653c7d50aec85a7e12bd55e">&#9670;&#160;</a></span>clone()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;cv_free_pod_like T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T jh::pod::bytes_view::clone </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clone the entire view contents into a value of type <code>T</code> on the stack. </p>
<p>This is the safest way to materialize a <code><a class="el" href="conceptjh_1_1pod_1_1pod__like.html" title="Concept for types that are safe to treat as plain old data (POD).">pod_like</a></code> object from a <code><a class="el" href="structjh_1_1pod_1_1bytes__view.html" title="A read-only view over a block of raw bytes.">bytes_view</a></code>. It requires that: </p><ul>
<li>
<code>len == sizeof(T)</code> — the view must exactly match the size of <code>T</code>. </li>
<li>
<code>T</code> must satisfy <code><a class="el" href="conceptjh_1_1pod_1_1pod__like.html" title="Concept for types that are safe to treat as plain old data (POD).">pod_like</a></code> (standard layout, trivially constructible, trivially copyable, trivially destructible). </li>
</ul>
<p>If the size check fails, a default-initialized <code>T{}</code> (zero-initialized POD object) is returned. Otherwise, this function copies the raw bytes into a local object and returns it by value, effectively performing a POD copy.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Must satisfy <code><a class="el" href="conceptjh_1_1pod_1_1cv__free__pod__like.html" title="Concept for POD-like types that are free of const or volatile qualification.">cv_free_pod_like</a></code>. Using <code>const</code> or <code>volatile</code> qualified types is disallowed, as this function constructs a writable value of type <code>T</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value reconstructed from the view if sizes match, or a default-initialized <code>T{}</code> if size mismatch. </dd></dl>

</div>
</div>
<a id="a08c4732e1383abb479d7415981257466" name="a08c4732e1383abb479d7415981257466"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08c4732e1383abb479d7415981257466">&#9670;&#160;</a></span>fetch()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;trivial_bytes T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T * jh::pod::bytes_view::fetch </td>
          <td>(</td>
          <td class="paramtype">const std::uint64_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Safely fetch a pointer to a <code>T</code> from the view. </p>
<p>This is the bounds-checked counterpart to <code>at</code>. It reinterprets a subregion of the view as <code>T</code> if the memory range <code>[offset, offset + sizeof(T))</code> is fully contained within the view. If the range would exceed <code><a class="el" href="#ac6f8210dc8f01ade114e7832d3c79795" title="Returns the number of bytes in the view.">size()</a></code>, it returns <code>nullptr</code> instead of producing undefined behavior.</p>
<p>The type <code>T</code> must satisfy <code><a class="el" href="conceptjh_1_1pod_1_1trivial__bytes.html" title="Concept for trivially layout-compatible types (POD-compatible memory view).">trivial_bytes</a></code>, ensuring POD-safe reinterpretation semantics. Internally it uses <code>std::launder</code> to avoid undefined behavior when accessing object representations. The operation is marked <code>noexcept</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Must satisfy <code><a class="el" href="conceptjh_1_1pod_1_1trivial__bytes.html" title="Concept for trivially layout-compatible types (POD-compatible memory view).">trivial_bytes</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>Offset in bytes into the view (default 0). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the reinterpreted value, or <code>nullptr</code> if out of bounds. </dd></dl>

</div>
</div>
<a id="a1a6cd61a75bfe8969d4bea9da6443a6d" name="a1a6cd61a75bfe8969d4bea9da6443a6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a6cd61a75bfe8969d4bea9da6443a6d">&#9670;&#160;</a></span>from() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;trivial_bytes T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structjh_1_1pod_1_1bytes__view.html">bytes_view</a> jh::pod::bytes_view::from </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>obj</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a <code><a class="el" href="structjh_1_1pod_1_1bytes__view.html" title="A read-only view over a block of raw bytes.">bytes_view</a></code> from a trivially laid-out object. </p>
<p>This function provides a safer alternative to manual <code>reinterpret_cast</code> when creating a view over raw memory. It guarantees that only objects satisfying <code><a class="el" href="conceptjh_1_1pod_1_1trivial__bytes.html" title="Concept for trivially layout-compatible types (POD-compatible memory view).">trivial_bytes</a></code> (standard layout, trivially constructible) are accepted, preventing misuse with non-POD types.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Must satisfy <code><a class="el" href="conceptjh_1_1pod_1_1trivial__bytes.html" title="Concept for trivially layout-compatible types (POD-compatible memory view).">trivial_bytes</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Source object (not copied). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="structjh_1_1pod_1_1bytes__view.html" title="A read-only view over a block of raw bytes.">bytes_view</a></code> representing the raw bytes of <code>obj</code>. </dd></dl>

</div>
</div>
<a id="a3ff927c65b8682a232b4bed6f298bd66" name="a3ff927c65b8682a232b4bed6f298bd66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ff927c65b8682a232b4bed6f298bd66">&#9670;&#160;</a></span>from() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;trivial_bytes T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structjh_1_1pod_1_1bytes__view.html">bytes_view</a> jh::pod::bytes_view::from </td>
          <td>(</td>
          <td class="paramtype">const T *</td>          <td class="paramname"><span class="paramname"><em>arr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::uint64_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a <code><a class="el" href="structjh_1_1pod_1_1bytes__view.html" title="A read-only view over a block of raw bytes.">bytes_view</a></code> from a contiguous array of objects. </p>
<p>Like the single-object overload, this provides a safer alternative to manual <code>reinterpret_cast</code> by requiring <code><a class="el" href="conceptjh_1_1pod_1_1trivial__bytes.html" title="Concept for trivially layout-compatible types (POD-compatible memory view).">trivial_bytes</a></code> elements. It enables treating a typed array or buffer (e.g., from a C-style array, span, or mmap'd structure) as a flat byte view.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Must satisfy <code><a class="el" href="conceptjh_1_1pod_1_1trivial__bytes.html" title="Concept for trivially layout-compatible types (POD-compatible memory view).">trivial_bytes</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>Pointer to the first element (may be <code>nullptr</code> if <code>size == 0</code>). </td></tr>
    <tr><td class="paramname"><a class="el" href="#ac6f8210dc8f01ade114e7832d3c79795" title="Returns the number of bytes in the view.">size</a></td><td>Number of elements (of type <code>T</code>, not bytes). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="structjh_1_1pod_1_1bytes__view.html" title="A read-only view over a block of raw bytes.">bytes_view</a></code> covering <code>sizeof(T) * size</code> bytes starting at <code>arr</code>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The caller must ensure that <code>arr</code> points to a valid contiguous block of at least <code>size</code> elements. </dd></dl>

</div>
</div>
<a id="acfcdb6f4e5ab057f76a6ef9e90adaa88" name="acfcdb6f4e5ab057f76a6ef9e90adaa88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfcdb6f4e5ab057f76a6ef9e90adaa88">&#9670;&#160;</a></span>hash()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::uint64_t jh::pod::bytes_view::hash </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacejh_1_1meta.html#a7ea475ab0421edb9edb93189740da707">jh::meta::c_hash</a></td>          <td class="paramname"><span class="paramname"><em>hash_method</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespacejh_1_1meta.html#a7ea475ab0421edb9edb93189740da707aca0466d3124e039f7442eccafc2fd891">jh::meta::c_hash::fnv1a64</a></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute a deterministic 64-bit hash of the view contents. </p>
<p>This function computes a stable, non-cryptographic hash value from the raw bytes in the view. The result depends only on the byte sequence and its length, not on any type-level semantics. It is suitable for version checking, cache keys, or equality grouping.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hash_method</td><td>Hash algorithm to use (default: <code>fnv1a64</code>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>64-bit hash of the byte content, or <code>0xFFFFFFFFFFFFFFFF</code> if <code>data == nullptr</code>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This hash is not cryptographically secure and must not be used for security-sensitive purposes. </dd>
<dd>
If <code>data == nullptr</code>, the return value is <code>0xFFFFFFFFFFFFFFFF</code> (sentinel). </dd>
<dd>
Although declared <code>constexpr</code>, this function cannot be used in <code>consteval</code> contexts due to its reliance on pointer reinterpretation. It is intended for runtime use. </dd></dl>

</div>
</div>
<a id="ada79125b6b639d5adfb077a44ecca76b" name="ada79125b6b639d5adfb077a44ecca76b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada79125b6b639d5adfb077a44ecca76b">&#9670;&#160;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool jh::pod::bytes_view::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structjh_1_1pod_1_1bytes__view.html">bytes_view</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare two views for byte-wise equality. </p>
<p>As a view type, equality is defined strictly in terms of the underlying byte sequence (deep comparison), not pointer identity or struct field comparison.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The other <code><a class="el" href="structjh_1_1pod_1_1bytes__view.html" title="A read-only view over a block of raw bytes.">bytes_view</a></code> to compare with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if both views have the same length and identical byte contents, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ac6f8210dc8f01ade114e7832d3c79795" name="ac6f8210dc8f01ade114e7832d3c79795"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6f8210dc8f01ade114e7832d3c79795">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a622f516091c4c1d405df6fe52cea3fac">size_type</a> jh::pod::bytes_view::size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of bytes in the view. </p>
<p>This is equivalent to the <code>len</code> field and reflects the total size (in bytes) of the memory region being viewed. The return type is 64-bit (<code>std::uint64_t</code>), allowing safe representation of large memory regions.</p>
<dl class="section return"><dt>Returns</dt><dd>The length of the view in bytes. </dd></dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>include/jh/pods/<a class="el" href="">bytes_view.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
</div> <!-- top -->
<hr class="footer"/>
<div class="footer">
    <img class="footer-logo" src="Ojing.svg" alt="Ojing"/>
    <div class="footer-text">
        JH-Toolkit v1.4.0 · Generated by Doxygen
    </div>
    <div class="footer-note">
        We primarily support embedded documentation views in IDEs (classic CLion).
        To ensure compatibility with embedded rendering, some example code in this
        documentation intentionally contains HTML entities.
        In certain cases, Doxygen does not unescape these entities correctly.
        This is a known limitation and currently has no workaround.
    </div>
</div>
</body>
</html>
