<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.16.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>JH-Toolkit: include/jh/core/ordered_map.h File Reference</title>
<link rel="icon" href="Jindallae.svg" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="Oree.svg"/></td>
  <td id="projectalign">
   <div id="projectname">JH-Toolkit<span id="projectnumber">&#160;v1.4.0</span>
   </div>
   <div id="projectbrief">An engineering-oriented C++20 toolkit with duck-typed concepts, static design, async coroutines, and semantic containers — header-only, RTTI-free, and concurrency-friendly.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.16.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('ordered__map_8h.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">ordered_map.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Contiguous AVL-based ordered container with fragmentation-free semantics.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;<a class="el" href="">concepts</a>&gt;</code><br />
<code>#include &lt;cstddef&gt;</code><br />
<code>#include &lt;utility&gt;</code><br />
<code>#include &lt;cstdint&gt;</code><br />
<code>#include &lt;iostream&gt;</code><br />
<code>#include &lt;type_traits&gt;</code><br />
<code>#include &lt;iterator&gt;</code><br />
<code>#include &lt;stdexcept&gt;</code><br />
<code>#include &lt;ranges&gt;</code><br />
<code>#include &lt;vector&gt;</code><br />
<code>#include &quot;<a class="el" href="">jh/typing/monostate.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="">jh/conceptual/tuple_like.h</a>&quot;</code><br />
</div>
<p><a href="">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:jh_3A_3Aavl_3A_3Aavl_5Fnode_3C_20K_2C_20V_20_3E" id="r_jh_3A_3Aavl_3A_3Aavl_5Fnode_3C_20K_2C_20V_20_3E"><td class="memItemLeft">struct &#160;</td><td class="memItemRight"><a class="el" href="structjh_1_1avl_1_1avl__node.html">jh::avl::avl_node&lt; K, V &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Node element for the contiguous AVL tree.  <a href="structjh_1_1avl_1_1avl__node.html#details">More...</a><br /></td></tr>
<tr class="memitem:jh_3A_3Aavl_3A_3Aavl_5Fnode_3C_20K_2C_20jh_3A_3Atyped_3A_3Amonostate_20_3E" id="r_jh_3A_3Aavl_3A_3Aavl_5Fnode_3C_20K_2C_20jh_3A_3Atyped_3A_3Amonostate_20_3E"><td class="memItemLeft">struct &#160;</td><td class="memItemRight"><a class="el" href="structjh_1_1avl_1_1avl__node_3_01K_00_01jh_1_1typed_1_1monostate_01_4.html">jh::avl::avl_node&lt; K, jh::typed::monostate &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Node element for set-style contiguous AVL trees.  <a href="structjh_1_1avl_1_1avl__node_3_01K_00_01jh_1_1typed_1_1monostate_01_4.html#details">More...</a><br /></td></tr>
<tr class="memitem:jh_3A_3Aavl_3A_3Atree_5Fmap_3C_20K_2C_20V_2C_20Alloc_20_3E" id="r_jh_3A_3Aavl_3A_3Atree_5Fmap_3C_20K_2C_20V_2C_20Alloc_20_3E"><td class="memItemLeft">class &#160;</td><td class="memItemRight"><a class="el" href="classjh_1_1avl_1_1tree__map.html">jh::avl::tree_map&lt; K, V, Alloc &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contiguous-array AVL tree used by <code><a class="el" href="namespacejh.html#adc97eb86056b9268c8b5c7378587c2be" title="Ordered associative map based on a contiguous-array AVL tree.">jh::ordered_map</a></code> and <code><a class="el" href="namespacejh.html#a7d49c250af115c5a63acb88c1b38c3ec" title="Ordered associative set based on a contiguous-array AVL tree.">jh::ordered_set</a></code>.  <a href="classjh_1_1avl_1_1tree__map.html#details">More...</a><br /></td></tr>
<tr class="memitem:jh_3A_3Aavl_3A_3Atree_5Fmap_3C_20K_2C_20V_2C_20Alloc_20_3E_3A_3Aiterator" id="r_jh_3A_3Aavl_3A_3Atree_5Fmap_3C_20K_2C_20V_2C_20Alloc_20_3E_3A_3Aiterator"><td class="memItemLeft">struct &#160;</td><td class="memItemRight"><a class="el" href="structjh_1_1avl_1_1tree__map_1_1iterator.html">jh::avl::tree_map&lt; K, V, Alloc &gt;::iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bidirectional iterator providing in-order traversal.  <a href="structjh_1_1avl_1_1tree__map_1_1iterator.html#details">More...</a><br /></td></tr>
<tr class="memitem:jh_3A_3Aavl_3A_3Atree_5Fmap_3C_20K_2C_20V_2C_20Alloc_20_3E_3A_3Aconst_5Fiterator" id="r_jh_3A_3Aavl_3A_3Atree_5Fmap_3C_20K_2C_20V_2C_20Alloc_20_3E_3A_3Aconst_5Fiterator"><td class="memItemLeft">struct &#160;</td><td class="memItemRight"><a class="el" href="structjh_1_1avl_1_1tree__map_1_1const__iterator.html">jh::avl::tree_map&lt; K, V, Alloc &gt;::const_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const bidirectional iterator for in-order traversal.  <a href="structjh_1_1avl_1_1tree__map_1_1const__iterator.html#details">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-typedef-members" class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a7d49c250af115c5a63acb88c1b38c3ec" id="r_a7d49c250af115c5a63acb88c1b38c3ec"><td class="memTemplParams" colspan="2">template&lt;typename K, typename Alloc = std::allocator&lt;K&gt;&gt; </td></tr>
<tr class="memitem:a7d49c250af115c5a63acb88c1b38c3ec template"><td class="memItemLeft">using&#160;</td><td class="memItemRight"><a class="el" href="namespacejh.html#a7d49c250af115c5a63acb88c1b38c3ec">jh::ordered_set</a></td></tr>
<tr class="memdesc:a7d49c250af115c5a63acb88c1b38c3ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ordered associative set based on a contiguous-array AVL tree.  <br /></td></tr>
<tr class="memitem:adc97eb86056b9268c8b5c7378587c2be" id="r_adc97eb86056b9268c8b5c7378587c2be"><td class="memTemplParams" colspan="2">template&lt;typename K, typename V, typename Alloc = std::allocator&lt;std::pair&lt;const K, V&gt;&gt;&gt; </td></tr>
<tr class="memitem:adc97eb86056b9268c8b5c7378587c2be template"><td class="memItemLeft">using&#160;</td><td class="memItemRight"><a class="el" href="namespacejh.html#adc97eb86056b9268c8b5c7378587c2be">jh::ordered_map</a></td></tr>
<tr class="memdesc:adc97eb86056b9268c8b5c7378587c2be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ordered associative map based on a contiguous-array AVL tree.  <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Contiguous AVL-based ordered container with fragmentation-free semantics. </p>
<dl class="section copyright"><dt>Copyright</dt><dd>Copyright 2025 JeongHan-Bae &lt;mastropseudo@gmail.com&gt; <br  />
 Licensed under the Apache License, Version 2.0 (the "License"); <br  />
 you may not use this file except in compliance with the License.<br  />
 You may obtain a copy of the License at<br  />
 <br  />
 <a href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a><br  />
 <br  />
 Unless required by applicable law or agreed to in writing, software<br  />
 distributed under the License is distributed on an "AS IS" BASIS,<br  />
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.<br  />
 See the License for the specific language governing permissions and<br  />
 limitations under the License.<br  />
 <br  />
 Full license: <a href="https://github.com/JeongHan-Bae/JH-Toolkit?tab=Apache-2.0-1-ov-file#readme">GitHub</a></dd></dl>
<dl class="section author"><dt>Author</dt><dd>JeongHan-Bae <a href="#" onclick="location.href='mai'+'lto:'+'mas'+'tr'+'ops'+'eu'+'do@'+'gm'+'ail'+'.c'+'om'; return false;">&lt;mastropseudo@gmail.com&gt;</a></dd></dl>
<h3>Overview</h3>
<p><code><a class="el" href="namespacejh.html#a7d49c250af115c5a63acb88c1b38c3ec" title="Ordered associative set based on a contiguous-array AVL tree.">jh::ordered_set&lt;K&gt;</a></code> and <code><a class="el" href="namespacejh.html#adc97eb86056b9268c8b5c7378587c2be" title="Ordered associative map based on a contiguous-array AVL tree.">jh::ordered_map&lt;K,V&gt;</a></code> implement a <b>contiguous AVL tree</b> stored inside a <code>std::vector</code> (or PMR-aware vector), eliminating pointer chasing and reducing allocator fragmentation. Nodes are referred to by <b>indices</b> instead of pointers, enabling stable, cache-friendly traversal and compact memory layout. </p>
<p>These containers are <b>not intended as a full replacement</b> for <code>std::set</code> or <code>std::map</code>, but serve as a <b>predictable, fragmentation-free, and locality-optimized</b> alternative for workloads where: </p>
<ul>
<li>
memory fragmentation must be controlled, </li>
<li>
allocator churn is expensive or unstable, </li>
<li>
iterators need predictable traversal cost, </li>
<li>
large-scale workloads favor cache locality, </li>
<li>
PMR-based pooling is desired for <span class="tt">O(1)</span> mass-clear operations. </li>
</ul>
<h3>Design Goals</h3>
<ul>
<li>
Minimize fragmentation by storing all nodes in a contiguous vector. </li>
<li>
Provide stable, predictable erasure via compactification. </li>
<li>
Offer STL-like API semantics (find, lower_bound, iteration, erase). </li>
<li>
Exploit cache locality by avoiding pointer-heavy RB-tree structures. </li>
<li>
Ensure deterministic <code>clear()</code> behavior under PMR. </li>
</ul>
<h3>Internal Storage Model</h3>
<p>Nodes are stored as <b>AVL nodes</b> in a contiguous vector: </p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>node {</div>
<div class="line">    store_t stored_; <span class="comment">// std::pair&lt;K, V&gt; for map or K for set</span></div>
<div class="line">    <span class="keywordtype">size_t</span> parent, left, right;</div>
<div class="line">    uint16_t height;</div>
<div class="line">};</div>
</div><!-- fragment --><ul>
<li>
No node is heap-allocated individually. </li>
<li>
Index references remain valid except for the erased node itself. </li>
<li>
Erase compacts the last node into the erased node's slot. </li>
<li>
AVL rotation works on indices instead of pointers. </li>
</ul>
<h3>Comparison vs <code>std::set</code> / <code>std::map</code></h3>
<table class="doxtable">
<tr>
<th>Aspect</th><th><code>std::set</code> <code>std::map</code></th><th><code><a class="el" href="namespacejh.html#a7d49c250af115c5a63acb88c1b38c3ec" title="Ordered associative set based on a contiguous-array AVL tree.">jh::ordered_set</a></code> <code>ordered_map</code></th></tr>
<tr>
<td>Node layout</td><td>pointer-linked RB-tree</td><td>contiguous AVL (vector)</td></tr>
<tr>
<td>Fragmentation</td><td>high (many small allocations)</td><td>minimal (1 vector buffer)</td></tr>
<tr>
<td>Iterator stability</td><td>stable</td><td>stable except erased node</td></tr>
<tr>
<td>Erase cost</td><td><span class="tt">O(log N)</span></td><td><span class="tt">O(log N)</span> + compactification</td></tr>
<tr>
<td>Traversal locality</td><td>poor (pointer chasing)</td><td>excellent</td></tr>
<tr>
<td>PMR <code>clear()</code></td><td>deep node destruction</td><td><span class="tt">O(1)</span>, vector reset</td></tr>
<tr>
<td>For &gt;5k elements</td><td>stable but noisy</td><td>predictable, low jitter</td></tr>
</table>
<h3>Rationale — Why It Exists</h3>
<p>Modern allocators suffer from fragmentation under workloads that frequently construct and destroy many tree nodes (e.g., dynamic indexing, routing tables, message subscription graphs). The standard containers rely on one allocation per node, causing: </p>
<ul>
<li>
allocator churn, </li>
<li>
TLB pressure and cache misses, </li>
<li>
unpredictable latency spikes, </li>
<li>
free-list poisoning in long-running systems. </li>
</ul>
<p>The contiguous AVL model eliminates these issues by placing all nodes into a single dynamic buffer. Erasing a node does not free any memory; it simply moves the last node into the removed slot. Combined with a monotonic-buffer resource, <code>clear()</code> becomes nearly <span class="tt">O(1)</span>. </p>
<h3>About Performance</h3>
<p>Benchmarks (Apple M3, LLVM clang++20, 2025) show stable behavior across 5 000-1 000 000 elements: </p>
<table class="doxtable">
<tr>
<th>Operation</th><th><code>std::set/map</code></th><th><code><a class="el" href="namespacejh.html#a7d49c250af115c5a63acb88c1b38c3ec" title="Ordered associative set based on a contiguous-array AVL tree.">jh::ordered_set</a>/map</code></th><th>Notes</th></tr>
<tr>
<td>Random insert</td><td>fast start, large jitter</td><td>≈ 10-40% overhead but small jitter</td><td>AVL maintenance but contiguous memory</td></tr>
<tr>
<td>Ordered insert</td><td>degenerates (right-heavy RB)</td><td>consistently faster</td><td>vector locality dominates</td></tr>
<tr>
<td>Random lookup</td><td>stable</td><td>comparable or slightly faster</td><td>branchless traversal &amp; locality</td></tr>
<tr>
<td>Iteration</td><td>pointer chasing</td><td>≈ 15-30% faster</td><td>sequential memory</td></tr>
<tr>
<td>Erase</td><td>stable</td><td>slightly slower worst-case</td><td>compacting cost</td></tr>
<tr>
<td>Clear (PMR)</td><td><span class="tt">O(N)</span> destruct</td><td><span class="tt">O(1)</span></td><td>pool discard</td></tr>
</table>
<h4>Observed Behavior in Large Datasets</h4>
<ul>
<li>
For 100k-1M string keys, performance gap tightens to within ~10%. </li>
<li>
For fully ordered input, <code>ordered_set</code> often surpasses std::set. </li>
<li>
Lookup variance is consistently lower due to contiguous cachelines. </li>
<li>
Iteration is measurably faster at all scales. </li>
</ul>
<h3>Memory &amp; Fragmentation Notes</h3>
<ul>
<li>
No per-node allocation → extremely low fragmentation. </li>
<li>
<code>erase()</code> never frees memory. </li>
<li>
<code>clear()</code> under PMR is almost zero-cost. </li>
<li>
Ideal for systems where pointers must not be invalidated by allocators. </li>
<li>
Much more stable than pointer-based trees under long uptimes. </li>
</ul>
<h3>Limitations</h3>
<ul>
<li>
Iterators are invalidated by <code>erase()</code> except the returned one. </li>
<li>
Does not provide node-hint insertion APIs (unlike <code>std::map::insert(hint)</code>). </li>
<li>
Erase requires compactification (copy/move of last node). </li>
<li>
Not designed for persistent node references. </li>
</ul>
<h3>Use Cases</h3>
<ul>
<li>
Memory-fragmentation-sensitive systems (game engines, GUI trees, routing). </li>
<li>
Real-time components requiring predictable latency. </li>
<li>
Systems with massive clear/repoulate cycles using PMR. </li>
<li>
Large ordered indexes requiring sequential iteration. </li>
</ul>
<h3>Complexity Summary</h3>
<ul>
<li>
Insert: <span class="tt">O(log N)</span> </li>
<li>
Erase: <span class="tt">O(log N)</span> + <span class="tt">O(1)</span> compact </li>
<li>
Find: <span class="tt">O(log N)</span> </li>
<li>
Traversal: <span class="tt">O(N)</span>, cache-friendly </li>
</ul>
<dl class="section version"><dt>Version</dt><dd><pre>1.4.x</pre> </dd></dl>
<dl class="section date"><dt>Date</dt><dd><pre>2025</pre> </dd></dl>
</div></div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
</div> <!-- top -->
<hr class="footer"/>
<div class="footer">
    <img class="footer-logo" src="Ojing.svg" alt="Ojing"/>
    <div class="footer-text">
        JH-Toolkit v1.4.0 · Generated by Doxygen
    </div>
    <div class="footer-note">
        We primarily support embedded documentation views in IDEs (classic CLion).
        To ensure compatibility with embedded rendering, some example code in this
        documentation intentionally contains HTML entities.
        In certain cases, Doxygen does not unescape these entities correctly.
        This is a known limitation and currently has no workaround.
    </div>
</div>
</body>
</html>
