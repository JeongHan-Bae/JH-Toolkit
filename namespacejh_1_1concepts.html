<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.16.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>JH-Toolkit: jh::concepts Namespace Reference</title>
<link rel="icon" href="Jindallae.svg" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="Oree.svg"/></td>
  <td id="projectalign">
   <div id="projectname">JH-Toolkit<span id="projectnumber">&#160;v1.4.0</span>
   </div>
   <div id="projectbrief">An engineering-oriented C++20 toolkit with duck-typed concepts, static design, async coroutines, and semantic containers — header-only, RTTI-free, and concurrency-friendly.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.16.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('namespacejh_1_1concepts.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">jh::concepts Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:range_5Fstorage_5Ftraits" id="r_range_5Fstorage_5Ftraits"><td class="memItemLeft">struct &#160;</td><td class="memItemRight"><a class="el" href="structjh_1_1concepts_1_1range__storage__traits.html">range_storage_traits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait defining how a range (or equivalent) is held inside a view or wrapper.  <a href="structjh_1_1concepts_1_1range__storage__traits.html#details">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-concepts" class="groupheader"><a id="concepts" name="concepts"></a>
Concepts</h2></td></tr>
<tr class="memitem:closable_5Fcontainer_5Ffor" id="r_closable_5Fcontainer_5Ffor"><td class="memItemLeft">concept &#160;</td><td class="memItemRight"><a class="el" href="conceptjh_1_1concepts_1_1closable__container__for.html">closable_container_for</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept checking whether a container <code>C</code> can be directly constructed ("closed") from a range <code>R</code>. <br /></td></tr>
<tr class="memitem:collectable_5Fcontainer_5Ffor" id="r_collectable_5Fcontainer_5Ffor"><td class="memItemLeft">concept &#160;</td><td class="memItemRight"><a class="el" href="conceptjh_1_1concepts_1_1collectable__container__for.html">collectable_container_for</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept verifying that a container <code>C</code> can collect elements from a range <code>R</code> via incremental insertion. <br /></td></tr>
<tr class="memitem:is_5Fcontiguous_5Freallocable" id="r_is_5Fcontiguous_5Freallocable"><td class="memItemLeft">concept &#160;</td><td class="memItemRight"><a class="el" href="conceptjh_1_1concepts_1_1is__contiguous__reallocable.html">is_contiguous_reallocable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that constrains types usable in contiguous, reallocating containers. <br /></td></tr>
<tr class="memitem:has_5Fstd_5Fhash" id="r_has_5Fstd_5Fhash"><td class="memItemLeft">concept &#160;</td><td class="memItemRight"><a class="el" href="conceptjh_1_1concepts_1_1has__std__hash.html">has_std_hash</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether <code>std::hash&lt;T&gt;</code> is valid and callable. <br /></td></tr>
<tr class="memitem:has_5Fadl_5Fhash" id="r_has_5Fadl_5Fhash"><td class="memItemLeft">concept &#160;</td><td class="memItemRight"><a class="el" href="conceptjh_1_1concepts_1_1has__adl__hash.html">has_adl_hash</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether a free (ADL-discoverable) <code>hash()</code> function exists. <br /></td></tr>
<tr class="memitem:has_5Fmbr_5Fhash" id="r_has_5Fmbr_5Fhash"><td class="memItemLeft">concept &#160;</td><td class="memItemRight"><a class="el" href="conceptjh_1_1concepts_1_1has__mbr__hash.html">has_mbr_hash</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether a type defines a <code>hash()</code> member function. <br /></td></tr>
<tr class="memitem:extended_5Fhashable" id="r_extended_5Fhashable"><td class="memItemLeft">concept &#160;</td><td class="memItemRight"><a class="el" href="conceptjh_1_1concepts_1_1extended__hashable.html">extended_hashable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept for types that can be hashed through any supported mechanism. <br /></td></tr>
<tr class="memitem:indirectly_5Freadable" id="r_indirectly_5Freadable"><td class="memItemLeft">concept &#160;</td><td class="memItemRight"><a class="el" href="conceptjh_1_1concepts_1_1indirectly__readable.html">indirectly_readable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept for types that can be read indirectly via dereference. <br /></td></tr>
<tr class="memitem:indirectly_5Fwritable" id="r_indirectly_5Fwritable"><td class="memItemLeft">concept &#160;</td><td class="memItemRight"><a class="el" href="conceptjh_1_1concepts_1_1indirectly__writable.html">indirectly_writable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept for types that support indirect write operations through dereference. <br /></td></tr>
<tr class="memitem:is_5Fiterator" id="r_is_5Fiterator"><td class="memItemLeft">concept &#160;</td><td class="memItemRight"><a class="el" href="conceptjh_1_1concepts_1_1is__iterator.html">is_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept for detecting iterator-like types based on behavior. <br /></td></tr>
<tr class="memitem:sentinel_5Ffor" id="r_sentinel_5Ffor"><td class="memItemLeft">concept &#160;</td><td class="memItemRight"><a class="el" href="conceptjh_1_1concepts_1_1sentinel__for.html">sentinel_for</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept for detecting sentinel-iterator compatibility. <br /></td></tr>
<tr class="memitem:input_5Fiterator" id="r_input_5Fiterator"><td class="memItemLeft">concept &#160;</td><td class="memItemRight"><a class="el" href="conceptjh_1_1concepts_1_1input__iterator.html">input_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept for readable, comparable single-pass iterators. <br /></td></tr>
<tr class="memitem:output_5Fiterator" id="r_output_5Fiterator"><td class="memItemLeft">concept &#160;</td><td class="memItemRight"><a class="el" href="conceptjh_1_1concepts_1_1output__iterator.html">output_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept for writable single-pass iterators. <br /></td></tr>
<tr class="memitem:forward_5Fiterator" id="r_forward_5Fiterator"><td class="memItemLeft">concept &#160;</td><td class="memItemRight"><a class="el" href="conceptjh_1_1concepts_1_1forward__iterator.html">forward_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept for multi-pass, readable, and self-sentinel iterators. <br /></td></tr>
<tr class="memitem:bidirectional_5Fiterator" id="r_bidirectional_5Fiterator"><td class="memItemLeft">concept &#160;</td><td class="memItemRight"><a class="el" href="conceptjh_1_1concepts_1_1bidirectional__iterator.html">bidirectional_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept for iterators supporting bidirectional traversal. <br /></td></tr>
<tr class="memitem:random_5Faccess_5Fiterator" id="r_random_5Faccess_5Fiterator"><td class="memItemLeft">concept &#160;</td><td class="memItemRight"><a class="el" href="conceptjh_1_1concepts_1_1random__access__iterator.html">random_access_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept for iterators supporting random access operations. <br /></td></tr>
<tr class="memitem:basic_5Flockable" id="r_basic_5Flockable"><td class="memItemLeft">concept &#160;</td><td class="memItemRight"><a class="el" href="conceptjh_1_1concepts_1_1basic__lockable.html">basic_lockable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept for basic lockable objects. <br /></td></tr>
<tr class="memitem:excl_5Flockable" id="r_excl_5Flockable"><td class="memItemLeft">concept &#160;</td><td class="memItemRight"><a class="el" href="conceptjh_1_1concepts_1_1excl__lockable.html">excl_lockable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept for exclusive lockable objects supporting try semantics. <br /></td></tr>
<tr class="memitem:timed_5Fexcl_5Flockable" id="r_timed_5Fexcl_5Flockable"><td class="memItemLeft">concept &#160;</td><td class="memItemRight"><a class="el" href="conceptjh_1_1concepts_1_1timed__excl__lockable.html">timed_excl_lockable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept for timed exclusive lockable objects. <br /></td></tr>
<tr class="memitem:shared_5Flockable" id="r_shared_5Flockable"><td class="memItemLeft">concept &#160;</td><td class="memItemRight"><a class="el" href="conceptjh_1_1concepts_1_1shared__lockable.html">shared_lockable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept for shared (reader) lockable objects. <br /></td></tr>
<tr class="memitem:timed_5Fshared_5Flockable" id="r_timed_5Fshared_5Flockable"><td class="memItemLeft">concept &#160;</td><td class="memItemRight"><a class="el" href="conceptjh_1_1concepts_1_1timed__shared__lockable.html">timed_shared_lockable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept for shared lockables supporting timed acquisition. <br /></td></tr>
<tr class="memitem:mutex_5Flike" id="r_mutex_5Flike"><td class="memItemLeft">concept &#160;</td><td class="memItemRight"><a class="el" href="conceptjh_1_1concepts_1_1mutex__like.html">mutex_like</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">General mutex-like concept. <br /></td></tr>
<tr class="memitem:timed_5Fmutex_5Flike" id="r_timed_5Fmutex_5Flike"><td class="memItemLeft">concept &#160;</td><td class="memItemRight"><a class="el" href="conceptjh_1_1concepts_1_1timed__mutex__like.html">timed_mutex_like</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Timed variant of <code>mutex_like</code>. <br /></td></tr>
<tr class="memitem:rw_5Fmutex_5Flike" id="r_rw_5Fmutex_5Flike"><td class="memItemLeft">concept &#160;</td><td class="memItemRight"><a class="el" href="conceptjh_1_1concepts_1_1rw__mutex__like.html">rw_mutex_like</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read-write (RW) mutex concept. <br /></td></tr>
<tr class="memitem:recursive_5Fmutex" id="r_recursive_5Fmutex"><td class="memItemLeft">concept &#160;</td><td class="memItemRight"><a class="el" href="conceptjh_1_1concepts_1_1recursive__mutex.html">recursive_mutex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept for counting reentrant (recursive) mutexes. <br /></td></tr>
<tr class="memitem:reentrant_5Fmutex" id="r_reentrant_5Fmutex"><td class="memItemLeft">concept &#160;</td><td class="memItemRight"><a class="el" href="conceptjh_1_1concepts_1_1reentrant__mutex.html">reentrant_mutex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept for idempotent (structurally reentrant) mutexes. <br /></td></tr>
<tr class="memitem:reentrance_5Fcapable_5Fmutex" id="r_reentrance_5Fcapable_5Fmutex"><td class="memItemLeft">concept &#160;</td><td class="memItemRight"><a class="el" href="conceptjh_1_1concepts_1_1reentrance__capable__mutex.html">reentrance_capable_mutex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept for any mutex supporting some form of reentrance. <br /></td></tr>
<tr class="memitem:vis_5Ffunction_5Ffor" id="r_vis_5Ffunction_5Ffor"><td class="memItemLeft">concept &#160;</td><td class="memItemRight"><a class="el" href="conceptjh_1_1concepts_1_1vis__function__for.html">vis_function_for</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept describing the <em>visual relation</em> between a range and a callable. <br /></td></tr>
<tr class="memitem:sequence" id="r_sequence"><td class="memItemLeft">concept &#160;</td><td class="memItemRight"><a class="el" href="conceptjh_1_1concepts_1_1sequence.html">sequence</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that checks whether a type provides at least const (non-destructive) iteration. <br /></td></tr>
<tr class="memitem:tuple_5Flike" id="r_tuple_5Flike"><td class="memItemLeft">concept &#160;</td><td class="memItemRight"><a class="el" href="conceptjh_1_1concepts_1_1tuple__like.html">tuple_like</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept recognizing <em>tuple-like</em> types. <br /></td></tr>
<tr class="memitem:pair_5Flike_5Ffor" id="r_pair_5Flike_5Ffor"><td class="memItemLeft">concept &#160;</td><td class="memItemRight"><a class="el" href="conceptjh_1_1concepts_1_1pair__like__for.html">pair_like_for</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether a type <code>P</code> is a 2-element tuple-like whose element types exactly match <code>K</code> and <code>V</code> (after remove_cvref). <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-typedef-members" class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a17b668c25a49f10c9af122eb3c04b8fd" id="r_a17b668c25a49f10c9af122eb3c04b8fd"><td class="memTemplParams" colspan="2">template&lt;typename C&gt; </td></tr>
<tr class="memitem:a17b668c25a49f10c9af122eb3c04b8fd template"><td class="memItemLeft">using&#160;</td><td class="memItemRight"><a class="el" href="#a17b668c25a49f10c9af122eb3c04b8fd">container_value_t</a> = typename detail::container_value_type_impl&lt;C&gt;::type</td></tr>
<tr class="memdesc:a17b668c25a49f10c9af122eb3c04b8fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduce the value type of a container <code>C</code>.  <br /></td></tr>
<tr class="memitem:aa4f38c39bf08009262a9918dda0363a6" id="r_aa4f38c39bf08009262a9918dda0363a6"><td class="memTemplParams" colspan="2"><a id="aa4f38c39bf08009262a9918dda0363a6" name="aa4f38c39bf08009262a9918dda0363a6"></a>
template&lt;typename I&gt; </td></tr>
<tr class="memitem:aa4f38c39bf08009262a9918dda0363a6 template"><td class="memItemLeft">using&#160;</td><td class="memItemRight"><b>iterator_value_t</b> = typename detail::iterator_value_impl&lt;I&gt;::type</td></tr>
<tr class="memdesc:aa4f38c39bf08009262a9918dda0363a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduces the value type of a duck-typed iterator. <br /></td></tr>
<tr class="memitem:a5fee47c1d444a07d9826e06bf9ff950c" id="r_a5fee47c1d444a07d9826e06bf9ff950c"><td class="memTemplParams" colspan="2"><a id="a5fee47c1d444a07d9826e06bf9ff950c" name="a5fee47c1d444a07d9826e06bf9ff950c"></a>
template&lt;typename I&gt; </td></tr>
<tr class="memitem:a5fee47c1d444a07d9826e06bf9ff950c template"><td class="memItemLeft">using&#160;</td><td class="memItemRight"><b>iterator_reference_t</b> = typename detail::iterator_reference_impl&lt;I&gt;::type</td></tr>
<tr class="memdesc:a5fee47c1d444a07d9826e06bf9ff950c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduces the reference type of a duck-typed iterator. <br /></td></tr>
<tr class="memitem:a9fde97daa679bb387820a2cb33d63eff" id="r_a9fde97daa679bb387820a2cb33d63eff"><td class="memTemplParams" colspan="2"><a id="a9fde97daa679bb387820a2cb33d63eff" name="a9fde97daa679bb387820a2cb33d63eff"></a>
template&lt;typename I&gt; </td></tr>
<tr class="memitem:a9fde97daa679bb387820a2cb33d63eff template"><td class="memItemLeft">using&#160;</td><td class="memItemRight"><b>iterator_rvalue_reference_t</b> = decltype(detail::adl_iter_move(std::declval&lt;I &amp;&gt;()))</td></tr>
<tr class="memdesc:a9fde97daa679bb387820a2cb33d63eff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduces the rvalue reference type of a duck-typed iterator. <br /></td></tr>
<tr class="memitem:a0283e4f328972b869d13761d0424690e" id="r_a0283e4f328972b869d13761d0424690e"><td class="memTemplParams" colspan="2"><a id="a0283e4f328972b869d13761d0424690e" name="a0283e4f328972b869d13761d0424690e"></a>
template&lt;typename I&gt; </td></tr>
<tr class="memitem:a0283e4f328972b869d13761d0424690e template"><td class="memItemLeft">using&#160;</td><td class="memItemRight"><b>iterator_difference_t</b> = typename detail::iterator_difference_impl&lt;I&gt;::type</td></tr>
<tr class="memdesc:a0283e4f328972b869d13761d0424690e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduces the difference type of a duck-typed iterator. <br /></td></tr>
<tr class="memitem:a6939938cf019276ab13d2d6bf87d2f77" id="r_a6939938cf019276ab13d2d6bf87d2f77"><td class="memTemplParams" colspan="2">template&lt;typename Container&gt; </td></tr>
<tr class="memitem:a6939938cf019276ab13d2d6bf87d2f77 template"><td class="memItemLeft">using&#160;</td><td class="memItemRight"><a class="el" href="#a6939938cf019276ab13d2d6bf87d2f77">iterator_t</a> = typename detail::iterator_resolver&lt;Container&gt;::type</td></tr>
<tr class="memdesc:a6939938cf019276ab13d2d6bf87d2f77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduces the iterator type associated with a container, pointer, or array.  <br /></td></tr>
<tr class="memitem:a288fd2a9c1ffde90dc5ca09475e9cd3f" id="r_a288fd2a9c1ffde90dc5ca09475e9cd3f"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a288fd2a9c1ffde90dc5ca09475e9cd3f template"><td class="memItemLeft">using&#160;</td><td class="memItemRight"><a class="el" href="#a288fd2a9c1ffde90dc5ca09475e9cd3f">sequence_value_t</a> = typename detail::sequence_value_type_impl&lt;T&gt;::type</td></tr>
<tr class="memdesc:a288fd2a9c1ffde90dc5ca09475e9cd3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the element type of a sequence.  <br /></td></tr>
<tr class="memitem:ad4487661b047c2f80950faa2a81d6f94" id="r_ad4487661b047c2f80950faa2a81d6f94"><td class="memTemplParams" colspan="2">template&lt;sequence Seq&gt; </td></tr>
<tr class="memitem:ad4487661b047c2f80950faa2a81d6f94 template"><td class="memItemLeft">using&#160;</td><td class="memItemRight"><a class="el" href="#ad4487661b047c2f80950faa2a81d6f94">sequence_difference_t</a></td></tr>
<tr class="memdesc:ad4487661b047c2f80950faa2a81d6f94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduce the <code>difference_type</code> used by a sequence after range adaptation.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-var-members" class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a1cf0fbac4bb034f80c09043e5da83083" id="r_a1cf0fbac4bb034f80c09043e5da83083"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a1cf0fbac4bb034f80c09043e5da83083 template"><td class="memItemLeft">constexpr bool&#160;</td><td class="memItemRight"><a class="el" href="#a1cf0fbac4bb034f80c09043e5da83083">is_sequence</a> = sequence&lt;T&gt;</td></tr>
<tr class="memdesc:a1cf0fbac4bb034f80c09043e5da83083"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile-time check for sequence compliance.  <br /></td></tr>
<tr class="memitem:aca802e7cca57b1c34f4d4877c914d035" id="r_aca802e7cca57b1c34f4d4877c914d035"><td class="memItemLeft"><a id="aca802e7cca57b1c34f4d4877c914d035" name="aca802e7cca57b1c34f4d4877c914d035"></a>
constexpr std::uint16_t&#160;</td><td class="memItemRight"><b>max_pod_array_bytes</b></td></tr>
<tr class="memdesc:aca802e7cca57b1c34f4d4877c914d035"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum size of a POD array (16KB). This is a compile-time constant. <br /></td></tr>
<tr class="memitem:a8721ba190c9c5f34c6d5a07381547fec" id="r_a8721ba190c9c5f34c6d5a07381547fec"><td class="memItemLeft"><a id="a8721ba190c9c5f34c6d5a07381547fec" name="a8721ba190c9c5f34c6d5a07381547fec"></a>
constexpr std::uint16_t&#160;</td><td class="memItemRight"><b>max_pod_bitflags_bytes</b></td></tr>
<tr class="memdesc:a8721ba190c9c5f34c6d5a07381547fec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum allowed size of a POD bitflags structure: 4KB (4096 bytes). <br /></td></tr>
<tr class="memitem:a53d7a874d813bd6afac202dda29fe9b9" id="r_a53d7a874d813bd6afac202dda29fe9b9"><td class="memTemplParams" colspan="2">template&lt;typename C&gt; </td></tr>
<tr class="memitem:a53d7a874d813bd6afac202dda29fe9b9 template"><td class="memItemLeft">constexpr <a class="el" href="structjh_1_1pod_1_1pair.html">jh::pod::pair</a>&lt; data_status, len_status &gt;&#160;</td><td class="memItemRight"><a class="el" href="#a53d7a874d813bd6afac202dda29fe9b9">linear_status</a></td></tr>
<tr class="memdesc:a53d7a874d813bd6afac202dda29fe9b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Precomputed linear-container classification result.  <br /></td></tr>
</table>
<a name="doc-typedef-members" id="doc-typedef-members"></a><h2 id="header-doc-typedef-members" class="groupheader">Typedef Documentation</h2>
<a id="a17b668c25a49f10c9af122eb3c04b8fd" name="a17b668c25a49f10c9af122eb3c04b8fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17b668c25a49f10c9af122eb3c04b8fd">&#9670;&#160;</a></span>container_value_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a17b668c25a49f10c9af122eb3c04b8fd">jh::concepts::container_value_t</a> = typename detail::container_value_type_impl&lt;C&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deduce the value type of a container <code>C</code>. </p>
<p>Resolution rules: </p><ol>
<li>
If <code>jh::container_deduction&lt;C&gt;::value_type</code> is explicitly defined, it overrides all other deduction mechanisms. </li>
<li>
Otherwise, deduction proceeds using the following logic: <ul>
<li>
If only <code>C::value_type</code> exists, it is used. </li>
<li>
If only iterator deduction (<code><a class="el" href="#a6939938cf019276ab13d2d6bf87d2f77" title="Deduces the iterator type associated with a container, pointer, or array.">iterator_t</a></code> and <code><a class="el" href="#aa4f38c39bf08009262a9918dda0363a6" title="Deduces the value type of a duck-typed iterator.">iterator_value_t</a></code>) is available, it is used. </li>
<li>
If both <code>C::value_type</code> and iterator deduction exist, they must not conflict. If they share a common reference type, the declared <code>C::value_type</code> is selected. </li>
</ul>
</li>
<li>
If no valid deduction is possible, the result is <span class="tt">void</span>. </li>
</ol>
<dl class="section note"><dt>Note</dt><dd>When using a proxy reference type within an iterator, the proxy should be implicitly convertible to the iterator's <code>value_type</code> to ensure correct participation in generic deduction. For full interoperability, it is recommended to register explicit <code>std::common_reference</code> specializations as follows:</dd></dl>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">struct </span>std::common_reference&lt;ProxyT, T&gt; { <span class="keyword">using </span>type = T; };</div>
<div class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">struct </span>std::common_reference&lt;T, ProxyT&gt; { <span class="keyword">using </span>type = T; };</div>
<div class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">struct </span>std::common_reference&lt;ProxyT, ProxyT&gt; { <span class="keyword">using </span>type = ProxyT; };</div>
</div><!-- fragment --><p>For completeness, derived forms should be added for reference and rvalue combinations, inheriting from the base forms: </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">struct </span>std::common_reference&lt;ProxyT&amp;, T&amp;&gt;</div>
<div class="line">    : std::common_reference&lt;ProxyT, T&gt; {};</div>
<div class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">struct </span>std::common_reference&lt;ProxyT&amp;&amp;, T&amp;&amp;&gt;</div>
<div class="line">    : std::common_reference&lt;ProxyT, T&gt; {};</div>
<div class="line"><span class="comment">// and T, ProxyT swapped forms, ProxyT with itself, etc.</span></div>
</div><!-- fragment --><p>This ensures that proxy iterators remain compatible with generic range-based algorithms and container deduction mechanisms.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">C</td><td>The container type to deduce from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The deduced element type or <span class="tt">void</span> if deduction fails. </dd></dl>

</div>
</div>
<a id="a6939938cf019276ab13d2d6bf87d2f77" name="a6939938cf019276ab13d2d6bf87d2f77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6939938cf019276ab13d2d6bf87d2f77">&#9670;&#160;</a></span>iterator_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a6939938cf019276ab13d2d6bf87d2f77">jh::concepts::iterator_t</a> = typename detail::iterator_resolver&lt;Container&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deduces the iterator type associated with a container, pointer, or array. </p>
<p><code><a class="el" href="#a6939938cf019276ab13d2d6bf87d2f77" title="Deduces the iterator type associated with a container, pointer, or array.">iterator_t&lt;Container&gt;</a></code> provides a unified iterator deduction path for all iterable entities supported by the JH Toolkit. It cooperates with <code><a class="el" href="structjh_1_1iterator.html" title="Forward declaration of jh::iterator&lt;Container&gt;.">jh::iterator&lt;Container&gt;</a></code>, which serves as the non-intrusive extension point for third-party containers.</p>
<p><b>Unified Deduction Model</b> </p>
<p><code><a class="el" href="#a6939938cf019276ab13d2d6bf87d2f77" title="Deduces the iterator type associated with a container, pointer, or array.">iterator_t&lt;Container&gt;</a></code> selects the iterator in the following order: </p>
<ol>
<li>
<code>jh::iterator&lt;Container&gt;::type</code> </li>
<li>
<code>Container::iterator</code> </li>
<li>
<code>decltype(Container.begin())</code> </li>
<li>
<code>T*</code> (raw pointer) </li>
<li>
<code>T[N]</code> or <code>T[]</code> decayed to <code>T*</code> </li>
</ol>
<p>This mechanism ensures consistent iterator semantics across standard containers, duck-typed containers, pointers, and arrays, while allowing external iterator declarations for non-modifiable third-party types. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>The type whose iterator is to be deduced. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad4487661b047c2f80950faa2a81d6f94" name="ad4487661b047c2f80950faa2a81d6f94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4487661b047c2f80950faa2a81d6f94">&#9670;&#160;</a></span>sequence_difference_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;sequence Seq&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ad4487661b047c2f80950faa2a81d6f94">jh::concepts::sequence_difference_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">std::ranges::range_difference_t&lt;decltype(jh::to_range(std::declval&lt;Seq &amp;&gt;()))&gt;</div>
</div><!-- fragment -->
<p>Deduce the <code>difference_type</code> used by a sequence after range adaptation. </p>
<p>This alias evaluates the <code>difference_type</code> that would be observed by STL algorithms after converting a <code><a class="el" href="conceptjh_1_1concepts_1_1sequence.html" title="Concept that checks whether a type provides at least const (non-destructive) iteration.">jh::concepts::sequence</a></code> into a valid <code>std::ranges::range</code> via <code><a class="el" href="namespacejh.html#a58aa95803840fb814bf92dd4954fb44c" title="Converts a generator factory (lambda or function) into a repeatable range.">jh::to_range()</a></code>. </p>
<p>In effect, it represents the type actually used by standard range-based algorithms for distance and offset calculations. Since every legal range must define a valid difference type, this alias is always well-formed. </p>
<p>If the original <code>sequence</code> does not provide a deducible difference type, the internal <code>range_adaptor</code> automatically falls back to <code>std::ptrdiff_t</code> to ensure STL algorithm compatibility. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Seq</td><td>A type satisfying <code><a class="el" href="conceptjh_1_1concepts_1_1sequence.html" title="Concept that checks whether a type provides at least const (non-destructive) iteration.">jh::concepts::sequence</a></code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a288fd2a9c1ffde90dc5ca09475e9cd3f" name="a288fd2a9c1ffde90dc5ca09475e9cd3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a288fd2a9c1ffde90dc5ca09475e9cd3f">&#9670;&#160;</a></span>sequence_value_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a288fd2a9c1ffde90dc5ca09475e9cd3f">jh::concepts::sequence_value_t</a> = typename detail::sequence_value_type_impl&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts the element type of a sequence. </p>
<p>Resolves the <code>value_type</code> through <code><a class="el" href="#a6939938cf019276ab13d2d6bf87d2f77" title="Deduces the iterator type associated with a container, pointer, or array.">jh::concepts::iterator_t&lt;T&gt;</a></code>. Cleanses cv-ref qualifiers for consistent deduction.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The sequence type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a name="doc-var-members" id="doc-var-members"></a><h2 id="header-doc-var-members" class="groupheader">Variable Documentation</h2>
<a id="a1cf0fbac4bb034f80c09043e5da83083" name="a1cf0fbac4bb034f80c09043e5da83083"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cf0fbac4bb034f80c09043e5da83083">&#9670;&#160;</a></span>is_sequence</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool jh::concepts::is_sequence = sequence&lt;T&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compile-time check for sequence compliance. </p>
<p>Equivalent to <code><a class="el" href="conceptjh_1_1concepts_1_1sequence.html" title="Concept that checks whether a type provides at least const (non-destructive) iteration.">jh::concepts::sequence&lt;T&gt;</a></code>, provided as a <b>boolean constant</b> for generic metaprogramming.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type to check. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a53d7a874d813bd6afac202dda29fe9b9" name="a53d7a874d813bd6afac202dda29fe9b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53d7a874d813bd6afac202dda29fe9b9">&#9670;&#160;</a></span>linear_status</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structjh_1_1pod_1_1pair.html">jh::pod::pair</a>&lt;data_status, len_status&gt; jh::pod::detail::linear_status</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Precomputed linear-container classification result. </p>
<p>This variable template evaluates the compile-time data/length access pattern of a given container type <code>C</code> via <code>compute_view_status&lt;C&gt;()</code>, and caches its pair of <code>data_status</code> / <code>len_status</code> for reuse.</p>
<p><b>ADL Priority:</b><br  />
 Detection prioritizes <b>ADL (Argument-Dependent Lookup)</b> forms such as <code>get_data()</code> or <code>get_size()</code> before checking direct fields or member functions. This allows users to explicitly override default detection when the internal representation is ambiguous or does not meet expectations.</p>
<p><b>Exposure:</b><br  />
 The result is exposed in <b><a class="el" href="namespacejh_1_1concepts.html">jh::concepts</a></b> as <code><a class="el" href="#a53d7a874d813bd6afac202dda29fe9b9" title="Precomputed linear-container classification result.">jh::concepts::linear_status&lt;C&gt;</a></code>, enabling higher-level modules to query whether a type provides pointer-based and length-based accessors without repeating introspection.</p>
<p><b>Note:</b><br  />
 The <b>precomputed</b> status is exposed instead of the function <code>compute_view_status&lt;C&gt;()</code> to minimize compile-time overhead. The constexpr evaluation runs once per type, and subsequent concept checks reuse the cached value.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
</div> <!-- top -->
<hr class="footer"/>
<div class="footer">
    <img class="footer-logo" src="Ojing.svg" alt="Ojing"/>
    <div class="footer-text">
        JH-Toolkit v1.4.0 · Generated by Doxygen
    </div>
    <div class="footer-note">
        We primarily support embedded documentation views in IDEs (classic CLion).
        To ensure compatibility with embedded rendering, some example code in this
        documentation intentionally contains HTML entities.
        In certain cases, Doxygen does not unescape these entities correctly.
        This is a known limitation and currently has no workaround.
    </div>
</div>
</body>
</html>
