<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.16.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>JH-Toolkit: include/jh/conceptual/iterator.h File Reference</title>
<link rel="icon" href="Jindallae.svg" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="Oree.svg"/></td>
  <td id="projectalign">
   <div id="projectname">JH-Toolkit<span id="projectnumber">&#160;v1.4.0</span>
   </div>
   <div id="projectbrief">An engineering-oriented C++20 toolkit with duck-typed concepts, static design, async coroutines, and semantic containers — header-only, RTTI-free, and concurrency-friendly.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.16.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('iterator_8h.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">iterator.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Forward declaration and <b>duck-typed</b> iterator concept definitions.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;<a class="el" href="">concepts</a>&gt;</code><br />
<code>#include &lt;type_traits&gt;</code><br />
<code>#include &lt;utility&gt;</code><br />
</div>
<p><a href="">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-concepts" class="groupheader"><a id="concepts" name="concepts"></a>
Concepts</h2></td></tr>
<tr class="memitem:jh_3A_3Aconcepts_3A_3Aindirectly_5Freadable" id="r_jh_3A_3Aconcepts_3A_3Aindirectly_5Freadable"><td class="memItemLeft">concept &#160;</td><td class="memItemRight"><a class="el" href="conceptjh_1_1concepts_1_1indirectly__readable.html">jh::concepts::indirectly_readable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept for types that can be read indirectly via dereference. <br /></td></tr>
<tr class="memitem:jh_3A_3Aconcepts_3A_3Aindirectly_5Fwritable" id="r_jh_3A_3Aconcepts_3A_3Aindirectly_5Fwritable"><td class="memItemLeft">concept &#160;</td><td class="memItemRight"><a class="el" href="conceptjh_1_1concepts_1_1indirectly__writable.html">jh::concepts::indirectly_writable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept for types that support indirect write operations through dereference. <br /></td></tr>
<tr class="memitem:jh_3A_3Aconcepts_3A_3Ais_5Fiterator" id="r_jh_3A_3Aconcepts_3A_3Ais_5Fiterator"><td class="memItemLeft">concept &#160;</td><td class="memItemRight"><a class="el" href="conceptjh_1_1concepts_1_1is__iterator.html">jh::concepts::is_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept for detecting iterator-like types based on behavior. <br /></td></tr>
<tr class="memitem:jh_3A_3Aconcepts_3A_3Asentinel_5Ffor" id="r_jh_3A_3Aconcepts_3A_3Asentinel_5Ffor"><td class="memItemLeft">concept &#160;</td><td class="memItemRight"><a class="el" href="conceptjh_1_1concepts_1_1sentinel__for.html">jh::concepts::sentinel_for</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept for detecting sentinel-iterator compatibility. <br /></td></tr>
<tr class="memitem:jh_3A_3Aconcepts_3A_3Ainput_5Fiterator" id="r_jh_3A_3Aconcepts_3A_3Ainput_5Fiterator"><td class="memItemLeft">concept &#160;</td><td class="memItemRight"><a class="el" href="conceptjh_1_1concepts_1_1input__iterator.html">jh::concepts::input_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept for readable, comparable single-pass iterators. <br /></td></tr>
<tr class="memitem:jh_3A_3Aconcepts_3A_3Aoutput_5Fiterator" id="r_jh_3A_3Aconcepts_3A_3Aoutput_5Fiterator"><td class="memItemLeft">concept &#160;</td><td class="memItemRight"><a class="el" href="conceptjh_1_1concepts_1_1output__iterator.html">jh::concepts::output_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept for writable single-pass iterators. <br /></td></tr>
<tr class="memitem:jh_3A_3Aconcepts_3A_3Aforward_5Fiterator" id="r_jh_3A_3Aconcepts_3A_3Aforward_5Fiterator"><td class="memItemLeft">concept &#160;</td><td class="memItemRight"><a class="el" href="conceptjh_1_1concepts_1_1forward__iterator.html">jh::concepts::forward_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept for multi-pass, readable, and self-sentinel iterators. <br /></td></tr>
<tr class="memitem:jh_3A_3Aconcepts_3A_3Abidirectional_5Fiterator" id="r_jh_3A_3Aconcepts_3A_3Abidirectional_5Fiterator"><td class="memItemLeft">concept &#160;</td><td class="memItemRight"><a class="el" href="conceptjh_1_1concepts_1_1bidirectional__iterator.html">jh::concepts::bidirectional_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept for iterators supporting bidirectional traversal. <br /></td></tr>
<tr class="memitem:jh_3A_3Aconcepts_3A_3Arandom_5Faccess_5Fiterator" id="r_jh_3A_3Aconcepts_3A_3Arandom_5Faccess_5Fiterator"><td class="memItemLeft">concept &#160;</td><td class="memItemRight"><a class="el" href="conceptjh_1_1concepts_1_1random__access__iterator.html">jh::concepts::random_access_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept for iterators supporting random access operations. <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-typedef-members" class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aa4f38c39bf08009262a9918dda0363a6" id="r_aa4f38c39bf08009262a9918dda0363a6"><td class="memTemplParams" colspan="2"><a id="aa4f38c39bf08009262a9918dda0363a6" name="aa4f38c39bf08009262a9918dda0363a6"></a>
template&lt;typename I&gt; </td></tr>
<tr class="memitem:aa4f38c39bf08009262a9918dda0363a6 template"><td class="memItemLeft">using&#160;</td><td class="memItemRight"><b>jh::concepts::iterator_value_t</b> = typename detail::iterator_value_impl&lt;I&gt;::type</td></tr>
<tr class="memdesc:aa4f38c39bf08009262a9918dda0363a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduces the value type of a duck-typed iterator. <br /></td></tr>
<tr class="memitem:a5fee47c1d444a07d9826e06bf9ff950c" id="r_a5fee47c1d444a07d9826e06bf9ff950c"><td class="memTemplParams" colspan="2"><a id="a5fee47c1d444a07d9826e06bf9ff950c" name="a5fee47c1d444a07d9826e06bf9ff950c"></a>
template&lt;typename I&gt; </td></tr>
<tr class="memitem:a5fee47c1d444a07d9826e06bf9ff950c template"><td class="memItemLeft">using&#160;</td><td class="memItemRight"><b>jh::concepts::iterator_reference_t</b> = typename detail::iterator_reference_impl&lt;I&gt;::type</td></tr>
<tr class="memdesc:a5fee47c1d444a07d9826e06bf9ff950c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduces the reference type of a duck-typed iterator. <br /></td></tr>
<tr class="memitem:a9fde97daa679bb387820a2cb33d63eff" id="r_a9fde97daa679bb387820a2cb33d63eff"><td class="memTemplParams" colspan="2"><a id="a9fde97daa679bb387820a2cb33d63eff" name="a9fde97daa679bb387820a2cb33d63eff"></a>
template&lt;typename I&gt; </td></tr>
<tr class="memitem:a9fde97daa679bb387820a2cb33d63eff template"><td class="memItemLeft">using&#160;</td><td class="memItemRight"><b>jh::concepts::iterator_rvalue_reference_t</b> = decltype(detail::adl_iter_move(std::declval&lt;I &amp;&gt;()))</td></tr>
<tr class="memdesc:a9fde97daa679bb387820a2cb33d63eff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduces the rvalue reference type of a duck-typed iterator. <br /></td></tr>
<tr class="memitem:a0283e4f328972b869d13761d0424690e" id="r_a0283e4f328972b869d13761d0424690e"><td class="memTemplParams" colspan="2"><a id="a0283e4f328972b869d13761d0424690e" name="a0283e4f328972b869d13761d0424690e"></a>
template&lt;typename I&gt; </td></tr>
<tr class="memitem:a0283e4f328972b869d13761d0424690e template"><td class="memItemLeft">using&#160;</td><td class="memItemRight"><b>jh::concepts::iterator_difference_t</b> = typename detail::iterator_difference_impl&lt;I&gt;::type</td></tr>
<tr class="memdesc:a0283e4f328972b869d13761d0424690e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduces the difference type of a duck-typed iterator. <br /></td></tr>
<tr class="memitem:a6939938cf019276ab13d2d6bf87d2f77" id="r_a6939938cf019276ab13d2d6bf87d2f77"><td class="memTemplParams" colspan="2">template&lt;typename Container&gt; </td></tr>
<tr class="memitem:a6939938cf019276ab13d2d6bf87d2f77 template"><td class="memItemLeft">using&#160;</td><td class="memItemRight"><a class="el" href="namespacejh_1_1concepts.html#a6939938cf019276ab13d2d6bf87d2f77">jh::concepts::iterator_t</a> = typename detail::iterator_resolver&lt;Container&gt;::type</td></tr>
<tr class="memdesc:a6939938cf019276ab13d2d6bf87d2f77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduces the iterator type associated with a container, pointer, or array.  <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Forward declaration and <b>duck-typed</b> iterator concept definitions. </p>
<dl class="section copyright"><dt>Copyright</dt><dd>Copyright 2025 JeongHan-Bae &lt;mastropseudo@gmail.com&gt; <br  />
 Licensed under the Apache License, Version 2.0 (the "License"); <br  />
 you may not use this file except in compliance with the License.<br  />
 You may obtain a copy of the License at<br  />
 <br  />
 <a href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a><br  />
 <br  />
 Unless required by applicable law or agreed to in writing, software<br  />
 distributed under the License is distributed on an "AS IS" BASIS,<br  />
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.<br  />
 See the License for the specific language governing permissions and<br  />
 limitations under the License.<br  />
 <br  />
 Full license: <a href="https://github.com/JeongHan-Bae/JH-Toolkit?tab=Apache-2.0-1-ov-file#readme">GitHub</a></dd></dl>
<dl class="section author"><dt>Author</dt><dd>JeongHan-Bae <a href="#" onclick="location.href='mai'+'lto:'+'mas'+'tr'+'ops'+'eu'+'do@'+'gm'+'ail'+'.c'+'om'; return false;">&lt;mastropseudo@gmail.com&gt;</a> </dd></dl>
<p>This header defines the unified iterator interface and concept suite for the JH container framework. Unlike traditional STL iterators that rely on static typedefs such as <code>iterator_category</code> or <code>difference_type</code>, this design applies <b>behavioral duck-typing</b> — a type is recognized as an iterator if it <em>behaves like one</em>.</p>
<h3>Overview</h3>
<ul>
<li>
Provides a forward declaration of <code><a class="el" href="structjh_1_1iterator.html" title="Forward declaration of jh::iterator&lt;Container&gt;.">jh::iterator&lt;&gt;</a></code> for cross-module compatibility. </li>
<li>
Defines behavior-based iterator concepts (<code>input_iterator</code>, <code>output_iterator</code>, etc.). </li>
<li>
Supports STL iterators, pointers, arrays, and user-defined duck-typed iterators. </li>
</ul>
<h3>Design Principles</h3>
<ol>
<li>
<p class="startli"><b>Behavioral Duck Typing</b> </p>
<p class="interli">Iterators are recognized by behavior — valid expressions like <code>*it</code>, <code>++it</code>, <code>it++</code> — not by typedefs. Any type usable in <code>for(auto&amp;&amp; x : container)</code> qualifies, covering both <code>for(auto&amp; x : ...)</code> and <code>for(auto x : ...)</code>. </p>
<p class="interli"></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>Unified Deduction Model</b> </p>
<p class="interli"><code>iterator_t&lt;Container&gt;</code> resolves iterators by fallback: <code>jh::Container&lt;T&gt;::type</code> → <code>Container::iterator</code> → <code>Container.begin()</code> → <code>T*</code>raw pointer → <code>T[]</code>array decay. </p>
<p class="interli"></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>STL Compatibility</b> </p>
<p class="interli">Works with STL iterators, pointers, arrays, and custom duck-typed types, with no dependency on <code>&lt;iterator&gt;</code> or <code>&lt;ranges&gt;</code>. </p>
<p class="interli"></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>Minimal Dependencies</b> </p>
<p class="interli">Built only on <code>&lt;concepts&gt;</code>, <code>&lt;type_traits&gt;</code>, and <code>&lt;utility&gt;</code>. Traits and categories are deduced via valid expressions instead of <code>std::iterator_traits</code>. </p>
<p class="interli"></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>Range Bridging</b> </p>
<p class="interli">Reuses the same duck-typing model for <code><a class="el" href="conceptjh_1_1concepts_1_1sequence.html" title="Concept that checks whether a type provides at least const (non-destructive) iteration.">jh::concepts::sequence</a></code> and <code>to_range()</code>, enabling STL-style iteration for any non-destructive range-like type. </p>
<p class="endli"></p>
</li>
</ol>
<h3>Concept Summary</h3>
<table class="doxtable">
<tr>
<th>Concept</th><th>Behavior Checked</th><th>Primary Use</th></tr>
<tr>
<td><code>is_iterator</code></td><td>Basic iteration (<code>*it</code>, <code>++it</code>)</td><td>Type detection</td></tr>
<tr>
<td><code>indirectly_readable</code></td><td>Dereference validity and value/reference consistency</td><td>Readable element access</td></tr>
<tr>
<td><code>indirectly_writable&lt;Out, T&gt;</code></td><td>Supports assignment through <code>*it = value</code></td><td>Writable element access</td></tr>
<tr>
<td><code>sentinel_for&lt;S, I&gt;</code></td><td>Equality/inequality comparability between iterator and sentinel</td><td>Range boundary detection</td></tr>
<tr>
<td><code>input_iterator</code></td><td>Readable, comparable iteration; refines <code>is_iterator</code> and <code>indirectly_readable</code></td><td>Single-pass sequential read</td></tr>
<tr>
<td><code>output_iterator</code></td><td>Writable via <code>*it = value</code>; refines <code>is_iterator</code> and <code>indirectly_writable</code></td><td>Single-pass sequential write</td></tr>
<tr>
<td><code>forward_iterator</code></td><td>Refines <code>input_iterator</code>; multi-pass, copyable, and <b>self-sentinel</b> (<code>sentinel_for&lt;I, I&gt;</code>)</td><td>Stable, reentrant traversal</td></tr>
<tr>
<td><code>bidirectional_iterator</code></td><td>Refines <code>forward_iterator</code>; supports reverse movement (<code>&ndash;it</code>, <code>it&ndash;</code>)</td><td>Reversible traversal</td></tr>
<tr>
<td><code>random_access_iterator</code></td><td>Refines <code>bidirectional_iterator</code>; supports arithmetic and indexing (<code>it + n</code>, <code>it[n]</code>)</td><td>Contiguous or offset access</td></tr>
<tr>
<td><code>iterator_t&lt;T&gt;</code></td><td>Unified iterator deduction via specialization, <code>begin()</code>, pointer, or array decay</td><td>Meta-type for resolving iterator type</td></tr>
</table>
<h3>Purpose</h3>
<p>These definitions unify STL and custom iterator semantics under a single duck-typed system. A type is recognized as an iterator by <b>behavioral conformance</b>, not by static signature or inheritance. </p>
<dl class="section version"><dt>Version</dt><dd><pre>1.3.x</pre> </dd></dl>
<dl class="section date"><dt>Date</dt><dd><pre>2025</pre> </dd></dl>
</div></div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
</div> <!-- top -->
<hr class="footer"/>
<div class="footer">
    <img class="footer-logo" src="Ojing.svg" alt="Ojing"/>
    <div class="footer-text">
        JH-Toolkit v1.4.0 · Generated by Doxygen
    </div>
    <div class="footer-note">
        We primarily support embedded documentation views in IDEs (classic CLion).
        To ensure compatibility with embedded rendering, some example code in this
        documentation intentionally contains HTML entities.
        In certain cases, Doxygen does not unescape these entities correctly.
        This is a known limitation and currently has no workaround.
    </div>
</div>
</body>
</html>
