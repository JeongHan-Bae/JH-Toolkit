<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.16.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>JH-Toolkit: jh::flat_multimap&lt; K, V, Alloc &gt; Class Template Reference</title>
<link rel="icon" href="Jindallae.svg" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="Oree.svg"/></td>
  <td id="projectalign">
   <div id="projectname">JH-Toolkit<span id="projectnumber">&#160;v1.4.0</span>
   </div>
   <div id="projectbrief">An engineering-oriented C++20 toolkit with duck-typed concepts, static design, async coroutines, and semantic containers â€” header-only, RTTI-free, and concurrency-friendly.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.16.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('classjh_1_1flat__multimap.html','','classjh_1_1flat__multimap-members'); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">jh::flat_multimap&lt; K, V, Alloc &gt; Class Template Reference<span class="mlabels"><span class="mlabel final">final</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>Flat ordered multimap implemented as a sorted contiguous container.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="">jh/core/flat_multimap.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-types" class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a132494e3292b19451a36ae1c67cadc48" id="r_a132494e3292b19451a36ae1c67cadc48"><td class="memItemLeft"><a id="a132494e3292b19451a36ae1c67cadc48" name="a132494e3292b19451a36ae1c67cadc48"></a>
using&#160;</td><td class="memItemRight"><b>value_type</b> = std::pair&lt;K, V&gt;</td></tr>
<tr class="memdesc:a132494e3292b19451a36ae1c67cadc48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value type stored in the container (<code>std::pair&lt;K, V&gt;</code>). <br /></td></tr>
<tr class="memitem:a7b98f710dd0de2225e5300f71e46eeb2" id="r_a7b98f710dd0de2225e5300f71e46eeb2"><td class="memItemLeft">using&#160;</td><td class="memItemRight"><a class="el" href="#a7b98f710dd0de2225e5300f71e46eeb2">allocator_type</a></td></tr>
<tr class="memdesc:a7b98f710dd0de2225e5300f71e46eeb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocator type rebound to <code><a class="el" href="#a132494e3292b19451a36ae1c67cadc48" title="Value type stored in the container (std::pair&lt;K, V&gt;).">value_type</a></code>.  <br /></td></tr>
<tr class="memitem:a235691aeee2087f70eb63965336bc8b2" id="r_a235691aeee2087f70eb63965336bc8b2"><td class="memItemLeft"><a id="a235691aeee2087f70eb63965336bc8b2" name="a235691aeee2087f70eb63965336bc8b2"></a>
using&#160;</td><td class="memItemRight"><b>container_type</b> = std::vector&lt;<a class="el" href="#a132494e3292b19451a36ae1c67cadc48">value_type</a>, <a class="el" href="#a7b98f710dd0de2225e5300f71e46eeb2">allocator_type</a>&gt;</td></tr>
<tr class="memdesc:a235691aeee2087f70eb63965336bc8b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Underlying contiguous storage type. <br /></td></tr>
<tr class="memitem:a10d35ff643b5e5c8effd3631f298a7ab" id="r_a10d35ff643b5e5c8effd3631f298a7ab"><td class="memItemLeft"><a id="a10d35ff643b5e5c8effd3631f298a7ab" name="a10d35ff643b5e5c8effd3631f298a7ab"></a>
using&#160;</td><td class="memItemRight"><b>iterator</b> = typename container_type::iterator</td></tr>
<tr class="memdesc:a10d35ff643b5e5c8effd3631f298a7ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator type for the container. <br /></td></tr>
<tr class="memitem:ae38a1ac4c399ee3953079821eb6a4ffa" id="r_ae38a1ac4c399ee3953079821eb6a4ffa"><td class="memItemLeft"><a id="ae38a1ac4c399ee3953079821eb6a4ffa" name="ae38a1ac4c399ee3953079821eb6a4ffa"></a>
using&#160;</td><td class="memItemRight"><b>const_iterator</b> = typename container_type::const_iterator</td></tr>
<tr class="memdesc:ae38a1ac4c399ee3953079821eb6a4ffa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const iterator type for the container. <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a95d8392ff0de3c470b06008d9da57100" id="r_a95d8392ff0de3c470b06008d9da57100"><td class="memItemLeft"><a id="a95d8392ff0de3c470b06008d9da57100" name="a95d8392ff0de3c470b06008d9da57100"></a>
&#160;</td><td class="memItemRight"><b>flat_multimap</b> ()=default</td></tr>
<tr class="memdesc:a95d8392ff0de3c470b06008d9da57100"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default-construct an empty multimap. <br /></td></tr>
<tr class="memitem:a360383430476f9489a514f71f256b492" id="r_a360383430476f9489a514f71f256b492"><td class="memItemLeft">&#160;</td><td class="memItemRight"><a class="el" href="#a360383430476f9489a514f71f256b492">flat_multimap</a> (const <a class="el" href="#a235691aeee2087f70eb63965336bc8b2">container_type</a> &amp;cont)</td></tr>
<tr class="memdesc:a360383430476f9489a514f71f256b492"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from an existing container.  <br /></td></tr>
<tr class="memitem:ab48bd708250e6926c45ae9d8641069bf" id="r_ab48bd708250e6926c45ae9d8641069bf"><td class="memItemLeft">&#160;</td><td class="memItemRight"><a class="el" href="#ab48bd708250e6926c45ae9d8641069bf">flat_multimap</a> (<a class="el" href="#a235691aeee2087f70eb63965336bc8b2">container_type</a> &amp;&amp;cont)</td></tr>
<tr class="memdesc:ab48bd708250e6926c45ae9d8641069bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move-construct from an existing container.  <br /></td></tr>
<tr class="memitem:a83c0828b31f281e62083eb5a6a288449" id="r_a83c0828b31f281e62083eb5a6a288449"><td class="memItemLeft">&#160;</td><td class="memItemRight"><a class="el" href="#a83c0828b31f281e62083eb5a6a288449">flat_multimap</a> (const <a class="el" href="#a7b98f710dd0de2225e5300f71e46eeb2">allocator_type</a> &amp;alloc)</td></tr>
<tr class="memdesc:a83c0828b31f281e62083eb5a6a288449"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an empty multimap with a specific allocator.  <br /></td></tr>
<tr class="memitem:affee982a86ee5ded78e2df08e133391a" id="r_affee982a86ee5ded78e2df08e133391a"><td class="memItemLeft">&#160;</td><td class="memItemRight"><a class="el" href="#affee982a86ee5ded78e2df08e133391a">flat_multimap</a> (const <a class="el" href="#a235691aeee2087f70eb63965336bc8b2">container_type</a> &amp;cont, const <a class="el" href="#a7b98f710dd0de2225e5300f71e46eeb2">allocator_type</a> &amp;alloc)</td></tr>
<tr class="memdesc:affee982a86ee5ded78e2df08e133391a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from a container and allocator.  <br /></td></tr>
<tr class="memitem:a7066087901077a8f5455e9eb602794e8" id="r_a7066087901077a8f5455e9eb602794e8"><td class="memItemLeft">&#160;</td><td class="memItemRight"><a class="el" href="#a7066087901077a8f5455e9eb602794e8">flat_multimap</a> (<a class="el" href="#a235691aeee2087f70eb63965336bc8b2">container_type</a> &amp;&amp;cont, const <a class="el" href="#a7b98f710dd0de2225e5300f71e46eeb2">allocator_type</a> &amp;alloc)</td></tr>
<tr class="memdesc:a7066087901077a8f5455e9eb602794e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move-construct from a container using a specific allocator.  <br /></td></tr>
<tr class="memitem:aeadde33caee6593f467135794d61d519" id="r_aeadde33caee6593f467135794d61d519"><td class="memItemLeft"><a id="aeadde33caee6593f467135794d61d519" name="aeadde33caee6593f467135794d61d519"></a>
&#160;</td><td class="memItemRight"><b>flat_multimap</b> (const flat_multimap &amp;)=default</td></tr>
<tr class="memdesc:aeadde33caee6593f467135794d61d519"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy-construct from another <a class="el" href="classjh_1_1flat__multimap.html" title="Flat ordered multimap implemented as a sorted contiguous container.">flat_multimap</a>, using a rebound default allocator. <br /></td></tr>
<tr class="memitem:a1c8ee58ccb4c7711dca460e17b14963d" id="r_a1c8ee58ccb4c7711dca460e17b14963d"><td class="memItemLeft">&#160;</td><td class="memItemRight"><a class="el" href="#a1c8ee58ccb4c7711dca460e17b14963d">flat_multimap</a> (const flat_multimap &amp;other, const <a class="el" href="#a7b98f710dd0de2225e5300f71e46eeb2">allocator_type</a> &amp;alloc)</td></tr>
<tr class="memdesc:a1c8ee58ccb4c7711dca460e17b14963d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy-construct from another <a class="el" href="classjh_1_1flat__multimap.html" title="Flat ordered multimap implemented as a sorted contiguous container.">flat_multimap</a>, using a user-supplied allocator.  <br /></td></tr>
<tr class="memitem:a73e4bd6855370a2de637db1da286f7a1" id="r_a73e4bd6855370a2de637db1da286f7a1"><td class="memItemLeft">&#160;</td><td class="memItemRight"><a class="el" href="#a73e4bd6855370a2de637db1da286f7a1">flat_multimap</a> (flat_multimap &amp;&amp;) noexcept=default</td></tr>
<tr class="memdesc:a73e4bd6855370a2de637db1da286f7a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move-construct from another <a class="el" href="classjh_1_1flat__multimap.html" title="Flat ordered multimap implemented as a sorted contiguous container.">flat_multimap</a>, using a rebound default allocator.  <br /></td></tr>
<tr class="memitem:a0ed2584e9278c8cc6bb728a74ff2e621" id="r_a0ed2584e9278c8cc6bb728a74ff2e621"><td class="memItemLeft">&#160;</td><td class="memItemRight"><a class="el" href="#a0ed2584e9278c8cc6bb728a74ff2e621">flat_multimap</a> (flat_multimap &amp;&amp;other, const <a class="el" href="#a7b98f710dd0de2225e5300f71e46eeb2">allocator_type</a> &amp;alloc)</td></tr>
<tr class="memdesc:a0ed2584e9278c8cc6bb728a74ff2e621"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move-construct from another <a class="el" href="classjh_1_1flat__multimap.html" title="Flat ordered multimap implemented as a sorted contiguous container.">flat_multimap</a>, using a user-supplied allocator.  <br /></td></tr>
<tr class="memitem:a638ab1b06d1f9bcbf27d60a05a579d64" id="r_a638ab1b06d1f9bcbf27d60a05a579d64"><td class="memItemLeft"><a id="a638ab1b06d1f9bcbf27d60a05a579d64" name="a638ab1b06d1f9bcbf27d60a05a579d64"></a>
<a class="el" href="#a95d8392ff0de3c470b06008d9da57100">flat_multimap</a> &amp;&#160;</td><td class="memItemRight"><b>operator=</b> (const <a class="el" href="#a95d8392ff0de3c470b06008d9da57100">flat_multimap</a> &amp;)=default</td></tr>
<tr class="memdesc:a638ab1b06d1f9bcbf27d60a05a579d64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment. <br /></td></tr>
<tr class="memitem:a1b3ee130054f9dabe118441f3de085be" id="r_a1b3ee130054f9dabe118441f3de085be"><td class="memItemLeft"><a id="a1b3ee130054f9dabe118441f3de085be" name="a1b3ee130054f9dabe118441f3de085be"></a>
<a class="el" href="#a95d8392ff0de3c470b06008d9da57100">flat_multimap</a> &amp;&#160;</td><td class="memItemRight"><b>operator=</b> (<a class="el" href="#a95d8392ff0de3c470b06008d9da57100">flat_multimap</a> &amp;&amp;) noexcept=default</td></tr>
<tr class="memdesc:a1b3ee130054f9dabe118441f3de085be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment. <br /></td></tr>
<tr class="memitem:a0c63bb5b1e3bf94da5b2e6a8338ead42" id="r_a0c63bb5b1e3bf94da5b2e6a8338ead42"><td class="memItemLeft">std::pair&lt; <a class="el" href="#a10d35ff643b5e5c8effd3631f298a7ab">iterator</a>, <a class="el" href="#a10d35ff643b5e5c8effd3631f298a7ab">iterator</a> &gt;&#160;</td><td class="memItemRight"><a class="el" href="#a0c63bb5b1e3bf94da5b2e6a8338ead42">equal_range</a> (const K &amp;k)</td></tr>
<tr class="memdesc:a0c63bb5b1e3bf94da5b2e6a8338ead42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the range of elements equivalent to the given key.  <br /></td></tr>
<tr class="memitem:a7db7e920b3e66d60a33b117a4105598f" id="r_a7db7e920b3e66d60a33b117a4105598f"><td class="memItemLeft">std::pair&lt; <a class="el" href="#ae38a1ac4c399ee3953079821eb6a4ffa">const_iterator</a>, <a class="el" href="#ae38a1ac4c399ee3953079821eb6a4ffa">const_iterator</a> &gt;&#160;</td><td class="memItemRight"><a class="el" href="#a7db7e920b3e66d60a33b117a4105598f">equal_range</a> (const K &amp;k) const</td></tr>
<tr class="memdesc:a7db7e920b3e66d60a33b117a4105598f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the range of elements equivalent to the given key (const overload).  <br /></td></tr>
<tr class="memitem:a6e66fdffe8c6324b00f7725feb3b8c1e" id="r_a6e66fdffe8c6324b00f7725feb3b8c1e"><td class="memItemLeft"><a class="el" href="#a10d35ff643b5e5c8effd3631f298a7ab">iterator</a>&#160;</td><td class="memItemRight"><a class="el" href="#a6e66fdffe8c6324b00f7725feb3b8c1e">find</a> (const K &amp;k)</td></tr>
<tr class="memdesc:a6e66fdffe8c6324b00f7725feb3b8c1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Locate the first element with the specified key.  <br /></td></tr>
<tr class="memitem:a83c00fcb5059f0450c758af68bf62aeb" id="r_a83c00fcb5059f0450c758af68bf62aeb"><td class="memItemLeft"><a class="el" href="#ae38a1ac4c399ee3953079821eb6a4ffa">const_iterator</a>&#160;</td><td class="memItemRight"><a class="el" href="#a83c00fcb5059f0450c758af68bf62aeb">find</a> (const K &amp;k) const</td></tr>
<tr class="memdesc:a83c00fcb5059f0450c758af68bf62aeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Locate the first element with the specified key (const overload).  <br /></td></tr>
<tr class="memitem:a373f60bcfc7fbc36605c6c5b3002e432" id="r_a373f60bcfc7fbc36605c6c5b3002e432"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a373f60bcfc7fbc36605c6c5b3002e432 template"><td class="memItemLeft"><a class="el" href="#a10d35ff643b5e5c8effd3631f298a7ab">iterator</a>&#160;</td><td class="memItemRight"><a class="el" href="#a373f60bcfc7fbc36605c6c5b3002e432">emplace</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a373f60bcfc7fbc36605c6c5b3002e432"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a key-value pair by constructing it from arbitrary arguments.  <br /></td></tr>
<tr class="memitem:acdf08f4ee15093453aa3e6a0e5cf78e6" id="r_acdf08f4ee15093453aa3e6a0e5cf78e6"><td class="memTemplParams" colspan="2">template&lt;typename P&gt; </td></tr>
<tr class="memitem:acdf08f4ee15093453aa3e6a0e5cf78e6 template"><td class="memItemLeft"><a class="el" href="#a10d35ff643b5e5c8effd3631f298a7ab">iterator</a>&#160;</td><td class="memItemRight"><a class="el" href="#acdf08f4ee15093453aa3e6a0e5cf78e6">insert</a> (P &amp;&amp;p)</td></tr>
<tr class="memdesc:acdf08f4ee15093453aa3e6a0e5cf78e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a key-value pair into the map.  <br /></td></tr>
<tr class="memitem:a7a704fd9c99d6bed27d9a394a2eed1b1" id="r_a7a704fd9c99d6bed27d9a394a2eed1b1"><td class="memItemLeft"><a class="el" href="#a10d35ff643b5e5c8effd3631f298a7ab">iterator</a>&#160;</td><td class="memItemRight"><a class="el" href="#a7a704fd9c99d6bed27d9a394a2eed1b1">erase</a> (<a class="el" href="#a10d35ff643b5e5c8effd3631f298a7ab">iterator</a> pos)</td></tr>
<tr class="memdesc:a7a704fd9c99d6bed27d9a394a2eed1b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase the element referenced by the given iterator.  <br /></td></tr>
<tr class="memitem:ab7f5b771f23385e1c785b5f61a701076" id="r_ab7f5b771f23385e1c785b5f61a701076"><td class="memItemLeft"><a class="el" href="#a10d35ff643b5e5c8effd3631f298a7ab">iterator</a>&#160;</td><td class="memItemRight"><a class="el" href="#ab7f5b771f23385e1c785b5f61a701076">erase</a> (<a class="el" href="#ae38a1ac4c399ee3953079821eb6a4ffa">const_iterator</a> pos)</td></tr>
<tr class="memdesc:ab7f5b771f23385e1c785b5f61a701076"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase the element referenced by the given const iterator.  <br /></td></tr>
<tr class="memitem:a720d2cc281e5be2e715f0034bb4f31cb" id="r_a720d2cc281e5be2e715f0034bb4f31cb"><td class="memItemLeft"><a class="el" href="#a10d35ff643b5e5c8effd3631f298a7ab">iterator</a>&#160;</td><td class="memItemRight"><a class="el" href="#a720d2cc281e5be2e715f0034bb4f31cb">erase</a> (<a class="el" href="#a10d35ff643b5e5c8effd3631f298a7ab">iterator</a> first, <a class="el" href="#a10d35ff643b5e5c8effd3631f298a7ab">iterator</a> last)</td></tr>
<tr class="memdesc:a720d2cc281e5be2e715f0034bb4f31cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase a range of elements.  <br /></td></tr>
<tr class="memitem:ab3a557ffa282b61950699c602bf02209" id="r_ab3a557ffa282b61950699c602bf02209"><td class="memItemLeft"><a class="el" href="#a10d35ff643b5e5c8effd3631f298a7ab">iterator</a>&#160;</td><td class="memItemRight"><a class="el" href="#ab3a557ffa282b61950699c602bf02209">erase</a> (<a class="el" href="#ae38a1ac4c399ee3953079821eb6a4ffa">const_iterator</a> first, <a class="el" href="#ae38a1ac4c399ee3953079821eb6a4ffa">const_iterator</a> last)</td></tr>
<tr class="memdesc:ab3a557ffa282b61950699c602bf02209"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase a range of elements.  <br /></td></tr>
<tr class="memitem:a23aef5df7ab9a2a7e7b1cf0afbe82a55" id="r_a23aef5df7ab9a2a7e7b1cf0afbe82a55"><td class="memItemLeft">size_t&#160;</td><td class="memItemRight"><a class="el" href="#a23aef5df7ab9a2a7e7b1cf0afbe82a55">erase</a> (const K &amp;k)</td></tr>
<tr class="memdesc:a23aef5df7ab9a2a7e7b1cf0afbe82a55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase all elements whose key compares equal to the given key.  <br /></td></tr>
<tr class="memitem:a06912a6259b418b704445eb0cb18a815" id="r_a06912a6259b418b704445eb0cb18a815"><td class="memItemLeft">std::size_t&#160;</td><td class="memItemRight"><a class="el" href="#a06912a6259b418b704445eb0cb18a815">count</a> (const K &amp;key) const</td></tr>
<tr class="memdesc:a06912a6259b418b704445eb0cb18a815"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the number of elements with the specified key.  <br /></td></tr>
<tr class="memitem:a933fe2cdddfc83f6a321f11e10e7a8e0" id="r_a933fe2cdddfc83f6a321f11e10e7a8e0"><td class="memItemLeft"><a id="a933fe2cdddfc83f6a321f11e10e7a8e0" name="a933fe2cdddfc83f6a321f11e10e7a8e0"></a>
<a class="el" href="#a10d35ff643b5e5c8effd3631f298a7ab">iterator</a>&#160;</td><td class="memItemRight"><b>begin</b> ()</td></tr>
<tr class="memdesc:a933fe2cdddfc83f6a321f11e10e7a8e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return iterator to the first element. <br /></td></tr>
<tr class="memitem:a3738d80c37d04c8f8f6b47877793deb0" id="r_a3738d80c37d04c8f8f6b47877793deb0"><td class="memItemLeft"><a id="a3738d80c37d04c8f8f6b47877793deb0" name="a3738d80c37d04c8f8f6b47877793deb0"></a>
<a class="el" href="#a10d35ff643b5e5c8effd3631f298a7ab">iterator</a>&#160;</td><td class="memItemRight"><b>end</b> ()</td></tr>
<tr class="memdesc:a3738d80c37d04c8f8f6b47877793deb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return iterator past the last element. <br /></td></tr>
<tr class="memitem:ab9611af0c6e8bad6004e617acc9056e2" id="r_ab9611af0c6e8bad6004e617acc9056e2"><td class="memItemLeft"><a id="ab9611af0c6e8bad6004e617acc9056e2" name="ab9611af0c6e8bad6004e617acc9056e2"></a>
<a class="el" href="#ae38a1ac4c399ee3953079821eb6a4ffa">const_iterator</a>&#160;</td><td class="memItemRight"><b>begin</b> () const</td></tr>
<tr class="memdesc:ab9611af0c6e8bad6004e617acc9056e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return const iterator to the first element. <br /></td></tr>
<tr class="memitem:a49a7f4fb2fe19fce11dfa7367d5330ca" id="r_a49a7f4fb2fe19fce11dfa7367d5330ca"><td class="memItemLeft"><a id="a49a7f4fb2fe19fce11dfa7367d5330ca" name="a49a7f4fb2fe19fce11dfa7367d5330ca"></a>
<a class="el" href="#ae38a1ac4c399ee3953079821eb6a4ffa">const_iterator</a>&#160;</td><td class="memItemRight"><b>end</b> () const</td></tr>
<tr class="memdesc:a49a7f4fb2fe19fce11dfa7367d5330ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return const iterator past the last element. <br /></td></tr>
<tr class="memitem:ab4b6767ed07d3aa53d4b6f1ddfb69e1f" id="r_ab4b6767ed07d3aa53d4b6f1ddfb69e1f"><td class="memItemLeft"><a id="ab4b6767ed07d3aa53d4b6f1ddfb69e1f" name="ab4b6767ed07d3aa53d4b6f1ddfb69e1f"></a>
size_t&#160;</td><td class="memItemRight"><b>size</b> () const</td></tr>
<tr class="memdesc:ab4b6767ed07d3aa53d4b6f1ddfb69e1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of elements stored. <br /></td></tr>
<tr class="memitem:ad2e5fb6910f97e161f264ded1beaf86f" id="r_ad2e5fb6910f97e161f264ded1beaf86f"><td class="memItemLeft"><a id="ad2e5fb6910f97e161f264ded1beaf86f" name="ad2e5fb6910f97e161f264ded1beaf86f"></a>
bool&#160;</td><td class="memItemRight"><b>empty</b> () const</td></tr>
<tr class="memdesc:ad2e5fb6910f97e161f264ded1beaf86f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the container is empty. <br /></td></tr>
<tr class="memitem:adbb2d7ff8dd4aed7dd832d338641be0d" id="r_adbb2d7ff8dd4aed7dd832d338641be0d"><td class="memItemLeft">void&#160;</td><td class="memItemRight"><a class="el" href="#adbb2d7ff8dd4aed7dd832d338641be0d">clear</a> () noexcept</td></tr>
<tr class="memdesc:adbb2d7ff8dd4aed7dd832d338641be0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all elements from the container.  <br /></td></tr>
<tr class="memitem:a6292783d1fafadffb134fffa4bced609" id="r_a6292783d1fafadffb134fffa4bced609"><td class="memItemLeft">void&#160;</td><td class="memItemRight"><a class="el" href="#a6292783d1fafadffb134fffa4bced609">reserve</a> (std::size_t n) noexcept(noexcept(storage_.reserve(n)))</td></tr>
<tr class="memdesc:a6292783d1fafadffb134fffa4bced609"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserve space for at least n elements.  <br /></td></tr>
<tr class="memitem:aedc0e4b80e9730a5d500fcc39c3d5fad" id="r_aedc0e4b80e9730a5d500fcc39c3d5fad"><td class="memItemLeft">void&#160;</td><td class="memItemRight"><a class="el" href="#aedc0e4b80e9730a5d500fcc39c3d5fad">shrink_to_fit</a> () noexcept(noexcept(storage_.shrink_to_fit()))</td></tr>
<tr class="memdesc:aedc0e4b80e9730a5d500fcc39c3d5fad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request that the container reduce its capacity.  <br /></td></tr>
<tr class="memitem:aa9da91ada11e6070c8dec2e78c501408" id="r_aa9da91ada11e6070c8dec2e78c501408"><td class="memTemplParams" colspan="2">template&lt;typename It&gt; </td></tr>
<tr class="memitem:aa9da91ada11e6070c8dec2e78c501408 template"><td class="memItemLeft">void&#160;</td><td class="memItemRight"><a class="el" href="#aa9da91ada11e6070c8dec2e78c501408">bulk_insert</a> (It first, It last)</td></tr>
<tr class="memdesc:aa9da91ada11e6070c8dec2e78c501408"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a range of elements and restore ordering.  <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename K, typename V, typename Alloc = std::allocator&lt;std::pair&lt;K, V&gt;&gt;&gt;<br />
requires ( (requires(const K &amp;a, const K &amp;b) { { a &lt; b } -&gt; std::convertible_to&lt;bool&gt;; }) &amp;&amp; <a class="el" href="conceptjh_1_1concepts_1_1is__contiguous__reallocable.html">jh::concepts::is_contiguous_reallocable</a>&lt;K&gt; &amp;&amp; <a class="el" href="conceptjh_1_1concepts_1_1is__contiguous__reallocable.html">jh::concepts::is_contiguous_reallocable</a>&lt;V&gt;)<br />
class jh::flat_multimap&lt; K, V, Alloc &gt;</div><p>Flat ordered multimap implemented as a sorted contiguous container. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K</td><td>Key type. Must be strictly ordered via <code>operator&lt;</code>. </td></tr>
    <tr><td class="paramname">V</td><td>Mapped value type. </td></tr>
    <tr><td class="paramname">Alloc</td><td>Allocator type used for underlying storage.</td></tr>
  </table>
  </dd>
</dl>
<p><code><a class="el" href="classjh_1_1flat__multimap.html" title="Flat ordered multimap implemented as a sorted contiguous container.">flat_multimap</a></code> implements ordered multimap semantics by storing <code>std::pair&lt;K, V&gt;</code> elements in a contiguous container (<code>std::vector</code>) that is kept sorted by key.</p>
<p>Duplicate keys are permitted and are stored contiguously. Lookup and range queries are implemented using binary search (<code>lower_bound</code>, <code>upper_bound</code>), while insertion and erasure are expressed in terms of vector operations. </p>
<p>This container is optimized for: </p><ul>
<li>
range-oriented multimap semantics (<code>equal_range</code>, <code>erase(key)</code>) </li>
<li>
cache-friendly traversal and lookup </li>
<li>
bulk insertion and reconstruction </li>
</ul>
<dl class="section note"><dt>Note</dt><dd>All insertions and erasures may invalidate iterators. <br  />
 Unlike tree-based ordered containers, no node identity or pointer stability is preserved; elements may be relocated freely within the underlying storage. </dd></dl>
</div><a name="doc-typedef-members" id="doc-typedef-members"></a><h2 id="header-doc-typedef-members" class="groupheader">Member Typedef Documentation</h2>
<a id="a7b98f710dd0de2225e5300f71e46eeb2" name="a7b98f710dd0de2225e5300f71e46eeb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b98f710dd0de2225e5300f71e46eeb2">&#9670;&#160;</a></span>allocator_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename Alloc = std::allocator&lt;std::pair&lt;K, V&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classjh_1_1flat__multimap.html">jh::flat_multimap</a>&lt; K, V, Alloc &gt;::allocator_type</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><span class="keyword">typename</span> std::allocator_traits&lt;Alloc&gt;</div>
<div class="line">       ::template rebind_alloc&lt;value_type&gt;</div>
</div><!-- fragment -->
<p>Allocator type rebound to <code><a class="el" href="#a132494e3292b19451a36ae1c67cadc48" title="Value type stored in the container (std::pair&lt;K, V&gt;).">value_type</a></code>. </p>

</div>
</div>
<a name="doc-constructors" id="doc-constructors"></a><h2 id="header-doc-constructors" class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a360383430476f9489a514f71f256b492" name="a360383430476f9489a514f71f256b492"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a360383430476f9489a514f71f256b492">&#9670;&#160;</a></span>flat_multimap() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename Alloc = std::allocator&lt;std::pair&lt;K, V&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classjh_1_1flat__multimap.html">jh::flat_multimap</a>&lt; K, V, Alloc &gt;::flat_multimap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a235691aeee2087f70eb63965336bc8b2">container_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>cont</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel explicit">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct from an existing container. </p>
<p>The contents of <code class="param">cont</code> are copied into the internal storage and stably sorted by key. If the input is already sorted, the cost is near-linear.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cont</td><td>Source container. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab48bd708250e6926c45ae9d8641069bf" name="ab48bd708250e6926c45ae9d8641069bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab48bd708250e6926c45ae9d8641069bf">&#9670;&#160;</a></span>flat_multimap() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename Alloc = std::allocator&lt;std::pair&lt;K, V&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classjh_1_1flat__multimap.html">jh::flat_multimap</a>&lt; K, V, Alloc &gt;::flat_multimap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a235691aeee2087f70eb63965336bc8b2">container_type</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>cont</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel explicit">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move-construct from an existing container. </p>
<p>The container is taken by move and then stably sorted by key.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cont</td><td>Source container. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a83c0828b31f281e62083eb5a6a288449" name="a83c0828b31f281e62083eb5a6a288449"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83c0828b31f281e62083eb5a6a288449">&#9670;&#160;</a></span>flat_multimap() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename Alloc = std::allocator&lt;std::pair&lt;K, V&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classjh_1_1flat__multimap.html">jh::flat_multimap</a>&lt; K, V, Alloc &gt;::flat_multimap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a7b98f710dd0de2225e5300f71e46eeb2">allocator_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>alloc</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel explicit">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an empty multimap with a specific allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alloc</td><td>Allocator used for underlying storage. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="affee982a86ee5ded78e2df08e133391a" name="affee982a86ee5ded78e2df08e133391a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affee982a86ee5ded78e2df08e133391a">&#9670;&#160;</a></span>flat_multimap() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename Alloc = std::allocator&lt;std::pair&lt;K, V&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classjh_1_1flat__multimap.html">jh::flat_multimap</a>&lt; K, V, Alloc &gt;::flat_multimap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a235691aeee2087f70eb63965336bc8b2">container_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>cont</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a7b98f710dd0de2225e5300f71e46eeb2">allocator_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>alloc</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct from a container and allocator. </p>
<p>The container is copied and then stably sorted by key.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cont</td><td>Source container. </td></tr>
    <tr><td class="paramname">alloc</td><td>Allocator to use. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7066087901077a8f5455e9eb602794e8" name="a7066087901077a8f5455e9eb602794e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7066087901077a8f5455e9eb602794e8">&#9670;&#160;</a></span>flat_multimap() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename Alloc = std::allocator&lt;std::pair&lt;K, V&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classjh_1_1flat__multimap.html">jh::flat_multimap</a>&lt; K, V, Alloc &gt;::flat_multimap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a235691aeee2087f70eb63965336bc8b2">container_type</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>cont</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a7b98f710dd0de2225e5300f71e46eeb2">allocator_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>alloc</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move-construct from a container using a specific allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cont</td><td>Source container. </td></tr>
    <tr><td class="paramname">alloc</td><td>Allocator to use. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1c8ee58ccb4c7711dca460e17b14963d" name="a1c8ee58ccb4c7711dca460e17b14963d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c8ee58ccb4c7711dca460e17b14963d">&#9670;&#160;</a></span>flat_multimap() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename Alloc = std::allocator&lt;std::pair&lt;K, V&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classjh_1_1flat__multimap.html">jh::flat_multimap</a>&lt; K, V, Alloc &gt;::flat_multimap </td>
          <td>(</td>
          <td class="paramtype">const flat_multimap&lt; K, V, Alloc &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a7b98f710dd0de2225e5300f71e46eeb2">allocator_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>alloc</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy-construct from another <a class="el" href="classjh_1_1flat__multimap.html" title="Flat ordered multimap implemented as a sorted contiguous container.">flat_multimap</a>, using a user-supplied allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The source tree to copy from. </td></tr>
    <tr><td class="paramname">alloc</td><td>Allocator to be used for the new tree. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a73e4bd6855370a2de637db1da286f7a1" name="a73e4bd6855370a2de637db1da286f7a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73e4bd6855370a2de637db1da286f7a1">&#9670;&#160;</a></span>flat_multimap() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename Alloc = std::allocator&lt;std::pair&lt;K, V&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classjh_1_1flat__multimap.html">jh::flat_multimap</a>&lt; K, V, Alloc &gt;::flat_multimap </td>
          <td>(</td>
          <td class="paramtype">flat_multimap&lt; K, V, Alloc &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel default">default</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move-construct from another <a class="el" href="classjh_1_1flat__multimap.html" title="Flat ordered multimap implemented as a sorted contiguous container.">flat_multimap</a>, using a rebound default allocator. </p>
<dl class="section note"><dt>Note</dt><dd>The source <a class="el" href="classjh_1_1flat__multimap.html" title="Flat ordered multimap implemented as a sorted contiguous container.">flat_multimap</a> is left in a valid but unspecified state afterwards, consistent with standard container move semantics. Callers must clear or overwrite the source if reuse is desired. </dd></dl>

</div>
</div>
<a id="a0ed2584e9278c8cc6bb728a74ff2e621" name="a0ed2584e9278c8cc6bb728a74ff2e621"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ed2584e9278c8cc6bb728a74ff2e621">&#9670;&#160;</a></span>flat_multimap() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename Alloc = std::allocator&lt;std::pair&lt;K, V&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classjh_1_1flat__multimap.html">jh::flat_multimap</a>&lt; K, V, Alloc &gt;::flat_multimap </td>
          <td>(</td>
          <td class="paramtype">flat_multimap&lt; K, V, Alloc &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a7b98f710dd0de2225e5300f71e46eeb2">allocator_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>alloc</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move-construct from another <a class="el" href="classjh_1_1flat__multimap.html" title="Flat ordered multimap implemented as a sorted contiguous container.">flat_multimap</a>, using a user-supplied allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The source <a class="el" href="classjh_1_1flat__multimap.html" title="Flat ordered multimap implemented as a sorted contiguous container.">flat_multimap</a> to move from. </td></tr>
    <tr><td class="paramname">alloc</td><td>Allocator to be used for this <a class="el" href="classjh_1_1flat__multimap.html" title="Flat ordered multimap implemented as a sorted contiguous container.">flat_multimap</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>The source <a class="el" href="classjh_1_1flat__multimap.html" title="Flat ordered multimap implemented as a sorted contiguous container.">flat_multimap</a> is left in a valid but unspecified state afterwards, consistent with standard container move semantics. Callers must clear or overwrite <code class="param">other</code> if reuse is desired. </p>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="aa9da91ada11e6070c8dec2e78c501408" name="aa9da91ada11e6070c8dec2e78c501408"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9da91ada11e6070c8dec2e78c501408">&#9670;&#160;</a></span>bulk_insert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename Alloc = std::allocator&lt;std::pair&lt;K, V&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename It&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classjh_1_1flat__multimap.html">jh::flat_multimap</a>&lt; K, V, Alloc &gt;::bulk_insert </td>
          <td>(</td>
          <td class="paramtype">It</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">It</td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a range of elements and restore ordering. </p>
<p>The elements in the range <span class="tt">[<code>first</code>, <code>last</code>)</span> are appended to the underlying storage, after which the entire container is stably sorted by key.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">It</td><td>Input iterator type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Iterator to the first element. </td></tr>
    <tr><td class="paramname">last</td><td>Iterator past the last element.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>All iterators are invalidated. </dd></dl>

</div>
</div>
<a id="adbb2d7ff8dd4aed7dd832d338641be0d" name="adbb2d7ff8dd4aed7dd832d338641be0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbb2d7ff8dd4aed7dd832d338641be0d">&#9670;&#160;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename Alloc = std::allocator&lt;std::pair&lt;K, V&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classjh_1_1flat__multimap.html">jh::flat_multimap</a>&lt; K, V, Alloc &gt;::clear </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove all elements from the container. </p>
<p>Resets the container to an empty state by clearing the underlying storage. The operation is equivalent to clearing a vector: </p>
<ul>
<li>
The size becomes zero, but the capacity is preserved. </li>
<li>
No reallocation occurs. </li>
<li>
Under polymorphic allocators (PMR), no element-by-element destruction or resource release takes place; the buffer is simply marked empty.  </li>
</ul>
<p>This gives clear an effectively constant-time cost. Unlike pointer-based tree structures such as those used by the standard multimap, there is no need to traverse and destroy individual nodes; the entire storage is discarded in one step. </p>
<dl class="section note"><dt>Note</dt><dd>All iterators are invalidated. </dd></dl>

</div>
</div>
<a id="a06912a6259b418b704445eb0cb18a815" name="a06912a6259b418b704445eb0cb18a815"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06912a6259b418b704445eb0cb18a815">&#9670;&#160;</a></span>count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename Alloc = std::allocator&lt;std::pair&lt;K, V&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classjh_1_1flat__multimap.html">jh::flat_multimap</a>&lt; K, V, Alloc &gt;::count </td>
          <td>(</td>
          <td class="paramtype">const K &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Count the number of elements with the specified key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Key to count. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of elements equivalent to <code>key</code>. </dd></dl>

</div>
</div>
<a id="a373f60bcfc7fbc36605c6c5b3002e432" name="a373f60bcfc7fbc36605c6c5b3002e432"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a373f60bcfc7fbc36605c6c5b3002e432">&#9670;&#160;</a></span>emplace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename Alloc = std::allocator&lt;std::pair&lt;K, V&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a10d35ff643b5e5c8effd3631f298a7ab">iterator</a> <a class="el" href="classjh_1_1flat__multimap.html">jh::flat_multimap</a>&lt; K, V, Alloc &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a key-value pair by constructing it from arbitrary arguments. </p>
<p>This function preserves the usual <code>emplace</code> semantics: the arguments are forwarded into a temporary <code>std::pair&lt;K, V&gt;</code>. The key and mapped value constructed in this temporary object are then forwarded into the internal insertion logic.</p>
<p>If the key already exists in the map, the new element is inserted after all existing equivalents.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>Arguments used to construct a temporary <code>std::pair&lt;K, V&gt;</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the inserted element.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>All iterators are invalidated except the returned one. </dd></dl>

</div>
</div>
<a id="a0c63bb5b1e3bf94da5b2e6a8338ead42" name="a0c63bb5b1e3bf94da5b2e6a8338ead42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c63bb5b1e3bf94da5b2e6a8338ead42">&#9670;&#160;</a></span>equal_range() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename Alloc = std::allocator&lt;std::pair&lt;K, V&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="#a10d35ff643b5e5c8effd3631f298a7ab">iterator</a>, <a class="el" href="#a10d35ff643b5e5c8effd3631f298a7ab">iterator</a> &gt; <a class="el" href="classjh_1_1flat__multimap.html">jh::flat_multimap</a>&lt; K, V, Alloc &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const K &amp;</td>          <td class="paramname"><span class="paramname"><em>k</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the range of elements equivalent to the given key. </p>
<p>Provides the canonical <code>equal_range</code> semantics for associative containers with multiple equivalent keys: </p><ul>
<li>
If an element with the given key exists, returns a pair <code>{lower_bound(key), upper_bound(key)}</code>.  </li>
<li>
If no such element exists, both iterators in the returned pair equal <code><a class="el" href="#a3738d80c37d04c8f8f6b47877793deb0" title="Return iterator past the last element.">end()</a></code>.  </li>
<li>
The returned range is half-open: the first iterator refers to the first element with the key (if present), and the second refers to the element that follows the last element with the key.  </li>
<li>
Does not modify the container. </li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>The key to search for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair of iterators defining the range of matching elements. </dd></dl>

</div>
</div>
<a id="a7db7e920b3e66d60a33b117a4105598f" name="a7db7e920b3e66d60a33b117a4105598f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7db7e920b3e66d60a33b117a4105598f">&#9670;&#160;</a></span>equal_range() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename Alloc = std::allocator&lt;std::pair&lt;K, V&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="#ae38a1ac4c399ee3953079821eb6a4ffa">const_iterator</a>, <a class="el" href="#ae38a1ac4c399ee3953079821eb6a4ffa">const_iterator</a> &gt; <a class="el" href="classjh_1_1flat__multimap.html">jh::flat_multimap</a>&lt; K, V, Alloc &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const K &amp;</td>          <td class="paramname"><span class="paramname"><em>k</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the range of elements equivalent to the given key (const overload). </p>
<p>Behaves identically to the non-const version but returns a pair of <code><a class="el" href="#ae38a1ac4c399ee3953079821eb6a4ffa" title="Const iterator type for the container.">const_iterator</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>The key to search for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair of const iterators defining the range of matching elements. </dd></dl>

</div>
</div>
<a id="a23aef5df7ab9a2a7e7b1cf0afbe82a55" name="a23aef5df7ab9a2a7e7b1cf0afbe82a55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23aef5df7ab9a2a7e7b1cf0afbe82a55">&#9670;&#160;</a></span>erase() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename Alloc = std::allocator&lt;std::pair&lt;K, V&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classjh_1_1flat__multimap.html">jh::flat_multimap</a>&lt; K, V, Alloc &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const K &amp;</td>          <td class="paramname"><span class="paramname"><em>k</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erase all elements whose key compares equal to the given key. </p>
<p>Searches for all elements with key equivalent to <code>k</code> and removes them from the container. </p><ul>
<li>
If at least one matching key exists, all such elements are removed, and the number of removed elements is returned. All iterators are invalidated.  </li>
<li>
If no matching key exists, the container is left unmodified and no iterators are invalidated.  </li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>The key of the element to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements removed. </dd></dl>

</div>
</div>
<a id="ab3a557ffa282b61950699c602bf02209" name="ab3a557ffa282b61950699c602bf02209"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3a557ffa282b61950699c602bf02209">&#9670;&#160;</a></span>erase() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename Alloc = std::allocator&lt;std::pair&lt;K, V&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a10d35ff643b5e5c8effd3631f298a7ab">iterator</a> <a class="el" href="classjh_1_1flat__multimap.html">jh::flat_multimap</a>&lt; K, V, Alloc &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ae38a1ac4c399ee3953079821eb6a4ffa">const_iterator</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ae38a1ac4c399ee3953079821eb6a4ffa">const_iterator</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erase a range of elements. </p>
<p>Removes all elements in the half-open range <span class="tt">[<code>first</code>, <code>last</code>)</span> by delegating to the non-const overload <code><a class="el" href="#a720d2cc281e5be2e715f0034bb4f31cb" title="Erase a range of elements.">erase(iterator, iterator)</a></code>. The behavior, iterator invalidation rules, and returned iterator semantics exactly match those of the non-const overload.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Const iterator referring to the first element to erase. </td></tr>
    <tr><td class="paramname">last</td><td>Const iterator referring to one past the last element to erase.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator referring to the logical successor of the last erased element, or <code><a class="el" href="#a3738d80c37d04c8f8f6b47877793deb0" title="Return iterator past the last element.">end()</a></code> if no such element exists.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>If <code>last</code> precedes <code>first</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab7f5b771f23385e1c785b5f61a701076" name="ab7f5b771f23385e1c785b5f61a701076"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7f5b771f23385e1c785b5f61a701076">&#9670;&#160;</a></span>erase() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename Alloc = std::allocator&lt;std::pair&lt;K, V&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a10d35ff643b5e5c8effd3631f298a7ab">iterator</a> <a class="el" href="classjh_1_1flat__multimap.html">jh::flat_multimap</a>&lt; K, V, Alloc &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ae38a1ac4c399ee3953079821eb6a4ffa">const_iterator</a></td>          <td class="paramname"><span class="paramname"><em>pos</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erase the element referenced by the given const iterator. </p>
<p>Removes the element pointed to by <code>pos</code> by delegating to the non-const overload <code><a class="el" href="#a7a704fd9c99d6bed27d9a394a2eed1b1" title="Erase the element referenced by the given iterator.">erase(iterator)</a></code>. The behavior, iterator invalidation rules, and returned iterator semantics exactly match those of <code><a class="el" href="#a7a704fd9c99d6bed27d9a394a2eed1b1" title="Erase the element referenced by the given iterator.">erase(iterator)</a></code>.</p>
<p>If <code>pos</code> equals <code><a class="el" href="#a3738d80c37d04c8f8f6b47877793deb0" title="Return iterator past the last element.">end()</a></code>, no removal occurs and <code>pos</code> is returned unchanged.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>Const iterator referring to the element to erase. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator as the logical successor of the erased element, or <code><a class="el" href="#a3738d80c37d04c8f8f6b47877793deb0" title="Return iterator past the last element.">end()</a></code> if no successor exists. </dd></dl>

</div>
</div>
<a id="a720d2cc281e5be2e715f0034bb4f31cb" name="a720d2cc281e5be2e715f0034bb4f31cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a720d2cc281e5be2e715f0034bb4f31cb">&#9670;&#160;</a></span>erase() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename Alloc = std::allocator&lt;std::pair&lt;K, V&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a10d35ff643b5e5c8effd3631f298a7ab">iterator</a> <a class="el" href="classjh_1_1flat__multimap.html">jh::flat_multimap</a>&lt; K, V, Alloc &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a10d35ff643b5e5c8effd3631f298a7ab">iterator</a></td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a10d35ff643b5e5c8effd3631f298a7ab">iterator</a></td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erase a range of elements. </p>
<p>Removes all elements in the half-open range <span class="tt">[<code>first</code>, <code>last</code>)</span> and returns an iterator to the logical successor of the last erased element. <br  />
 The range <span class="tt">[<code>first</code>, <code>last</code>)</span> must be valid. In particular, <code>last</code> must not precede <code>first</code>. If this condition is violated, a <code>std::logic_error</code> is thrown. <br  />
 If <code>first == last</code>, no elements are removed and <code>first</code> is returned. <br  />
 If <code>first == <a class="el" href="#a3738d80c37d04c8f8f6b47877793deb0" title="Return iterator past the last element.">end()</a></code>, no removal is performed and <code><a class="el" href="#a3738d80c37d04c8f8f6b47877793deb0" title="Return iterator past the last element.">end()</a></code> is returned. This is only considered valid when <code>last == <a class="el" href="#a3738d80c37d04c8f8f6b47877793deb0" title="Return iterator past the last element.">end()</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Iterator referring to the first element to erase. </td></tr>
    <tr><td class="paramname">last</td><td>Iterator referring to one past the last element to erase.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator referring to the logical successor of the last erased element, or <code><a class="el" href="#a3738d80c37d04c8f8f6b47877793deb0" title="Return iterator past the last element.">end()</a></code> if no such element exists.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>If <code>last</code> precedes <code>first</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7a704fd9c99d6bed27d9a394a2eed1b1" name="a7a704fd9c99d6bed27d9a394a2eed1b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a704fd9c99d6bed27d9a394a2eed1b1">&#9670;&#160;</a></span>erase() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename Alloc = std::allocator&lt;std::pair&lt;K, V&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a10d35ff643b5e5c8effd3631f298a7ab">iterator</a> <a class="el" href="classjh_1_1flat__multimap.html">jh::flat_multimap</a>&lt; K, V, Alloc &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a10d35ff643b5e5c8effd3631f298a7ab">iterator</a></td>          <td class="paramname"><span class="paramname"><em>pos</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erase the element referenced by the given iterator. </p>
<p>Removes the element pointed to by <code>pos</code> and returns an iterator to its logical successor. If <code>pos</code> refers to <code><a class="el" href="#a3738d80c37d04c8f8f6b47877793deb0" title="Return iterator past the last element.">end()</a></code>, no action is performed and <code>pos</code> is returned unchanged.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>Iterator referring to the element to erase. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator as the logical successor of the erased element, or <code><a class="el" href="#a3738d80c37d04c8f8f6b47877793deb0" title="Return iterator past the last element.">end()</a></code> if no successor exists. </dd></dl>

</div>
</div>
<a id="a6e66fdffe8c6324b00f7725feb3b8c1e" name="a6e66fdffe8c6324b00f7725feb3b8c1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e66fdffe8c6324b00f7725feb3b8c1e">&#9670;&#160;</a></span>find() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename Alloc = std::allocator&lt;std::pair&lt;K, V&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a10d35ff643b5e5c8effd3631f298a7ab">iterator</a> <a class="el" href="classjh_1_1flat__multimap.html">jh::flat_multimap</a>&lt; K, V, Alloc &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const K &amp;</td>          <td class="paramname"><span class="paramname"><em>k</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Locate the first element with the specified key. </p>
<p>If multiple elements with the same key exist, returns an iterator to the first such element. If no element exists, returns <code><a class="el" href="#a3738d80c37d04c8f8f6b47877793deb0" title="Return iterator past the last element.">end()</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>The key to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the matching element, or <code><a class="el" href="#a3738d80c37d04c8f8f6b47877793deb0" title="Return iterator past the last element.">end()</a></code> if not found. </dd></dl>

</div>
</div>
<a id="a83c00fcb5059f0450c758af68bf62aeb" name="a83c00fcb5059f0450c758af68bf62aeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83c00fcb5059f0450c758af68bf62aeb">&#9670;&#160;</a></span>find() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename Alloc = std::allocator&lt;std::pair&lt;K, V&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ae38a1ac4c399ee3953079821eb6a4ffa">const_iterator</a> <a class="el" href="classjh_1_1flat__multimap.html">jh::flat_multimap</a>&lt; K, V, Alloc &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const K &amp;</td>          <td class="paramname"><span class="paramname"><em>k</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Locate the first element with the specified key (const overload). </p>
<p>Behaves identically to the non-const version but returns a <code><a class="el" href="#ae38a1ac4c399ee3953079821eb6a4ffa" title="Const iterator type for the container.">const_iterator</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>The key to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Const iterator to the matching element, or <code><a class="el" href="#a3738d80c37d04c8f8f6b47877793deb0" title="Return iterator past the last element.">end()</a></code> if not found. </dd></dl>

</div>
</div>
<a id="acdf08f4ee15093453aa3e6a0e5cf78e6" name="acdf08f4ee15093453aa3e6a0e5cf78e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdf08f4ee15093453aa3e6a0e5cf78e6">&#9670;&#160;</a></span>insert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename Alloc = std::allocator&lt;std::pair&lt;K, V&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a10d35ff643b5e5c8effd3631f298a7ab">iterator</a> <a class="el" href="classjh_1_1flat__multimap.html">jh::flat_multimap</a>&lt; K, V, Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">P &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a key-value pair into the map. </p>
<p>This overload generalizes the traditional <code>std::pair&lt;K, V&gt;</code>-based insertion interface. Instead of requiring a <code><a class="el" href="#a132494e3292b19451a36ae1c67cadc48" title="Value type stored in the container (std::pair&lt;K, V&gt;).">value_type</a></code> object, any 2-element tuple-like value is accepted as long as: </p><ul>
<li>
<code>get&lt;0&gt;(p)</code> has type <code>K</code> (after remove_cvref) </li>
<li>
<code>get&lt;1&gt;(p)</code> has type <code>V</code> (after remove_cvref) </li>
</ul>
<p>This reflects the actual insertion semantics: the container consumes the key and mapped value directly. Any tuple-like pair (including <code>std::pair</code>, <code>std::tuple</code>, proxy references, and structured-binding-compatible types) is therefore permitted if its element types match exactly. <br  />
 If the key already exists in the map, the new element is inserted after all existing equivalents.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">P</td><td>The tuple-like type providing key and mapped value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>A tuple-like value providing key and mapped value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the inserted element.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>All iterators are invalidated except the returned one. </dd></dl>

</div>
</div>
<a id="a6292783d1fafadffb134fffa4bced609" name="a6292783d1fafadffb134fffa4bced609"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6292783d1fafadffb134fffa4bced609">&#9670;&#160;</a></span>reserve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename Alloc = std::allocator&lt;std::pair&lt;K, V&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classjh_1_1flat__multimap.html">jh::flat_multimap</a>&lt; K, V, Alloc &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reserve space for at least n elements. </p>
<p>Requests that the underlying storage grow its capacity to at least <code>n</code> elements. This operation does not change the size of the container or alter any existing node indices. </p>
<p>Calling reserve with a value smaller than the current size is no-op, according to ISO C++11+ standards for standard containers. </p>
<p>With polymorphic allocators (PMR), reserve typically has minimal overhead, as the resource may enlarge the buffer without a full reallocation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Minimum capacity to reserve.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This operation may invalidate all iterators if reallocation occurs. </dd></dl>

</div>
</div>
<a id="aedc0e4b80e9730a5d500fcc39c3d5fad" name="aedc0e4b80e9730a5d500fcc39c3d5fad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedc0e4b80e9730a5d500fcc39c3d5fad">&#9670;&#160;</a></span>shrink_to_fit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename Alloc = std::allocator&lt;std::pair&lt;K, V&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classjh_1_1flat__multimap.html">jh::flat_multimap</a>&lt; K, V, Alloc &gt;::shrink_to_fit </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Request that the container reduce its capacity. </p>
<p>Issues a non-binding request to the underlying storage to reduce its capacity. The behavior matches that of <code>std::vector::shrink_to_fit</code>: </p>
<ul>
<li>
The operation may reduce capacity, but is not required to do so. </li>
<li>
There is no guarantee that the resulting capacity equals the size. </li>
<li>
Under polymorphic allocators (PMR), the resource may keep the existing buffer unchanged. </li>
<li>
Because iterators reference elements by index, not pointer, this operation never invalidates iterators. </li>
</ul>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/jh/core/<a class="el" href="">flat_multimap.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
</div> <!-- top -->
<hr class="footer"/>
<div class="footer">
    <img class="footer-logo" src="Ojing.svg" alt="Ojing"/>
    <div class="footer-text">
        JH-Toolkit v1.4.0 Â· Generated by Doxygen
    </div>
    <div class="footer-note">
        We primarily support embedded documentation views in IDEs (classic CLion).
        To ensure compatibility with embedded rendering, some example code in this
        documentation intentionally contains HTML entities.
        In certain cases, Doxygen does not unescape these entities correctly.
        This is a known limitation and currently has no workaround.
    </div>
</div>
</body>
</html>
