<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.16.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>JH-Toolkit: jh::async Namespace Reference</title>
<link rel="icon" href="Jindallae.svg" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="Oree.svg"/></td>
  <td id="projectalign">
   <div id="projectname">JH-Toolkit<span id="projectnumber">&#160;v1.4.0</span>
   </div>
   <div id="projectbrief">An engineering-oriented C++20 toolkit with duck-typed concepts, static design, async coroutines, and semantic containers — header-only, RTTI-free, and concurrency-friendly.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.16.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('namespacejh_1_1async.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">jh::async Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:resume_5Ft" id="r_resume_5Ft"><td class="memItemLeft">struct &#160;</td><td class="memItemRight"><a class="el" href="structjh_1_1async_1_1resume__t.html">resume_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag type used to trigger a <code>co_await</code> inside a <code>fiber</code>.  <a href="structjh_1_1async_1_1resume__t.html#details">More...</a><br /></td></tr>
<tr class="memitem:fiber" id="r_fiber"><td class="memItemLeft">class &#160;</td><td class="memItemRight"><a class="el" href="classjh_1_1async_1_1fiber.html">fiber</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Coroutine-based fiber providing manual suspension and resumption.  <a href="classjh_1_1async_1_1fiber.html#details">More...</a><br /></td></tr>
<tr class="memitem:generator" id="r_generator"><td class="memItemLeft">class &#160;</td><td class="memItemRight"><a class="el" href="classjh_1_1async_1_1generator.html">generator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Coroutine-based generator supporting both yielding and receiving values.  <a href="classjh_1_1async_1_1generator.html#details">More...</a><br /></td></tr>
<tr class="memitem:generator_5Frange" id="r_generator_5Frange"><td class="memItemLeft">class &#160;</td><td class="memItemRight"><a class="el" href="classjh_1_1async_1_1generator__range.html">generator_range</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A range-like wrapper that enables iteration over a generator factory.  <a href="classjh_1_1async_1_1generator__range.html#details">More...</a><br /></td></tr>
<tr class="memitem:listener" id="r_listener"><td class="memItemLeft">class &#160;</td><td class="memItemRight"><a class="el" href="classjh_1_1async_1_1listener.html">listener</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A one-shot inbox that serves as the <b>fan-in aggregation point</b>.  <a href="classjh_1_1async_1_1listener.html#details">More...</a><br /></td></tr>
<tr class="memitem:slot" id="r_slot"><td class="memItemLeft">class &#160;</td><td class="memItemRight"><a class="el" href="classjh_1_1async_1_1slot.html">slot</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Coroutine representing the user-defined asynchronous state machine.  <a href="classjh_1_1async_1_1slot.html#details">More...</a><br /></td></tr>
<tr class="memitem:slot_5Fhub" id="r_slot_5Fhub"><td class="memItemLeft">class &#160;</td><td class="memItemRight"><a class="el" href="classjh_1_1async_1_1slot__hub.html">slot_hub</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronization domain managing timed mutex acquisition and binding exactly one slot.  <a href="classjh_1_1async_1_1slot__hub.html#details">More...</a><br /></td></tr>
<tr class="memitem:event_5Fsignal" id="r_event_5Fsignal"><td class="memItemLeft">class &#160;</td><td class="memItemRight"><a class="el" href="classjh_1_1async_1_1event__signal.html">event_signal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lightweight push-only event emitter.  <a href="classjh_1_1async_1_1event__signal.html#details">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a91b3ce49da3a766df2cc5820e813a38b" id="r_a91b3ce49da3a766df2cc5820e813a38b"><td class="memTemplParams" colspan="2">template&lt;concepts::sequence SeqType&gt; </td></tr>
<tr class="memitem:a91b3ce49da3a766df2cc5820e813a38b template"><td class="memItemLeft"><a class="el" href="classjh_1_1async_1_1generator.html">generator</a>&lt; <a class="el" href="namespacejh_1_1concepts.html#a288fd2a9c1ffde90dc5ca09475e9cd3f">concepts::sequence_value_t</a>&lt; SeqType &gt; &gt;&#160;</td><td class="memItemRight"><a class="el" href="#a91b3ce49da3a766df2cc5820e813a38b">make_generator</a> (const SeqType &amp;seq)</td></tr>
<tr class="memdesc:a91b3ce49da3a766df2cc5820e813a38b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a duck-typed <b>sequence-like</b> object into a generator.  <br /></td></tr>
<tr class="memitem:aa0b16783c19998c319f4824b3c199275" id="r_aa0b16783c19998c319f4824b3c199275"><td class="memTemplParams" colspan="2">template&lt;std::ranges::range R&gt; </td></tr>
<tr class="memitem:aa0b16783c19998c319f4824b3c199275 template"><td class="memItemLeft"><a class="el" href="classjh_1_1async_1_1generator.html">generator</a>&lt; std::ranges::range_value_t&lt; R &gt; &gt;&#160;</td><td class="memItemRight"><a class="el" href="#aa0b16783c19998c319f4824b3c199275">make_generator</a> (R &amp;&amp;rng)</td></tr>
<tr class="memdesc:aa0b16783c19998c319f4824b3c199275"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a standard <b>range</b> into a generator.  <br /></td></tr>
<tr class="memitem:a17777ad53ec96266cfc3e5d7abe763c8" id="r_a17777ad53ec96266cfc3e5d7abe763c8"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a17777ad53ec96266cfc3e5d7abe763c8 template"><td class="memItemLeft">std::vector&lt; T &gt;&#160;</td><td class="memItemRight"><a class="el" href="#a17777ad53ec96266cfc3e5d7abe763c8">to_vector</a> (<a class="el" href="classjh_1_1async_1_1generator.html">generator</a>&lt; T &gt; &amp;gen)</td></tr>
<tr class="memdesc:a17777ad53ec96266cfc3e5d7abe763c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collects all yielded values from a generator into a <code>std::vector</code>.  <br /></td></tr>
<tr class="memitem:a7ec6dd0540b991ce7452f572b36a89d7" id="r_a7ec6dd0540b991ce7452f572b36a89d7"><td class="memTemplParams" colspan="2">template&lt;typename T, typename U&gt; </td></tr>
<tr class="memitem:a7ec6dd0540b991ce7452f572b36a89d7 template"><td class="memItemLeft">std::vector&lt; T &gt;&#160;</td><td class="memItemRight"><a class="el" href="#a7ec6dd0540b991ce7452f572b36a89d7">to_vector</a> (<a class="el" href="classjh_1_1async_1_1generator.html">generator</a>&lt; T, U &gt; &amp;gen, U input_value)</td></tr>
<tr class="memdesc:a7ec6dd0540b991ce7452f572b36a89d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collects all yielded values into a <code>std::vector</code> using a fixed input value.  <br /></td></tr>
<tr class="memitem:a76f83d068faeb7ceee06981cbd23b65b" id="r_a76f83d068faeb7ceee06981cbd23b65b"><td class="memTemplParams" colspan="2">template&lt;typename T, std::ranges::range R&gt; </td></tr>
<tr class="memitem:a76f83d068faeb7ceee06981cbd23b65b template"><td class="memItemLeft">std::vector&lt; T &gt;&#160;</td><td class="memItemRight"><a class="el" href="#a76f83d068faeb7ceee06981cbd23b65b">to_vector</a> (<a class="el" href="classjh_1_1async_1_1generator.html">generator</a>&lt; T, std::ranges::range_value_t&lt; R &gt; &gt; &amp;gen, const R &amp;inputs)</td></tr>
<tr class="memdesc:a76f83d068faeb7ceee06981cbd23b65b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collects all yielded values into a <code>std::vector</code> using a sequence of input values.  <br /></td></tr>
<tr class="memitem:aa136f6ea5f81fa00a4f1bf070cd8ff97" id="r_aa136f6ea5f81fa00a4f1bf070cd8ff97"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:aa136f6ea5f81fa00a4f1bf070cd8ff97 template"><td class="memItemLeft">std::deque&lt; T &gt;&#160;</td><td class="memItemRight"><a class="el" href="#aa136f6ea5f81fa00a4f1bf070cd8ff97">to_deque</a> (<a class="el" href="classjh_1_1async_1_1generator.html">generator</a>&lt; T &gt; &amp;gen)</td></tr>
<tr class="memdesc:aa136f6ea5f81fa00a4f1bf070cd8ff97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collects all yielded values from a generator into a <code>std::deque</code>.  <br /></td></tr>
<tr class="memitem:a54ce8192c823f8a506e5939445021d5f" id="r_a54ce8192c823f8a506e5939445021d5f"><td class="memTemplParams" colspan="2">template&lt;typename T, typename U&gt; </td></tr>
<tr class="memitem:a54ce8192c823f8a506e5939445021d5f template"><td class="memItemLeft">std::deque&lt; T &gt;&#160;</td><td class="memItemRight"><a class="el" href="#a54ce8192c823f8a506e5939445021d5f">to_deque</a> (<a class="el" href="classjh_1_1async_1_1generator.html">generator</a>&lt; T, U &gt; &amp;gen, U input_value)</td></tr>
<tr class="memdesc:a54ce8192c823f8a506e5939445021d5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collects all yielded values into a <code>std::deque</code> using a fixed input value.  <br /></td></tr>
<tr class="memitem:aa5fdc95beea735b204f8ddf2d0bf6831" id="r_aa5fdc95beea735b204f8ddf2d0bf6831"><td class="memTemplParams" colspan="2">template&lt;typename T, std::ranges::range R&gt; </td></tr>
<tr class="memitem:aa5fdc95beea735b204f8ddf2d0bf6831 template"><td class="memItemLeft">std::deque&lt; T &gt;&#160;</td><td class="memItemRight"><a class="el" href="#aa5fdc95beea735b204f8ddf2d0bf6831">to_deque</a> (<a class="el" href="classjh_1_1async_1_1generator.html">generator</a>&lt; T, std::ranges::range_value_t&lt; R &gt; &gt; &amp;gen, const R &amp;inputs)</td></tr>
<tr class="memdesc:aa5fdc95beea735b204f8ddf2d0bf6831"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collects all yielded values into a <code>std::deque</code> using a sequence of input values.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-var-members" class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a9ec39c76a98583f5d7b2d91b84a0490a" id="r_a9ec39c76a98583f5d7b2d91b84a0490a"><td class="memItemLeft"><a id="a9ec39c76a98583f5d7b2d91b84a0490a" name="a9ec39c76a98583f5d7b2d91b84a0490a"></a>
<a class="el" href="structjh_1_1async_1_1resume__t.html">resume_t</a>&#160;</td><td class="memItemRight"><b>resume_tag</b> {}</td></tr>
<tr class="memdesc:a9ec39c76a98583f5d7b2d91b84a0490a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global constant instance of <code><a class="el" href="structjh_1_1async_1_1resume__t.html" title="Tag type used to trigger a co_await inside a fiber.">resume_t</a></code>. <br /></td></tr>
</table>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="a91b3ce49da3a766df2cc5820e813a38b" name="a91b3ce49da3a766df2cc5820e813a38b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91b3ce49da3a766df2cc5820e813a38b">&#9670;&#160;</a></span>make_generator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;concepts::sequence SeqType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classjh_1_1async_1_1generator.html">generator</a>&lt; <a class="el" href="namespacejh_1_1concepts.html#a288fd2a9c1ffde90dc5ca09475e9cd3f">concepts::sequence_value_t</a>&lt; SeqType &gt; &gt; jh::async::make_generator </td>
          <td>(</td>
          <td class="paramtype">const SeqType &amp;</td>          <td class="paramname"><span class="paramname"><em>seq</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a duck-typed <b>sequence-like</b> object into a generator. </p>
<p>This overload provides the <b>most permissive</b> fallback version of <code><a class="el" href="#a91b3ce49da3a766df2cc5820e813a38b" title="Converts a duck-typed sequence-like object into a generator.">make_generator()</a></code>. It accepts any type that satisfies the minimal <code>jh::sequence</code> concept: having <code>begin()</code> and <code>end()</code> returning readable iterators and supporting <code>!=</code> comparison.</p>
<p>Unlike <code>std::ranges::range</code>, a <code>jh::sequence</code> does <b>not</b> guarantee forwarding or lifetime semantics — only that it can be read immutably. Therefore, this overload uses <b>const reference</b> and avoids forwarding or move-based iteration. </p>
<ul>
<li>
Acts as a <b>duck-typed fallback</b> for legacy or lightweight containers that behave like ranges but are not formally defined as such. </li>
<li>
Preserves the minimal safety invariant: iteration must not mutate <code>seq</code>. </li>
<li>
Ensures compatibility with <b>immutable const iteration</b> even in non-range-conforming types. </li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SeqType</td><td>The input sequence type; must satisfy <code>jh::sequence</code> but not <code>std::ranges::range</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seq</td><td>The sequence-like object to convert (read-only). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A generator yielding elements from <code>seq</code>. </dd></dl>

</div>
</div>
<a id="aa0b16783c19998c319f4824b3c199275" name="aa0b16783c19998c319f4824b3c199275"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0b16783c19998c319f4824b3c199275">&#9670;&#160;</a></span>make_generator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::ranges::range R&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classjh_1_1async_1_1generator.html">generator</a>&lt; std::ranges::range_value_t&lt; R &gt; &gt; jh::async::make_generator </td>
          <td>(</td>
          <td class="paramtype">R &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>rng</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a standard <b>range</b> into a generator. </p>
<p>This overload handles any type satisfying the C++20 <code>std::ranges::range</code> concept. It directly consumes the range by iteration, yielding each element via <code>co_yield</code>.</p>
<p>Because <code>range</code> guarantees valid lifetime and iterator semantics, this overload may safely take the range by <b>universal reference</b> and use <code>std::forward</code> to preserve value category. </p>
<ul>
<li>
Preserves const correctness and supports read-only iteration. </li>
<li>
Allows moving temporary or view-based ranges directly into the coroutine — the generator takes ownership of the iteration sequence. </li>
<li>
Unlike the <code>sequence</code> overload, this version fully supports <b>forwarded rvalue ranges</b> and <b>lazy views</b>. </li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>A valid <code>std::ranges::range</code> type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rng</td><td>The range object or view to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A generator yielding elements from <code>rng</code>. </dd></dl>

</div>
</div>
<a id="aa136f6ea5f81fa00a4f1bf070cd8ff97" name="aa136f6ea5f81fa00a4f1bf070cd8ff97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa136f6ea5f81fa00a4f1bf070cd8ff97">&#9670;&#160;</a></span>to_deque() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::deque&lt; T &gt; jh::async::to_deque </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classjh_1_1async_1_1generator.html">generator</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>gen</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collects all yielded values from a generator into a <code>std::deque</code>. </p>
<p>This overload applies to generators that produce values but do not receive input (<code>U == <a class="el" href="structjh_1_1typed_1_1monostate.html" title="Trivial empty type representing &quot;no value&quot;.">typed::monostate</a></code>). It repeatedly advances the coroutine using <code>next()</code> until completion, appending each yielded element into a <code>std::deque</code>.</p>
<ul>
<li>
Designed for output-only generators. </li>
<li>
Maintains stable iterator validity across insertions. </li>
<li>
Uses the fastest STL <b>segmented linear container</b>, ideal for frequent <code>push_back()</code> operations. </li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The generator's <b>yielded value type</b>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gen</td><td>The generator instance to collect from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>std::deque</code> containing all yielded elements in order. </dd></dl>

</div>
</div>
<a id="aa5fdc95beea735b204f8ddf2d0bf6831" name="aa5fdc95beea735b204f8ddf2d0bf6831"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5fdc95beea735b204f8ddf2d0bf6831">&#9670;&#160;</a></span>to_deque() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::ranges::range R&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::deque&lt; T &gt; jh::async::to_deque </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classjh_1_1async_1_1generator.html">generator</a>&lt; T, std::ranges::range_value_t&lt; R &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>gen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const R &amp;</td>          <td class="paramname"><span class="paramname"><em>inputs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collects all yielded values into a <code>std::deque</code> using a sequence of input values. </p>
<p>This overload supports generators that consume varying inputs. It sequentially sends each element from <code>inputs</code> to the generator via <code>send()</code> and appends the produced values into a deque.</p>
<ul>
<li>
Synchronizes one <b>send()</b> per yielded element. </li>
<li>
Terminates when either the input range or generator is exhausted. </li>
<li>
Deque is optimal for dynamic growth and stable iteration under expansion. </li>
</ul>
<p>The <code>inputs</code> parameter must satisfy <code>std::ranges::range</code>. Nevertheless, any <b>duck-typed sequence</b> that conforms to <code>jh::sequence</code> can be wrapped via <code><a class="el" href="namespacejh.html#a58aa95803840fb814bf92dd4954fb44c" title="Converts a generator factory (lambda or function) into a repeatable range.">jh::to_range()</a></code>: </p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> dq = <a class="code hl_function" href="#aa136f6ea5f81fa00a4f1bf070cd8ff97">jh::async::to_deque</a>(gen, <a class="code hl_function" href="namespacejh.html#a58aa95803840fb814bf92dd4954fb44c">jh::to_range</a>(my_sequence));</div>
<div class="ttc" id="anamespacejh_1_1async_html_aa136f6ea5f81fa00a4f1bf070cd8ff97"><div class="ttname"><a href="#aa136f6ea5f81fa00a4f1bf070cd8ff97">jh::async::to_deque</a></div><div class="ttdeci">std::deque&lt; T &gt; to_deque(generator&lt; T &gt; &amp;gen)</div><div class="ttdoc">Collects all yielded values from a generator into a std::deque.</div><div class="ttdef"><b>Definition</b> generator.h:921</div></div>
<div class="ttc" id="anamespacejh_html_a58aa95803840fb814bf92dd4954fb44c"><div class="ttname"><a href="namespacejh.html#a58aa95803840fb814bf92dd4954fb44c">jh::to_range</a></div><div class="ttdeci">auto to_range(F &amp;&amp;f)</div><div class="ttdoc">Converts a generator factory (lambda or function) into a repeatable range.</div><div class="ttdef"><b>Definition</b> generator.h:1195</div></div>
</div><!-- fragment --><p>This allows compatibility with user-defined containers that are not formally <code>std::ranges::range</code> but still support <code>begin()</code>/<code>end()</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The generator's output type (<code>co_yield</code> value type). </td></tr>
    <tr><td class="paramname">R</td><td>A <code>std::ranges::range</code> of input values sent to the generator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gen</td><td>The generator to consume. </td></tr>
    <tr><td class="paramname">inputs</td><td>The input range providing values for each step. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>std::deque</code> containing all yielded results in sequence. </dd></dl>

</div>
</div>
<a id="a54ce8192c823f8a506e5939445021d5f" name="a54ce8192c823f8a506e5939445021d5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54ce8192c823f8a506e5939445021d5f">&#9670;&#160;</a></span>to_deque() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename U&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::deque&lt; T &gt; jh::async::to_deque </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classjh_1_1async_1_1generator.html">generator</a>&lt; T, U &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>gen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U</td>          <td class="paramname"><span class="paramname"><em>input_value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collects all yielded values into a <code>std::deque</code> using a fixed input value. </p>
<p>This overload supports interactive generators that expect an input type (<code>U != <a class="el" href="structjh_1_1typed_1_1monostate.html" title="Trivial empty type representing &quot;no value&quot;.">typed::monostate</a></code>). It sends the same <b>input value</b> at every coroutine step via <code>send()</code>, pushing each yielded element into a <code>std::deque</code>.</p>
<ul>
<li>
Each iteration performs <code>next()</code> then <code>send(input_value)</code>. </li>
<li>
Efficient for streaming pipelines where append cost must remain amortized O(1). </li>
<li>
Deque preserves all references and pointers to existing elements upon reallocation. </li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The yielded value type. </td></tr>
    <tr><td class="paramname">U</td><td>The input type accepted by the generator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gen</td><td>The generator to consume. </td></tr>
    <tr><td class="paramname">input_value</td><td>The fixed input sent at each step. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>std::deque</code> containing all yielded values. </dd></dl>

</div>
</div>
<a id="a17777ad53ec96266cfc3e5d7abe763c8" name="a17777ad53ec96266cfc3e5d7abe763c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17777ad53ec96266cfc3e5d7abe763c8">&#9670;&#160;</a></span>to_vector() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; jh::async::to_vector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classjh_1_1async_1_1generator.html">generator</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>gen</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collects all yielded values from a generator into a <code>std::vector</code>. </p>
<p>This overload applies to generators that produce values but do not receive input (<code>U == <a class="el" href="structjh_1_1typed_1_1monostate.html" title="Trivial empty type representing &quot;no value&quot;.">typed::monostate</a></code>). It repeatedly advances the coroutine using <code>next()</code> until completion, copying each yielded value into a contiguous <code>std::vector</code>.</p>
<ul>
<li>
Intended for output-only generators. </li>
<li>
Preserves iteration order and copies each yielded element. </li>
<li>
Acts as the most lightweight way to "materialize" a generator sequence. </li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The generator's <b>yielded value type</b>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gen</td><td>The generator instance to collect from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>std::vector</code> containing all yielded elements in order. </dd></dl>

</div>
</div>
<a id="a76f83d068faeb7ceee06981cbd23b65b" name="a76f83d068faeb7ceee06981cbd23b65b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76f83d068faeb7ceee06981cbd23b65b">&#9670;&#160;</a></span>to_vector() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::ranges::range R&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; jh::async::to_vector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classjh_1_1async_1_1generator.html">generator</a>&lt; T, std::ranges::range_value_t&lt; R &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>gen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const R &amp;</td>          <td class="paramname"><span class="paramname"><em>inputs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collects all yielded values into a <code>std::vector</code> using a sequence of input values. </p>
<p>This overload supports generators that consume varying inputs. It sequentially sends each element from <code>inputs</code> to the generator via <code>send()</code> and accumulates the produced values into a vector.</p>
<ul>
<li>
Synchronizes one <b>send()</b> call per yielded element. </li>
<li>
Terminates when either the input range or generator is exhausted. </li>
<li>
Ensures order-preserving correspondence between inputs and outputs. </li>
</ul>
<p>This function formally requires <code>inputs</code> to satisfy <code>std::ranges::range</code>. However, any <b>duck-typed sequence</b> that conforms to the <code>jh::sequence</code> concept can be made compatible by wrapping it with <code><a class="el" href="namespacejh.html#a58aa95803840fb814bf92dd4954fb44c" title="Converts a generator factory (lambda or function) into a repeatable range.">jh::to_range()</a></code>: </p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> vec = <a class="code hl_function" href="#a17777ad53ec96266cfc3e5d7abe763c8">jh::async::to_vector</a>(gen, <a class="code hl_function" href="namespacejh.html#a58aa95803840fb814bf92dd4954fb44c">jh::to_range</a>(my_sequence));</div>
<div class="ttc" id="anamespacejh_1_1async_html_a17777ad53ec96266cfc3e5d7abe763c8"><div class="ttname"><a href="#a17777ad53ec96266cfc3e5d7abe763c8">jh::async::to_vector</a></div><div class="ttdeci">std::vector&lt; T &gt; to_vector(generator&lt; T &gt; &amp;gen)</div><div class="ttdoc">Collects all yielded values from a generator into a std::vector.</div><div class="ttdef"><b>Definition</b> generator.h:804</div></div>
</div><!-- fragment --><p>This design ensures that legacy containers and lightweight sequence-like types remain usable in generator pipelines without requiring full <code><a class="el" href="namespacestd_1_1ranges.html">std::ranges</a></code> compliance. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The generator's output type (<code>co_yield</code> value type). </td></tr>
    <tr><td class="paramname">R</td><td>A <code>std::ranges::range</code> of input values sent to the generator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gen</td><td>The generator to consume. </td></tr>
    <tr><td class="paramname">inputs</td><td>The input range providing values for each step. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>std::vector</code> containing all yielded results in sequence. </dd></dl>

</div>
</div>
<a id="a7ec6dd0540b991ce7452f572b36a89d7" name="a7ec6dd0540b991ce7452f572b36a89d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ec6dd0540b991ce7452f572b36a89d7">&#9670;&#160;</a></span>to_vector() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename U&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; jh::async::to_vector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classjh_1_1async_1_1generator.html">generator</a>&lt; T, U &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>gen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U</td>          <td class="paramname"><span class="paramname"><em>input_value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collects all yielded values into a <code>std::vector</code> using a fixed input value. </p>
<p>This overload supports interactive generators that expect an input type (<code>U != <a class="el" href="structjh_1_1typed_1_1monostate.html" title="Trivial empty type representing &quot;no value&quot;.">typed::monostate</a></code>). It sends the same <b>input value</b> at every coroutine step via <code>send()</code>, producing a deterministic output sequence.</p>
<ul>
<li>
Each iteration performs <code>next()</code> then <code>send(input_value)</code>. </li>
<li>
Useful for constant-parameter simulations or iterative transforms. </li>
<li>
If the generator terminates early, iteration stops gracefully. </li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The yielded value type. </td></tr>
    <tr><td class="paramname">U</td><td>The input type accepted by the generator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gen</td><td>The generator to consume. </td></tr>
    <tr><td class="paramname">input_value</td><td>The fixed input sent at each step. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>std::vector</code> containing all yielded values. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
</div> <!-- top -->
<hr class="footer"/>
<div class="footer">
    <img class="footer-logo" src="Ojing.svg" alt="Ojing"/>
    <div class="footer-text">
        JH-Toolkit v1.4.0 · Generated by Doxygen
    </div>
    <div class="footer-note">
        We primarily support embedded documentation views in IDEs (classic CLion).
        To ensure compatibility with embedded rendering, some example code in this
        documentation intentionally contains HTML entities.
        In certain cases, Doxygen does not unescape these entities correctly.
        This is a known limitation and currently has no workaround.
    </div>
</div>
</body>
</html>
