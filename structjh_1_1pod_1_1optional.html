<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.16.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>JH-Toolkit: jh::pod::optional&lt; T &gt; Struct Template Reference</title>
<link rel="icon" href="Jindallae.svg" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="Oree.svg"/></td>
  <td id="projectalign">
   <div id="projectname">JH-Toolkit<span id="projectnumber">&#160;v1.4.0</span>
   </div>
   <div id="projectbrief">An engineering-oriented C++20 toolkit with duck-typed concepts, static design, async coroutines, and semantic containers — header-only, RTTI-free, and concurrency-friendly.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.16.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('structjh_1_1pod_1_1optional.html','','structjh_1_1pod_1_1optional-members'); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">jh::pod::optional&lt; T &gt; Struct Template Reference<span class="mlabels"><span class="mlabel final">final</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>POD-compatible optional wrapper.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="">jh/pods/optional.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-types" class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a456ae4a1b24b12f22c25196ca9abceb6" id="r_a456ae4a1b24b12f22c25196ca9abceb6"><td class="memItemLeft"><a id="a456ae4a1b24b12f22c25196ca9abceb6" name="a456ae4a1b24b12f22c25196ca9abceb6"></a>
using&#160;</td><td class="memItemRight"><b>value_type</b> = T</td></tr>
<tr class="memdesc:a456ae4a1b24b12f22c25196ca9abceb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias of contained type. <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a8604c1f110931a6e36c0ef15b6702aa7" id="r_a8604c1f110931a6e36c0ef15b6702aa7"><td class="memItemLeft"><a id="a8604c1f110931a6e36c0ef15b6702aa7" name="a8604c1f110931a6e36c0ef15b6702aa7"></a>
constexpr&#160;</td><td class="memItemRight"><b>optional</b> () noexcept=default</td></tr>
<tr class="memdesc:a8604c1f110931a6e36c0ef15b6702aa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor (empty state). <br /></td></tr>
<tr class="memitem:aaf3425c02807acb0a00706987391ff62" id="r_aaf3425c02807acb0a00706987391ff62"><td class="memItemLeft">void&#160;</td><td class="memItemRight"><a class="el" href="#aaf3425c02807acb0a00706987391ff62">store</a> (const T &amp;value) noexcept</td></tr>
<tr class="memdesc:aaf3425c02807acb0a00706987391ff62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store a value by copying raw memory.  <br /></td></tr>
<tr class="memitem:ae3c1063b38ee0a5e9d96e295547bf6c2" id="r_ae3c1063b38ee0a5e9d96e295547bf6c2"><td class="memItemLeft"><a id="ae3c1063b38ee0a5e9d96e295547bf6c2" name="ae3c1063b38ee0a5e9d96e295547bf6c2"></a>
void&#160;</td><td class="memItemRight"><b>clear</b> () noexcept</td></tr>
<tr class="memdesc:ae3c1063b38ee0a5e9d96e295547bf6c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the stored value (set to empty). <br /></td></tr>
<tr class="memitem:a82565ee9efa0bdbd6114003b835ad2e8" id="r_a82565ee9efa0bdbd6114003b835ad2e8"><td class="memItemLeft">T *&#160;</td><td class="memItemRight"><a class="el" href="#a82565ee9efa0bdbd6114003b835ad2e8">get</a> () noexcept</td></tr>
<tr class="memdesc:a82565ee9efa0bdbd6114003b835ad2e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get mutable pointer to stored value.  <br /></td></tr>
<tr class="memitem:a2720ddc429fd3f139e98456036bc2210" id="r_a2720ddc429fd3f139e98456036bc2210"><td class="memItemLeft">const T *&#160;</td><td class="memItemRight"><a class="el" href="#a2720ddc429fd3f139e98456036bc2210">get</a> () const noexcept</td></tr>
<tr class="memdesc:a2720ddc429fd3f139e98456036bc2210"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get const pointer to stored value.  <br /></td></tr>
<tr class="memitem:ae4d19b63aed1a1ea6f1e6b126bc8e5be" id="r_ae4d19b63aed1a1ea6f1e6b126bc8e5be"><td class="memItemLeft"><a id="ae4d19b63aed1a1ea6f1e6b126bc8e5be" name="ae4d19b63aed1a1ea6f1e6b126bc8e5be"></a>
bool&#160;</td><td class="memItemRight"><b>has</b> () const noexcept</td></tr>
<tr class="memdesc:ae4d19b63aed1a1ea6f1e6b126bc8e5be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether a value is present. <br /></td></tr>
<tr class="memitem:ad731c45d9573051c881ae0cb3a3c953b" id="r_ad731c45d9573051c881ae0cb3a3c953b"><td class="memItemLeft"><a id="ad731c45d9573051c881ae0cb3a3c953b" name="ad731c45d9573051c881ae0cb3a3c953b"></a>
bool&#160;</td><td class="memItemRight"><b>empty</b> () const noexcept</td></tr>
<tr class="memdesc:ad731c45d9573051c881ae0cb3a3c953b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the optional is empty. <br /></td></tr>
<tr class="memitem:a6b89c1c413a3ce0ada18feb08ee516d2" id="r_a6b89c1c413a3ce0ada18feb08ee516d2"><td class="memItemLeft">T &amp;&#160;</td><td class="memItemRight"><a class="el" href="#a6b89c1c413a3ce0ada18feb08ee516d2">ref</a> () noexcept</td></tr>
<tr class="memdesc:a6b89c1c413a3ce0ada18feb08ee516d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access stored value by reference.  <br /></td></tr>
<tr class="memitem:a5275e0c5f8e3fa209970844d34d92864" id="r_a5275e0c5f8e3fa209970844d34d92864"><td class="memItemLeft">const T &amp;&#160;</td><td class="memItemRight"><a class="el" href="#a5275e0c5f8e3fa209970844d34d92864">ref</a> () const noexcept</td></tr>
<tr class="memdesc:a5275e0c5f8e3fa209970844d34d92864"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access stored value by const reference.  <br /></td></tr>
<tr class="memitem:abf8bcabf44ebd5c62ff3a79edbaaa808" id="r_abf8bcabf44ebd5c62ff3a79edbaaa808"><td class="memItemLeft">T&#160;</td><td class="memItemRight"><a class="el" href="#abf8bcabf44ebd5c62ff3a79edbaaa808">value_or</a> (T fallback) const noexcept</td></tr>
<tr class="memdesc:abf8bcabf44ebd5c62ff3a79edbaaa808"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return stored value or fallback.  <br /></td></tr>
<tr class="memitem:aaa156d91fc860c2d59aed7cdd37150b3" id="r_aaa156d91fc860c2d59aed7cdd37150b3"><td class="memItemLeft">constexpr bool&#160;</td><td class="memItemRight"><a class="el" href="#aaa156d91fc860c2d59aed7cdd37150b3">operator==</a> (const <a class="el" href="#a8604c1f110931a6e36c0ef15b6702aa7">optional</a> &amp;rhs) const noexcept</td></tr>
<tr class="memdesc:aaa156d91fc860c2d59aed7cdd37150b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison with another optional.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-attribs" class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a6e5655184e245af0656e4c769806f742" id="r_a6e5655184e245af0656e4c769806f742"><td class="memItemLeft"><a id="a6e5655184e245af0656e4c769806f742" name="a6e5655184e245af0656e4c769806f742"></a>
std::byte&#160;</td><td class="memItemRight"><b>storage</b> [sizeof(T)]</td></tr>
<tr class="memdesc:a6e5655184e245af0656e4c769806f742"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raw storage; flattens type ABI, never access directly. <br /></td></tr>
<tr class="memitem:a83cbe6dd617d46acf7c5798ab1cb774a" id="r_a83cbe6dd617d46acf7c5798ab1cb774a"><td class="memItemLeft"><a id="a83cbe6dd617d46acf7c5798ab1cb774a" name="a83cbe6dd617d46acf7c5798ab1cb774a"></a>
bool&#160;</td><td class="memItemRight"><b>has_value</b></td></tr>
<tr class="memdesc:a83cbe6dd617d46acf7c5798ab1cb774a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Presence flag (true = has value). <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;cv_free_pod_like T&gt;<br />
struct jh::pod::optional&lt; T &gt;</div><p>POD-compatible optional wrapper. </p>
<p>Stores raw bytes for <code>T</code> and a boolean flag. Provides POD-level semantics similar to <code>std::optional</code>.</p>
<h4>Equality Semantics:</h4>
<ul>
<li>
If one has value and the other not → false </li>
<li>
If both are empty → true (ignores raw storage) </li>
<li>
If both have value → compare storage bytes (<code>memcmp</code>) </li>
</ul>
<h4>Usage Model:</h4>
<ul>
<li>
Use <code>.<a class="el" href="#aaf3425c02807acb0a00706987391ff62" title="Store a value by copying raw memory.">store()</a></code> to assign </li>
<li>
Check <code>.<a class="el" href="#ae4d19b63aed1a1ea6f1e6b126bc8e5be" title="Whether a value is present.">has()</a></code> / <code>.<a class="el" href="#ad731c45d9573051c881ae0cb3a3c953b" title="Whether the optional is empty.">empty()</a></code> before access </li>
<li>
Use <code>.<a class="el" href="#a6b89c1c413a3ce0ada18feb08ee516d2" title="Access stored value by reference.">ref()</a></code> / <code>.<a class="el" href="#a82565ee9efa0bdbd6114003b835ad2e8" title="Get mutable pointer to stored value.">get()</a></code> to access value </li>
<li>
Use <code>.<a class="el" href="#abf8bcabf44ebd5c62ff3a79edbaaa808" title="Return stored value or fallback.">value_or()</a></code> for fallback </li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Element type. Must satisfy <code>pod_like&lt;T&gt;</code> and be <b>free of const/volatile qualifiers</b> (i.e. satisfy <code>cv_free_pod_like&lt;T&gt;</code>). Using a cv-qualified type would make the optional itself non-POD due to loss of trivial assignment and standard layout guarantees. </td></tr>
  </table>
  </dd>
</dl>
</div><a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="a2720ddc429fd3f139e98456036bc2210" name="a2720ddc429fd3f139e98456036bc2210"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2720ddc429fd3f139e98456036bc2210">&#9670;&#160;</a></span>get() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;cv_free_pod_like T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T * <a class="el" href="structjh_1_1pod_1_1optional.html">jh::pod::optional</a>&lt; T &gt;::get </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get const pointer to stored value. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to const <code>T</code>, must check <code>.<a class="el" href="#ae4d19b63aed1a1ea6f1e6b126bc8e5be" title="Whether a value is present.">has()</a></code> before use. </dd></dl>

</div>
</div>
<a id="a82565ee9efa0bdbd6114003b835ad2e8" name="a82565ee9efa0bdbd6114003b835ad2e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82565ee9efa0bdbd6114003b835ad2e8">&#9670;&#160;</a></span>get() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;cv_free_pod_like T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T * <a class="el" href="structjh_1_1pod_1_1optional.html">jh::pod::optional</a>&lt; T &gt;::get </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get mutable pointer to stored value. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to <code>T</code>, must check <code>.<a class="el" href="#ae4d19b63aed1a1ea6f1e6b126bc8e5be" title="Whether a value is present.">has()</a></code> before use. </dd></dl>

</div>
</div>
<a id="aaa156d91fc860c2d59aed7cdd37150b3" name="aaa156d91fc860c2d59aed7cdd37150b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa156d91fc860c2d59aed7cdd37150b3">&#9670;&#160;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;cv_free_pod_like T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structjh_1_1pod_1_1optional.html">jh::pod::optional</a>&lt; T &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a8604c1f110931a6e36c0ef15b6702aa7">optional</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison with another optional. </p>
<p>Semantics are aligned with <code>std::optional</code>: </p><ul>
<li>
If one has a value and the other does not → <code>false</code> </li>
<li>
If both are empty → <code>true</code> </li>
<li>
If both have a value → compare the underlying storage bytes </li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>Other optional to compare with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if both optionals have the same state and (if present) identical raw byte content, <code>false</code> otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This operator does not rely on <code>= default</code>, because the default comparison would also require raw <code>storage</code> equality when <code>has_value == false</code>. That would force meaningless zeroing of storage in <code>.<a class="el" href="#ae3c1063b38ee0a5e9d96e295547bf6c2" title="Clear the stored value (set to empty).">clear()</a></code>. Instead, we define comparison explicitly: empty optionals are always equal regardless of storage content. </dd>
<dd>
Raw comparison is performed with <code>std::memcmp</code>, ensuring POD-level semantics without invoking <code>T::operator==</code>. </dd></dl>

</div>
</div>
<a id="a5275e0c5f8e3fa209970844d34d92864" name="a5275e0c5f8e3fa209970844d34d92864"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5275e0c5f8e3fa209970844d34d92864">&#9670;&#160;</a></span>ref() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;cv_free_pod_like T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T &amp; <a class="el" href="structjh_1_1pod_1_1optional.html">jh::pod::optional</a>&lt; T &gt;::ref </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access stored value by const reference. </p>
<dl class="section return"><dt>Returns</dt><dd>Const reference to <code>T</code>. Undefined if <code>.<a class="el" href="#ae4d19b63aed1a1ea6f1e6b126bc8e5be" title="Whether a value is present.">has()</a> == false</code>. </dd></dl>

</div>
</div>
<a id="a6b89c1c413a3ce0ada18feb08ee516d2" name="a6b89c1c413a3ce0ada18feb08ee516d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b89c1c413a3ce0ada18feb08ee516d2">&#9670;&#160;</a></span>ref() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;cv_free_pod_like T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="structjh_1_1pod_1_1optional.html">jh::pod::optional</a>&lt; T &gt;::ref </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access stored value by reference. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to <code>T</code>. Undefined if <code>.<a class="el" href="#ae4d19b63aed1a1ea6f1e6b126bc8e5be" title="Whether a value is present.">has()</a> == false</code>. </dd></dl>

</div>
</div>
<a id="aaf3425c02807acb0a00706987391ff62" name="aaf3425c02807acb0a00706987391ff62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf3425c02807acb0a00706987391ff62">&#9670;&#160;</a></span>store()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;cv_free_pod_like T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structjh_1_1pod_1_1optional.html">jh::pod::optional</a>&lt; T &gt;::store </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Store a value by copying raw memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Source value to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abf8bcabf44ebd5c62ff3a79edbaaa808" name="abf8bcabf44ebd5c62ff3a79edbaaa808"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf8bcabf44ebd5c62ff3a79edbaaa808">&#9670;&#160;</a></span>value_or()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;cv_free_pod_like T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="structjh_1_1pod_1_1optional.html">jh::pod::optional</a>&lt; T &gt;::value_or </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>fallback</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return stored value or fallback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fallback</td><td>Value to return if empty. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Copy of stored or fallback value. </dd></dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>include/jh/pods/<a class="el" href="">optional.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
</div> <!-- top -->
<hr class="footer"/>
<div class="footer">
    <img class="footer-logo" src="Ojing.svg" alt="Ojing"/>
    <div class="footer-text">
        JH-Toolkit v1.4.0 · Generated by Doxygen
    </div>
    <div class="footer-note">
        We primarily support embedded documentation views in IDEs (classic CLion).
        To ensure compatibility with embedded rendering, some example code in this
        documentation intentionally contains HTML entities.
        In certain cases, Doxygen does not unescape these entities correctly.
        This is a known limitation and currently has no workaround.
    </div>
</div>
</body>
</html>
