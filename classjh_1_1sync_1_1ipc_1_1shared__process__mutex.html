<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.16.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>JH-Toolkit: jh::sync::ipc::shared_process_mutex&lt; S, HighPriv &gt; Class Template Reference</title>
<link rel="icon" href="Jindallae.svg" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="Oree.svg"/></td>
  <td id="projectalign">
   <div id="projectname">JH-Toolkit<span id="projectnumber">&#160;v1.4.0</span>
   </div>
   <div id="projectbrief">An engineering-oriented C++20 toolkit with duck-typed concepts, static design, async coroutines, and semantic containers — header-only, RTTI-free, and concurrency-friendly.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.16.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('classjh_1_1sync_1_1ipc_1_1shared__process__mutex.html','','classjh_1_1sync_1_1ipc_1_1shared__process__mutex-members'); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">jh::sync::ipc::shared_process_mutex&lt; S, HighPriv &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Cross-process shared/exclusive timed mutex with optional upgrade support.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="">jh/synchronous/ipc/shared_process_mutex.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6a7ef385edd456e8bae744dfd3494bba" id="r_a6a7ef385edd456e8bae744dfd3494bba"><td class="memItemLeft"><a id="a6a7ef385edd456e8bae744dfd3494bba" name="a6a7ef385edd456e8bae744dfd3494bba"></a>
&#160;</td><td class="memItemRight"><b>shared_process_mutex</b> (const shared_process_mutex &amp;)=delete</td></tr>
<tr class="memitem:ab7d401d618f73f32b27340c1f32d31e9" id="r_ab7d401d618f73f32b27340c1f32d31e9"><td class="memItemLeft"><a id="ab7d401d618f73f32b27340c1f32d31e9" name="ab7d401d618f73f32b27340c1f32d31e9"></a>
shared_process_mutex &amp;&#160;</td><td class="memItemRight"><b>operator=</b> (const shared_process_mutex &amp;)=delete</td></tr>
<tr class="memitem:a3f14a19895988e3be4ee2cdbe571157b" id="r_a3f14a19895988e3be4ee2cdbe571157b"><td class="memItemLeft">void&#160;</td><td class="memItemRight"><a class="el" href="#a3f14a19895988e3be4ee2cdbe571157b">lock</a> ()</td></tr>
<tr class="memdesc:a3f14a19895988e3be4ee2cdbe571157b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquire exclusive access (blocking).  <br /></td></tr>
<tr class="memitem:a8b298098690dc43a6d39089b5f6634e7" id="r_a8b298098690dc43a6d39089b5f6634e7"><td class="memItemLeft">bool&#160;</td><td class="memItemRight"><a class="el" href="#a8b298098690dc43a6d39089b5f6634e7">try_lock</a> ()</td></tr>
<tr class="memdesc:a8b298098690dc43a6d39089b5f6634e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to acquire exclusive access immediately.  <br /></td></tr>
<tr class="memitem:ade50fe5445ff86679dfefa3821fed29a" id="r_ade50fe5445ff86679dfefa3821fed29a"><td class="memTemplParams" colspan="2"><a id="ade50fe5445ff86679dfefa3821fed29a" name="ade50fe5445ff86679dfefa3821fed29a"></a>
template&lt;typename Rep, typename Period&gt; </td></tr>
<tr class="memitem:ade50fe5445ff86679dfefa3821fed29a template"><td class="memItemLeft">bool&#160;</td><td class="memItemRight"><b>try_lock_for</b> (const std::chrono::duration&lt; Rep, Period &gt; &amp;d)</td></tr>
<tr class="memdesc:ade50fe5445ff86679dfefa3821fed29a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to acquire exclusive access for a limited duration. <br /></td></tr>
<tr class="memitem:a18bf8d5ccd30ece1cbcbbe35405ce327" id="r_a18bf8d5ccd30ece1cbcbbe35405ce327"><td class="memTemplParams" colspan="2"><a id="a18bf8d5ccd30ece1cbcbbe35405ce327" name="a18bf8d5ccd30ece1cbcbbe35405ce327"></a>
template&lt;typename Clock, typename Duration&gt; </td></tr>
<tr class="memitem:a18bf8d5ccd30ece1cbcbbe35405ce327 template"><td class="memItemLeft">bool&#160;</td><td class="memItemRight"><b>try_lock_until</b> (const std::chrono::time_point&lt; Clock, Duration &gt; &amp;tp)</td></tr>
<tr class="memdesc:a18bf8d5ccd30ece1cbcbbe35405ce327"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to acquire exclusive access until a specific time point. <br /></td></tr>
<tr class="memitem:ac61920cbbc7492f8927600229025aada" id="r_ac61920cbbc7492f8927600229025aada"><td class="memItemLeft">void&#160;</td><td class="memItemRight"><a class="el" href="#ac61920cbbc7492f8927600229025aada">unlock</a> ()</td></tr>
<tr class="memdesc:ac61920cbbc7492f8927600229025aada"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release exclusive access.  <br /></td></tr>
<tr class="memitem:a234d89d3028359bd53731ba926994259" id="r_a234d89d3028359bd53731ba926994259"><td class="memItemLeft">void&#160;</td><td class="memItemRight"><a class="el" href="#a234d89d3028359bd53731ba926994259">lock_shared</a> ()</td></tr>
<tr class="memdesc:a234d89d3028359bd53731ba926994259"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquire shared access.  <br /></td></tr>
<tr class="memitem:a39211244e7167e3312846d48367e6dd7" id="r_a39211244e7167e3312846d48367e6dd7"><td class="memItemLeft"><a id="a39211244e7167e3312846d48367e6dd7" name="a39211244e7167e3312846d48367e6dd7"></a>
bool&#160;</td><td class="memItemRight"><b>try_lock_shared</b> ()</td></tr>
<tr class="memdesc:a39211244e7167e3312846d48367e6dd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to acquire shared access immediately. <br /></td></tr>
<tr class="memitem:aa73867d50e57e34a4554acb42131f31d" id="r_aa73867d50e57e34a4554acb42131f31d"><td class="memTemplParams" colspan="2"><a id="aa73867d50e57e34a4554acb42131f31d" name="aa73867d50e57e34a4554acb42131f31d"></a>
template&lt;typename Rep, typename Period&gt; </td></tr>
<tr class="memitem:aa73867d50e57e34a4554acb42131f31d template"><td class="memItemLeft">bool&#160;</td><td class="memItemRight"><b>try_lock_shared_for</b> (const std::chrono::duration&lt; Rep, Period &gt; &amp;d)</td></tr>
<tr class="memdesc:aa73867d50e57e34a4554acb42131f31d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to acquire shared access for a limited duration. <br /></td></tr>
<tr class="memitem:a11f7fb02d1d487837050280b50fb1688" id="r_a11f7fb02d1d487837050280b50fb1688"><td class="memTemplParams" colspan="2"><a id="a11f7fb02d1d487837050280b50fb1688" name="a11f7fb02d1d487837050280b50fb1688"></a>
template&lt;typename Clock, typename Duration&gt; </td></tr>
<tr class="memitem:a11f7fb02d1d487837050280b50fb1688 template"><td class="memItemLeft">bool&#160;</td><td class="memItemRight"><b>try_lock_shared_until</b> (const std::chrono::time_point&lt; Clock, Duration &gt; &amp;tp)</td></tr>
<tr class="memdesc:a11f7fb02d1d487837050280b50fb1688"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to acquire shared access until a time point. <br /></td></tr>
<tr class="memitem:aad33e8159d07af32aab49a432ef22ba4" id="r_aad33e8159d07af32aab49a432ef22ba4"><td class="memItemLeft">void&#160;</td><td class="memItemRight"><a class="el" href="#aad33e8159d07af32aab49a432ef22ba4">unlock_shared</a> ()</td></tr>
<tr class="memdesc:aad33e8159d07af32aab49a432ef22ba4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release shared access.  <br /></td></tr>
<tr class="memitem:abbe07f498b1ea01f493e526ffe9c3b69" id="r_abbe07f498b1ea01f493e526ffe9c3b69"><td class="memItemLeft">void&#160;</td><td class="memItemRight"><a class="el" href="#abbe07f498b1ea01f493e526ffe9c3b69">upgrade_lock</a> ()</td></tr>
<tr class="memdesc:abbe07f498b1ea01f493e526ffe9c3b69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Upgrade from shared to exclusive mode (system-wide).  <br /></td></tr>
<tr class="memitem:acb9db2c0fadf9cb60829529c3bf8264c" id="r_acb9db2c0fadf9cb60829529c3bf8264c"><td class="memItemLeft"><a id="acb9db2c0fadf9cb60829529c3bf8264c" name="acb9db2c0fadf9cb60829529c3bf8264c"></a>
void&#160;</td><td class="memItemRight"><b>upgrade_lock</b> ()=delete</td></tr>
<tr class="memdesc:acb9db2c0fadf9cb60829529c3bf8264c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disabled for non-privileged variants. <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-static-methods" class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a11c726724cfdbc653ba60bc5c5692bb4" id="r_a11c726724cfdbc653ba60bc5c5692bb4"><td class="memItemLeft">static shared_process_mutex &amp;&#160;</td><td class="memItemRight"><a class="el" href="#a11c726724cfdbc653ba60bc5c5692bb4">instance</a> ()</td></tr>
<tr class="memdesc:a11c726724cfdbc653ba60bc5c5692bb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the process-wide singleton instance of this mutex.  <br /></td></tr>
<tr class="memitem:ae7a4668873f4deb5d13e9783774fb533" id="r_ae7a4668873f4deb5d13e9783774fb533"><td class="memItemLeft">static void&#160;</td><td class="memItemRight"><a class="el" href="#ae7a4668873f4deb5d13e9783774fb533">unlink</a> ()</td></tr>
<tr class="memdesc:ae7a4668873f4deb5d13e9783774fb533"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all associated process primitives.  <br /></td></tr>
<tr class="memitem:a09bc18652de9f560e048b43f8c19927a" id="r_a09bc18652de9f560e048b43f8c19927a"><td class="memItemLeft"><a id="a09bc18652de9f560e048b43f8c19927a" name="a09bc18652de9f560e048b43f8c19927a"></a>
static void&#160;</td><td class="memItemRight"><b>unlink</b> ()=delete</td></tr>
<tr class="memdesc:a09bc18652de9f560e048b43f8c19927a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disabled for non-privileged variants. <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;jh::meta::TStr S, bool HighPriv&gt;<br />
requires (<a class="el" href="namespacejh_1_1sync_1_1ipc_1_1limits.html#ac9d6d7cefc59eb289082b37bca1603b9">limits::valid_object_name</a>&lt;S, limits::max_name_length - 8&gt;())<br />
class jh::sync::ipc::shared_process_mutex&lt; S, HighPriv &gt;</div><p>Cross-process shared/exclusive timed mutex with optional upgrade support. </p>
<h4>Overview</h4>
<p><code><a class="el" href="classjh_1_1sync_1_1ipc_1_1shared__process__mutex.html" title="Cross-process shared/exclusive timed mutex with optional upgrade support.">jh::sync::ipc::shared_process_mutex</a></code> is a process-visible synchronization primitive providing shared, exclusive, and (optionally) upgradeable locking semantics, similar to <code>std::shared_timed_mutex</code> but implemented from process-level IPC primitives. </p>
<h4>Composition</h4>
<ul>
<li>
<code><a class="el" href="classjh_1_1sync_1_1ipc_1_1process__mutex.html" title="Cross-platform named process-wide mutex primitive.">process_mutex</a>&lt;S + ".exc"&gt;</code> — exclusive access control. </li>
<li>
<code><a class="el" href="classjh_1_1sync_1_1ipc_1_1process__cond__var.html" title="Cross-process condition variable primitive (POSIX / Win32).">process_cond_var</a>&lt;S + ".cond"&gt;</code> — wake writers or upgraders when readers exit. </li>
<li>
<code><a class="el" href="classjh_1_1sync_1_1ipc_1_1process__counter.html" title="Cross-process integer counter stored in shared memory (POSIX / Win32).">process_counter</a>&lt;S + ".cnt"&gt;</code> — global reader count. </li>
<li>
<code><a class="el" href="classjh_1_1sync_1_1ipc_1_1process__mutex.html" title="Cross-platform named process-wide mutex primitive.">process_mutex</a>&lt;S + ".pri"&gt;</code> — preemption lock for upgrade continuity. </li>
</ul>
<h4>Behavior</h4>
<ul>
<li>
Implements all <code>std::shared_timed_mutex</code> interfaces (<code>lock</code>, <code>try_lock*</code>, <code>lock_shared</code>, <code>try_lock_shared*</code>). </li>
<li>
The <b>HighPriv</b> variant adds <code><a class="el" href="#abbe07f498b1ea01f493e526ffe9c3b69" title="Upgrade from shared to exclusive mode (system-wide).">upgrade_lock()</a></code> and <code><a class="el" href="#ae7a4668873f4deb5d13e9783774fb533" title="Remove all associated process primitives.">unlink()</a></code>. </li>
<li>
Thread- and coroutine-local reentrancy is supported; repeated calls to <code><a class="el" href="#a3f14a19895988e3be4ee2cdbe571157b" title="Acquire exclusive access (blocking).">lock()</a></code> or <code><a class="el" href="#a234d89d3028359bd53731ba926994259" title="Acquire shared access.">lock_shared()</a></code> in the same execution context are idempotent. </li>
<li>
Lock ownership is tracked via <code>thread_local</code> flags; release operations are similarly idempotent within the same participant. </li>
</ul>
<h4>Upgrade semantics</h4>
<ul>
<li>
Upgrade is <b>continuous and exclusive</b>: once started, it cannot yield or be interrupted. </li>
<li>
Only one upgrader may exist system-wide. Concurrent upgrades are <b>undefined behavior (UB)</b>. </li>
<li>
During upgrade, the participant seizes <code>.pri</code> to preempt writers and preserve transactional consistency. </li>
<li>
If two participants may attempt upgrade, it is recommended to protect the upgrade path with an additional mutex and use <code><a class="el" href="#a8b298098690dc43a6d39089b5f6634e7" title="Try to acquire exclusive access immediately.">try_lock()</a></code> to ensure a single active upgrader. </li>
</ul>
<h4>Design notes</h4>
<ul>
<li>
This class models the behavior of <code>std::shared_timed_mutex</code>, but is implemented from process-wide IPC primitives. </li>
<li>
It is an <b>engineering-level primitive</b>: deterministic, portable, and designed for correctness rather than fairness. </li>
<li>
Within a single thread or coroutine context, (a coroutine and the thread it is executing on, that is, the first thread to attempt to resume it, are considered the same participant), all lock operations are <b>idempotent</b>. Repeated acquisitions or releases are safe and treated as no-ops. This enables reentrant patterns for coroutine and task frameworks. </li>
<li>
Across threads or processes, reentrancy is not propagated — holding a lock in one thread does not imply ownership in another. </li>
<li>
<code>notify_one()</code> is used intentionally: only writers wait on the condition variable, and at most one writer should proceed when readers complete. </li>
<li>
Fully compatible with RAII wrappers (<code>std::shared_lock</code>, <code>std::unique_lock</code>, <code>std::lock_guard</code>). </li>
</ul>
<h4>Privilege and cleanup</h4>
<ul>
<li>
<b>Normal variant</b> (<code>HighPriv == false</code>): shared/exclusive locks only. </li>
<li>
<b>High-privileged variant</b> (<code>HighPriv == true</code>): adds upgrade support and <code><a class="el" href="#ae7a4668873f4deb5d13e9783774fb533" title="Remove all associated process primitives.">unlink()</a></code>. </li>
<li>
Unlink removes all associated IPC objects: <code>.exc</code>, <code>.cond</code>, <code>.cnt</code>, and <code>.pri</code>. </li>
</ul>
</div><a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="a11c726724cfdbc653ba60bc5c5692bb4" name="a11c726724cfdbc653ba60bc5c5692bb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11c726724cfdbc653ba60bc5c5692bb4">&#9670;&#160;</a></span>instance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;jh::meta::TStr S, bool HighPriv&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">shared_process_mutex &amp; <a class="el" href="classjh_1_1sync_1_1ipc_1_1shared__process__mutex.html">jh::sync::ipc::shared_process_mutex</a>&lt; S, HighPriv &gt;::instance </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access the process-wide singleton instance of this mutex. </p>
<dl class="section return"><dt>Returns</dt><dd>A reference to the global synchronization object. </dd></dl>

</div>
</div>
<a id="a3f14a19895988e3be4ee2cdbe571157b" name="a3f14a19895988e3be4ee2cdbe571157b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f14a19895988e3be4ee2cdbe571157b">&#9670;&#160;</a></span>lock()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;jh::meta::TStr S, bool HighPriv&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classjh_1_1sync_1_1ipc_1_1shared__process__mutex.html">jh::sync::ipc::shared_process_mutex</a>&lt; S, HighPriv &gt;::lock </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Acquire exclusive access (blocking). </p>
<p>Sequence: </p><ol>
<li>
Acquire <code>.exc</code> to block new readers. </li>
<li>
Wait until <code>readers_ == 0</code>. </li>
<li>
Acquire <code>.pri</code> to ensure no upgrader interferes. </li>
</ol>
<p>The participant then has full exclusive access across all processes. </p>

</div>
</div>
<a id="a234d89d3028359bd53731ba926994259" name="a234d89d3028359bd53731ba926994259"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a234d89d3028359bd53731ba926994259">&#9670;&#160;</a></span>lock_shared()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;jh::meta::TStr S, bool HighPriv&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classjh_1_1sync_1_1ipc_1_1shared__process__mutex.html">jh::sync::ipc::shared_process_mutex</a>&lt; S, HighPriv &gt;::lock_shared </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Acquire shared access. </p>
<p>Locks <code>.exc</code> briefly to safely increment <code>readers_</code>, ensuring no writer is entering concurrently. </p>

</div>
</div>
<a id="a8b298098690dc43a6d39089b5f6634e7" name="a8b298098690dc43a6d39089b5f6634e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b298098690dc43a6d39089b5f6634e7">&#9670;&#160;</a></span>try_lock()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;jh::meta::TStr S, bool HighPriv&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classjh_1_1sync_1_1ipc_1_1shared__process__mutex.html">jh::sync::ipc::shared_process_mutex</a>&lt; S, HighPriv &gt;::try_lock </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Try to acquire exclusive access immediately. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if successful, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ae7a4668873f4deb5d13e9783774fb533" name="ae7a4668873f4deb5d13e9783774fb533"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7a4668873f4deb5d13e9783774fb533">&#9670;&#160;</a></span>unlink()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;jh::meta::TStr S, bool HighPriv&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classjh_1_1sync_1_1ipc_1_1shared__process__mutex.html">jh::sync::ipc::shared_process_mutex</a>&lt; S, HighPriv &gt;::unlink </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove all associated process primitives. </p>
<p>Removes the following objects from the OS namespace: </p><ul>
<li>
<code><a class="el" href="classjh_1_1sync_1_1ipc_1_1process__mutex.html" title="Cross-platform named process-wide mutex primitive.">process_mutex</a>&lt;S + ".exc"&gt;</code> </li>
<li>
<code><a class="el" href="classjh_1_1sync_1_1ipc_1_1process__cond__var.html" title="Cross-process condition variable primitive (POSIX / Win32).">process_cond_var</a>&lt;S + ".cond"&gt;</code> </li>
<li>
<code><a class="el" href="classjh_1_1sync_1_1ipc_1_1process__counter.html" title="Cross-process integer counter stored in shared memory (POSIX / Win32).">process_counter</a>&lt;S + ".cnt"&gt;</code> </li>
</ul>

</div>
</div>
<a id="ac61920cbbc7492f8927600229025aada" name="ac61920cbbc7492f8927600229025aada"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac61920cbbc7492f8927600229025aada">&#9670;&#160;</a></span>unlock()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;jh::meta::TStr S, bool HighPriv&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classjh_1_1sync_1_1ipc_1_1shared__process__mutex.html">jh::sync::ipc::shared_process_mutex</a>&lt; S, HighPriv &gt;::unlock </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Release exclusive access. </p>
<p>Steps: </p><ol>
<li>
Release <code>.pri</code>. </li>
<li>
Signal <code>.cond</code> to wake blocked writers or upgraders. </li>
<li>
If the lock was not obtained via upgrade preemption, release <code>.exc</code>. </li>
</ol>

</div>
</div>
<a id="aad33e8159d07af32aab49a432ef22ba4" name="aad33e8159d07af32aab49a432ef22ba4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad33e8159d07af32aab49a432ef22ba4">&#9670;&#160;</a></span>unlock_shared()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;jh::meta::TStr S, bool HighPriv&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classjh_1_1sync_1_1ipc_1_1shared__process__mutex.html">jh::sync::ipc::shared_process_mutex</a>&lt; S, HighPriv &gt;::unlock_shared </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Release shared access. </p>
<p>Decrements <code>readers_</code>; if this was the last reader (<span class="tt">old == 1</span>), signals <code>.cond</code> to wake one waiting writer or upgrader. </p>

</div>
</div>
<a id="abbe07f498b1ea01f493e526ffe9c3b69" name="abbe07f498b1ea01f493e526ffe9c3b69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbe07f498b1ea01f493e526ffe9c3b69">&#9670;&#160;</a></span>upgrade_lock()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;jh::meta::TStr S, bool HighPriv&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classjh_1_1sync_1_1ipc_1_1shared__process__mutex.html">jh::sync::ipc::shared_process_mutex</a>&lt; S, HighPriv &gt;::upgrade_lock </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Upgrade from shared to exclusive mode (system-wide). </p>
<p>Steps: </p><ol>
<li>
Requires the participant to hold a shared lock. </li>
<li>
Attempts to acquire <code>.exc</code> (blocks new readers). </li>
<li>
If <code>.exc</code> is held by another writer, acquires <code>.pri</code> to preempt that writer and maintain upgrade continuity. </li>
<li>
If <code>.pri</code> cannot be acquired, another upgrader is active — treated as fatal violation. </li>
<li>
Waits until all other readers exit (<span class="tt">readers_ == 1</span>). </li>
<li>
Decrements its reader count and transitions into exclusive mode. </li>
</ol>
<p>This operation preserves global upgrade atomicity and ensures consistency across processes. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/jh/synchronous/ipc/<a class="el" href="">shared_process_mutex.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
</div> <!-- top -->
<hr class="footer"/>
<div class="footer">
    <img class="footer-logo" src="Ojing.svg" alt="Ojing"/>
    <div class="footer-text">
        JH-Toolkit v1.4.0 · Generated by Doxygen
    </div>
    <div class="footer-note">
        We primarily support embedded documentation views in IDEs (classic CLion).
        To ensure compatibility with embedded rendering, some example code in this
        documentation intentionally contains HTML entities.
        In certain cases, Doxygen does not unescape these entities correctly.
        This is a known limitation and currently has no workaround.
    </div>
</div>
</body>
</html>
