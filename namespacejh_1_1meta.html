<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.16.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>JH-Toolkit: jh::meta Namespace Reference</title>
<link rel="icon" href="Jindallae.svg" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="Oree.svg"/></td>
  <td id="projectalign">
   <div id="projectname">JH-Toolkit<span id="projectnumber">&#160;v1.4.0</span>
   </div>
   <div id="projectbrief">An engineering-oriented C++20 toolkit with duck-typed concepts, static design, async coroutines, and semantic containers â€” header-only, RTTI-free, and concurrency-friendly.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.16.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('namespacejh_1_1meta.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">jh::meta Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:flatten_5Fproxy" id="r_flatten_5Fproxy"><td class="memItemLeft">struct &#160;</td><td class="memItemRight"><a class="el" href="structjh_1_1meta_1_1flatten__proxy.html">flatten_proxy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Proxy wrapper that lazily exposes flattened tuple access.  <a href="structjh_1_1meta_1_1flatten__proxy.html#details">More...</a><br /></td></tr>
<tr class="memitem:lookup_5Fmap" id="r_lookup_5Fmap"><td class="memItemLeft">struct &#160;</td><td class="memItemRight"><a class="el" href="structjh_1_1meta_1_1lookup__map.html">lookup_map</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fixed-capacity hash-based flat map providing switch-like lookup semantics.  <a href="structjh_1_1meta_1_1lookup__map.html#details">More...</a><br /></td></tr>
<tr class="memitem:t_5Fstr" id="r_t_5Fstr"><td class="memItemLeft">struct &#160;</td><td class="memItemRight"><a class="el" href="structjh_1_1meta_1_1t__str.html">t_str</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile-time string wrapper for use as a non-type template parameter (NTTP).  <a href="structjh_1_1meta_1_1t__str.html#details">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-concepts" class="groupheader"><a id="concepts" name="concepts"></a>
Concepts</h2></td></tr>
<tr class="memitem:any_5Fchar" id="r_any_5Fchar"><td class="memItemLeft">concept &#160;</td><td class="memItemRight"><a class="el" href="conceptjh_1_1meta_1_1any__char.html">any_char</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept representing <span class="tt">character-semantic</span> 1-byte integral types. <br /></td></tr>
<tr class="memitem:transparent_5Fkey" id="r_transparent_5Fkey"><td class="memItemLeft">concept &#160;</td><td class="memItemRight"><a class="el" href="conceptjh_1_1meta_1_1transparent__key.html">transparent_key</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept checking whether key conversion through <code>key_traits&lt;K&gt;</code> is valid. <br /></td></tr>
<tr class="memitem:check_5Fall" id="r_check_5Fall"><td class="memItemLeft">concept &#160;</td><td class="memItemRight"><a class="el" href="conceptjh_1_1meta_1_1check__all.html">check_all</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile-time predicate applied to all alternatives in a variant. <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-typedef-members" class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a2c7c6d5726fe729281558cf3e1b39c73" id="r_a2c7c6d5726fe729281558cf3e1b39c73"><td class="memTemplParams" colspan="2">template&lt;std::size_t I, typename Variant, template&lt; typename &gt; typename TpTrans&gt; </td></tr>
<tr class="memitem:a2c7c6d5726fe729281558cf3e1b39c73 template"><td class="memItemLeft">using&#160;</td><td class="memItemRight"><a class="el" href="#a2c7c6d5726fe729281558cf3e1b39c73">deduce_type_t</a> = typename detail::deduce_type&lt;I, Variant, TpTrans&gt;::type</td></tr>
<tr class="memdesc:a2c7c6d5726fe729281558cf3e1b39c73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the transformed type of the I-th alternative in a variant.  <br /></td></tr>
<tr class="memitem:acd983f119ed02295fe5560be5fddfe6c" id="r_acd983f119ed02295fe5560be5fddfe6c"><td class="memTemplParams" colspan="2">template&lt;typename Variant, template&lt; typename &gt; typename TpTrans&gt; </td></tr>
<tr class="memitem:acd983f119ed02295fe5560be5fddfe6c template"><td class="memItemLeft">using&#160;</td><td class="memItemRight"><a class="el" href="#acd983f119ed02295fe5560be5fddfe6c">variant_transform_t</a> = typename detail::variant_transform_impl&lt;Variant, TpTrans&gt;::type</td></tr>
<tr class="memdesc:acd983f119ed02295fe5560be5fddfe6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a unary type transformation to every alternative in a variant.  <br /></td></tr>
<tr class="memitem:a21456508a218dd8558dc10e070097a80" id="r_a21456508a218dd8558dc10e070097a80"><td class="memTemplParams" colspan="2">template&lt;typename Variant, template&lt; typename &gt; typename TpTrans&gt; </td></tr>
<tr class="memitem:a21456508a218dd8558dc10e070097a80 template"><td class="memItemLeft">using&#160;</td><td class="memItemRight"><a class="el" href="#a21456508a218dd8558dc10e070097a80">variant_collapse_t</a></td></tr>
<tr class="memdesc:a21456508a218dd8558dc10e070097a80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to collapse a transformed variant into a single uniform type.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-enum-members" class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a7ea475ab0421edb9edb93189740da707" id="r_a7ea475ab0421edb9edb93189740da707"><td class="memItemLeft">enum class &#160;</td><td class="memItemRight"><a class="el" href="#a7ea475ab0421edb9edb93189740da707">c_hash</a> : std::uint8_t { <br />
&#160;&#160;<a class="el" href="#a7ea475ab0421edb9edb93189740da707aca0466d3124e039f7442eccafc2fd891">fnv1a64</a> = 0
, <a class="el" href="#a7ea475ab0421edb9edb93189740da707a801754de2e3613d0a8384c2e15d8acd0">fnv1_64</a> = 1
, <a class="el" href="#a7ea475ab0421edb9edb93189740da707ad135fed35d7b519e59544d89c4710f86">djb2</a> = 2
, <a class="el" href="#a7ea475ab0421edb9edb93189740da707af507ae7f703754f0db87d15de56a7987">sdbm</a> = 3
, <br />
&#160;&#160;<a class="el" href="#a7ea475ab0421edb9edb93189740da707a9b8b9c08ae9b6e050210e9ff2a950116">murmur64</a> = 4
, <a class="el" href="#a7ea475ab0421edb9edb93189740da707ab3fae8c169390abead5d02af0f63d102">xxhash64</a> = 5
<br />
 }</td></tr>
<tr class="memdesc:a7ea475ab0421edb9edb93189740da707"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile-time selectable hash algorithm tag (FNV, DJB2, SDBM, etc.).  <a href="#a7ea475ab0421edb9edb93189740da707">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a0cef302115e1455eeb8d86afa4e0e9c9" id="r_a0cef302115e1455eeb8d86afa4e0e9c9"><td class="memTemplParams" colspan="2">template&lt;class F, class T, size_t... I&gt; </td></tr>
<tr class="memitem:a0cef302115e1455eeb8d86afa4e0e9c9 template"><td class="memItemLeft">constexpr decltype(auto)&#160;</td><td class="memItemRight"><a class="el" href="#a0cef302115e1455eeb8d86afa4e0e9c9">adl_apply_impl</a> (F &amp;&amp;f, T &amp;&amp;t, std::index_sequence&lt; I... &gt;)</td></tr>
<tr class="memdesc:a0cef302115e1455eeb8d86afa4e0e9c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal implementation helper for <code><a class="el" href="#a5e3294b6489e7e73d1c0b040b9dbbc86" title="ADL-enabled universal apply for tuple-like objects.">jh::meta::adl_apply</a></code>.  <br /></td></tr>
<tr class="memitem:a5e3294b6489e7e73d1c0b040b9dbbc86" id="r_a5e3294b6489e7e73d1c0b040b9dbbc86"><td class="memTemplParams" colspan="2">template&lt;class F, <a class="el" href="conceptjh_1_1concepts_1_1tuple__like.html">jh::concepts::tuple_like</a> T&gt; </td></tr>
<tr class="memitem:a5e3294b6489e7e73d1c0b040b9dbbc86 template"><td class="memItemLeft">constexpr decltype(auto)&#160;</td><td class="memItemRight"><a class="el" href="#a5e3294b6489e7e73d1c0b040b9dbbc86">adl_apply</a> (F &amp;&amp;f, T &amp;&amp;t) noexcept(noexcept(<a class="el" href="#a0cef302115e1455eeb8d86afa4e0e9c9">adl_apply_impl</a>(std::forward&lt; F &gt;(f), std::forward&lt; T &gt;(t), std::make_index_sequence&lt; std::tuple_size_v&lt; std::remove_cvref_t&lt; T &gt; &gt; &gt;{})))</td></tr>
<tr class="memdesc:a5e3294b6489e7e73d1c0b040b9dbbc86"><td class="mdescLeft">&#160;</td><td class="mdescRight">ADL-enabled universal apply for tuple-like objects.  <br /></td></tr>
<tr class="memitem:a2c0eb782dc3e8316e05ea1696e271d28" id="r_a2c0eb782dc3e8316e05ea1696e271d28"><td class="memTemplParams" colspan="2">template&lt;TStr S&gt; </td></tr>
<tr class="memitem:a2c0eb782dc3e8316e05ea1696e271d28 template"><td class="memItemLeft">constexpr auto&#160;</td><td class="memItemRight"><a class="el" href="#a2c0eb782dc3e8316e05ea1696e271d28">decode_base64</a> ()</td></tr>
<tr class="memdesc:a2c0eb782dc3e8316e05ea1696e271d28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a Base64-encoded <code>TStr</code> literal at compile time.  <br /></td></tr>
<tr class="memitem:a400b34eb10b9eac45a74171977fb72b5" id="r_a400b34eb10b9eac45a74171977fb72b5"><td class="memTemplParams" colspan="2">template&lt;TStr S&gt; </td></tr>
<tr class="memitem:a400b34eb10b9eac45a74171977fb72b5 template"><td class="memItemLeft">constexpr auto&#160;</td><td class="memItemRight"><a class="el" href="#a400b34eb10b9eac45a74171977fb72b5">decode_base64url</a> ()</td></tr>
<tr class="memdesc:a400b34eb10b9eac45a74171977fb72b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a Base64URL-encoded <code>TStr</code> literal at compile time.  <br /></td></tr>
<tr class="memitem:ad41d1719ddafa239b1004759108178f7" id="r_ad41d1719ddafa239b1004759108178f7"><td class="memTemplParams" colspan="2">template&lt;std::uint16_t N&gt; </td></tr>
<tr class="memitem:ad41d1719ddafa239b1004759108178f7 template"><td class="memItemLeft">constexpr auto&#160;</td><td class="memItemRight"><a class="el" href="#ad41d1719ddafa239b1004759108178f7">encode_base64</a> (const <a class="el" href="structjh_1_1pod_1_1array.html">jh::pod::array</a>&lt; std::uint8_t, N &gt; &amp;raw)</td></tr>
<tr class="memdesc:ad41d1719ddafa239b1004759108178f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode a byte buffer into a Base64 literal at compile time.  <br /></td></tr>
<tr class="memitem:a43b2aee38f3aba5d827faf90b7d39ff2" id="r_a43b2aee38f3aba5d827faf90b7d39ff2"><td class="memTemplParams" colspan="2">template&lt;std::uint16_t N, class PadT = std::false_type&gt; </td></tr>
<tr class="memitem:a43b2aee38f3aba5d827faf90b7d39ff2 template"><td class="memItemLeft">constexpr auto&#160;</td><td class="memItemRight"><a class="el" href="#a43b2aee38f3aba5d827faf90b7d39ff2">encode_base64url</a> (const <a class="el" href="structjh_1_1pod_1_1array.html">jh::pod::array</a>&lt; std::uint8_t, N &gt; &amp;raw, PadT={})</td></tr>
<tr class="memdesc:a43b2aee38f3aba5d827faf90b7d39ff2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode a byte buffer into a Base64URL literal at compile time.  <br /></td></tr>
<tr class="memitem:a77361dd79d5cf5c37e794e1b3a877b7c" id="r_a77361dd79d5cf5c37e794e1b3a877b7c"><td class="memTemplParams" colspan="2"><a id="a77361dd79d5cf5c37e794e1b3a877b7c" name="a77361dd79d5cf5c37e794e1b3a877b7c"></a>
template&lt;any_char Char&gt; </td></tr>
<tr class="memitem:a77361dd79d5cf5c37e794e1b3a877b7c template"><td class="memItemLeft">constexpr bool&#160;</td><td class="memItemRight"><b>is_alpha</b> (Char c) noexcept</td></tr>
<tr class="memdesc:a77361dd79d5cf5c37e794e1b3a877b7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if character is an alphabetic letter (A-Z, a-z). <br /></td></tr>
<tr class="memitem:a5fb1217f69fa86e89b057373c63f7610" id="r_a5fb1217f69fa86e89b057373c63f7610"><td class="memTemplParams" colspan="2"><a id="a5fb1217f69fa86e89b057373c63f7610" name="a5fb1217f69fa86e89b057373c63f7610"></a>
template&lt;any_char Char&gt; </td></tr>
<tr class="memitem:a5fb1217f69fa86e89b057373c63f7610 template"><td class="memItemLeft">constexpr bool&#160;</td><td class="memItemRight"><b>is_digit</b> (Char c) noexcept</td></tr>
<tr class="memdesc:a5fb1217f69fa86e89b057373c63f7610"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if character is a decimal digit (0-9). <br /></td></tr>
<tr class="memitem:a2ef2c3364b268e36f7ab20865c71453a" id="r_a2ef2c3364b268e36f7ab20865c71453a"><td class="memTemplParams" colspan="2"><a id="a2ef2c3364b268e36f7ab20865c71453a" name="a2ef2c3364b268e36f7ab20865c71453a"></a>
template&lt;any_char Char&gt; </td></tr>
<tr class="memitem:a2ef2c3364b268e36f7ab20865c71453a template"><td class="memItemLeft">constexpr bool&#160;</td><td class="memItemRight"><b>is_alnum</b> (Char c) noexcept</td></tr>
<tr class="memdesc:a2ef2c3364b268e36f7ab20865c71453a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if character is alphanumeric (letter or digit). <br /></td></tr>
<tr class="memitem:a387bbe993692ba8a150671c7ad6cbfcf" id="r_a387bbe993692ba8a150671c7ad6cbfcf"><td class="memTemplParams" colspan="2"><a id="a387bbe993692ba8a150671c7ad6cbfcf" name="a387bbe993692ba8a150671c7ad6cbfcf"></a>
template&lt;any_char Char&gt; </td></tr>
<tr class="memitem:a387bbe993692ba8a150671c7ad6cbfcf template"><td class="memItemLeft">constexpr bool&#160;</td><td class="memItemRight"><b>is_hex_char</b> (Char c) noexcept</td></tr>
<tr class="memdesc:a387bbe993692ba8a150671c7ad6cbfcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if character is a valid hexadecimal digit. <br /></td></tr>
<tr class="memitem:a2bee5e582910fe984755f70d8a4cce17" id="r_a2bee5e582910fe984755f70d8a4cce17"><td class="memTemplParams" colspan="2"><a id="a2bee5e582910fe984755f70d8a4cce17" name="a2bee5e582910fe984755f70d8a4cce17"></a>
template&lt;any_char Char&gt; </td></tr>
<tr class="memitem:a2bee5e582910fe984755f70d8a4cce17 template"><td class="memItemLeft">constexpr bool&#160;</td><td class="memItemRight"><b>is_base64_core</b> (Char c) noexcept</td></tr>
<tr class="memdesc:a2bee5e582910fe984755f70d8a4cce17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if character belongs to standard Base64 alphabet. <br /></td></tr>
<tr class="memitem:a69d880703ba1ae72c6181702cccfe952" id="r_a69d880703ba1ae72c6181702cccfe952"><td class="memTemplParams" colspan="2"><a id="a69d880703ba1ae72c6181702cccfe952" name="a69d880703ba1ae72c6181702cccfe952"></a>
template&lt;any_char Char&gt; </td></tr>
<tr class="memitem:a69d880703ba1ae72c6181702cccfe952 template"><td class="memItemLeft">constexpr bool&#160;</td><td class="memItemRight"><b>is_base64url_core</b> (Char c) noexcept</td></tr>
<tr class="memdesc:a69d880703ba1ae72c6181702cccfe952"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if character belongs to Base64URL alphabet. <br /></td></tr>
<tr class="memitem:a9dc06171b408ffbec668ad862412c94e" id="r_a9dc06171b408ffbec668ad862412c94e"><td class="memTemplParams" colspan="2"><a id="a9dc06171b408ffbec668ad862412c94e" name="a9dc06171b408ffbec668ad862412c94e"></a>
template&lt;any_char Char&gt; </td></tr>
<tr class="memitem:a9dc06171b408ffbec668ad862412c94e template"><td class="memItemLeft">constexpr bool&#160;</td><td class="memItemRight"><b>is_printable_ascii</b> (Char c) noexcept</td></tr>
<tr class="memdesc:a9dc06171b408ffbec668ad862412c94e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if character is printable 7-bit ASCII (range 32-126). <br /></td></tr>
<tr class="memitem:ab4c82117c1ba666ff3046b19e3384283" id="r_ab4c82117c1ba666ff3046b19e3384283"><td class="memTemplParams" colspan="2"><a id="ab4c82117c1ba666ff3046b19e3384283" name="ab4c82117c1ba666ff3046b19e3384283"></a>
template&lt;any_char Char&gt; </td></tr>
<tr class="memitem:ab4c82117c1ba666ff3046b19e3384283 template"><td class="memItemLeft">constexpr char&#160;</td><td class="memItemRight"><b>to_upper</b> (Char c) noexcept</td></tr>
<tr class="memdesc:ab4c82117c1ba666ff3046b19e3384283"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert letter to uppercase; leave others unchanged. <br /></td></tr>
<tr class="memitem:a7944757a692fbb43b0666d768435535d" id="r_a7944757a692fbb43b0666d768435535d"><td class="memTemplParams" colspan="2"><a id="a7944757a692fbb43b0666d768435535d" name="a7944757a692fbb43b0666d768435535d"></a>
template&lt;any_char Char&gt; </td></tr>
<tr class="memitem:a7944757a692fbb43b0666d768435535d template"><td class="memItemLeft">constexpr char&#160;</td><td class="memItemRight"><b>to_lower</b> (Char c) noexcept</td></tr>
<tr class="memdesc:a7944757a692fbb43b0666d768435535d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert letter to lowercase; leave others unchanged. <br /></td></tr>
<tr class="memitem:ac0d4dc74b57e204bda2ba4f0e8cb2b92" id="r_ac0d4dc74b57e204bda2ba4f0e8cb2b92"><td class="memTemplParams" colspan="2"><a id="ac0d4dc74b57e204bda2ba4f0e8cb2b92" name="ac0d4dc74b57e204bda2ba4f0e8cb2b92"></a>
template&lt;any_char Char&gt; </td></tr>
<tr class="memitem:ac0d4dc74b57e204bda2ba4f0e8cb2b92 template"><td class="memItemLeft">constexpr char&#160;</td><td class="memItemRight"><b>flip_case</b> (Char c) noexcept</td></tr>
<tr class="memdesc:ac0d4dc74b57e204bda2ba4f0e8cb2b92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flip case of alphabetic character. <br /></td></tr>
<tr class="memitem:a77de538c0c5a10d264e4a41d80d29053" id="r_a77de538c0c5a10d264e4a41d80d29053"><td class="memTemplParams" colspan="2">template&lt;typename Tuple&gt; </td></tr>
<tr class="memitem:a77de538c0c5a10d264e4a41d80d29053 template"><td class="memItemLeft">constexpr auto&#160;</td><td class="memItemRight"><a class="el" href="#a77de538c0c5a10d264e4a41d80d29053">tuple_materialize</a> (const Tuple &amp;t)</td></tr>
<tr class="memdesc:a77de538c0c5a10d264e4a41d80d29053"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flattens a tuple-like object into a fully materialized std::tuple.  <br /></td></tr>
<tr class="memitem:ac43fffca5fab177503794cbc81874384" id="r_ac43fffca5fab177503794cbc81874384"><td class="memTemplParams" colspan="2"><a id="ac43fffca5fab177503794cbc81874384" name="ac43fffca5fab177503794cbc81874384"></a>
template&lt;std::size_t I, typename Tuple&gt; </td></tr>
<tr class="memitem:ac43fffca5fab177503794cbc81874384 template"><td class="memItemLeft">constexpr decltype(auto)&#160;</td><td class="memItemRight"><b>get</b> (const <a class="el" href="structjh_1_1meta_1_1flatten__proxy.html">flatten_proxy</a>&lt; Tuple &gt; &amp;p) noexcept</td></tr>
<tr class="memitem:ae05f2c591e617cc02688994bff15c0c4" id="r_ae05f2c591e617cc02688994bff15c0c4"><td class="memTemplParams" colspan="2"><a id="ae05f2c591e617cc02688994bff15c0c4" name="ae05f2c591e617cc02688994bff15c0c4"></a>
template&lt;any_char Char&gt; </td></tr>
<tr class="memitem:ae05f2c591e617cc02688994bff15c0c4 template"><td class="memItemLeft">constexpr std::uint64_t&#160;</td><td class="memItemRight"><b>fnv1a64</b> (const Char *data, const std::uint64_t size) noexcept</td></tr>
<tr class="memdesc:ae05f2c591e617cc02688994bff15c0c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">FNV-1a 64-bit hash implementation (default choice). <br /></td></tr>
<tr class="memitem:a051bd3567d3d4ac3d94bb38237196efa" id="r_a051bd3567d3d4ac3d94bb38237196efa"><td class="memTemplParams" colspan="2"><a id="a051bd3567d3d4ac3d94bb38237196efa" name="a051bd3567d3d4ac3d94bb38237196efa"></a>
template&lt;any_char Char&gt; </td></tr>
<tr class="memitem:a051bd3567d3d4ac3d94bb38237196efa template"><td class="memItemLeft">constexpr std::uint64_t&#160;</td><td class="memItemRight"><b>fnv1_64</b> (const Char *data, const std::uint64_t size) noexcept</td></tr>
<tr class="memdesc:a051bd3567d3d4ac3d94bb38237196efa"><td class="mdescLeft">&#160;</td><td class="mdescRight">FNV-1 64-bit hash (multiply before xor). <br /></td></tr>
<tr class="memitem:aad6eef5388574eaa5f7a800fff74ae42" id="r_aad6eef5388574eaa5f7a800fff74ae42"><td class="memTemplParams" colspan="2"><a id="aad6eef5388574eaa5f7a800fff74ae42" name="aad6eef5388574eaa5f7a800fff74ae42"></a>
template&lt;any_char Char&gt; </td></tr>
<tr class="memitem:aad6eef5388574eaa5f7a800fff74ae42 template"><td class="memItemLeft">constexpr std::uint64_t&#160;</td><td class="memItemRight"><b>djb2</b> (const Char *str, const std::uint64_t size) noexcept</td></tr>
<tr class="memdesc:aad6eef5388574eaa5f7a800fff74ae42"><td class="mdescLeft">&#160;</td><td class="mdescRight">DJB2 hash (hash * 33 + c). <br /></td></tr>
<tr class="memitem:a60d16d2528d66346d84cc35793fa3ad9" id="r_a60d16d2528d66346d84cc35793fa3ad9"><td class="memTemplParams" colspan="2"><a id="a60d16d2528d66346d84cc35793fa3ad9" name="a60d16d2528d66346d84cc35793fa3ad9"></a>
template&lt;any_char Char&gt; </td></tr>
<tr class="memitem:a60d16d2528d66346d84cc35793fa3ad9 template"><td class="memItemLeft">constexpr std::uint64_t&#160;</td><td class="memItemRight"><b>sdbm</b> (const Char *str, const std::uint64_t size) noexcept</td></tr>
<tr class="memdesc:a60d16d2528d66346d84cc35793fa3ad9"><td class="mdescLeft">&#160;</td><td class="mdescRight">SDBM hash (used in several DB engines). <br /></td></tr>
<tr class="memitem:aa920d81776a7a608d1bbfe68c1a801ba" id="r_aa920d81776a7a608d1bbfe68c1a801ba"><td class="memTemplParams" colspan="2"><a id="aa920d81776a7a608d1bbfe68c1a801ba" name="aa920d81776a7a608d1bbfe68c1a801ba"></a>
template&lt;any_char Char&gt; </td></tr>
<tr class="memitem:aa920d81776a7a608d1bbfe68c1a801ba template"><td class="memItemLeft">constexpr std::uint64_t&#160;</td><td class="memItemRight"><b>murmur64</b> (const Char *data, const std::uint64_t size) noexcept</td></tr>
<tr class="memdesc:aa920d81776a7a608d1bbfe68c1a801ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">constexpr MurmurHash-like 64-bit variant (seedless) <br /></td></tr>
<tr class="memitem:a27b18e0e831d2dbe1de070aff63c28a2" id="r_a27b18e0e831d2dbe1de070aff63c28a2"><td class="memTemplParams" colspan="2"><a id="a27b18e0e831d2dbe1de070aff63c28a2" name="a27b18e0e831d2dbe1de070aff63c28a2"></a>
template&lt;any_char Char&gt; </td></tr>
<tr class="memitem:a27b18e0e831d2dbe1de070aff63c28a2 template"><td class="memItemLeft">constexpr std::uint64_t&#160;</td><td class="memItemRight"><b>xxhash64</b> (const Char *data, std::uint64_t len) noexcept</td></tr>
<tr class="memdesc:a27b18e0e831d2dbe1de070aff63c28a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">constexpr xxHash-like 64-bit variant (seedless) <br /></td></tr>
<tr class="memitem:ac27252503359c40182ba6074f8648683" id="r_ac27252503359c40182ba6074f8648683"><td class="memTemplParams" colspan="2"><a id="ac27252503359c40182ba6074f8648683" name="ac27252503359c40182ba6074f8648683"></a>
template&lt;any_char Char&gt; </td></tr>
<tr class="memitem:ac27252503359c40182ba6074f8648683 template"><td class="memItemLeft">constexpr std::uint64_t&#160;</td><td class="memItemRight"><b>hash</b> (const <a class="el" href="#a7ea475ab0421edb9edb93189740da707">c_hash</a> algo, const Char *data, const std::uint64_t size) noexcept</td></tr>
<tr class="memdesc:ac27252503359c40182ba6074f8648683"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatch to selected hash algorithm based on <a class="el" href="#a7ea475ab0421edb9edb93189740da707" title="Compile-time selectable hash algorithm tag (FNV, DJB2, SDBM, etc.).">c_hash</a>. <br /></td></tr>
<tr class="memitem:a23867267b0112bff3318a821628224e8" id="r_a23867267b0112bff3318a821628224e8"><td class="memTemplParams" colspan="2">template&lt;typename K, typename V, std::size_t N&gt; </td></tr>
<tr class="memitem:a23867267b0112bff3318a821628224e8 template"><td class="memItemLeft">&#160;</td><td class="memItemRight"><a class="el" href="#a23867267b0112bff3318a821628224e8">lookup_map</a> (std::array&lt; std::pair&lt; K, V &gt;, N &gt; &amp;&amp;) -&gt; lookup_map&lt; K, V, N, <a class="el" href="structjh_1_1hash.html">jh::hash</a>&lt; K &gt; &gt;</td></tr>
<tr class="memdesc:a23867267b0112bff3318a821628224e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction guide for constructing <code><a class="el" href="structjh_1_1meta_1_1lookup__map.html" title="Fixed-capacity hash-based flat map providing switch-like lookup semantics.">lookup_map</a></code> from an array of pairs.  <br /></td></tr>
<tr class="memitem:af6e7300a096a88586556c7917591de6b" id="r_af6e7300a096a88586556c7917591de6b"><td class="memTemplParams" colspan="2">template&lt;typename K, typename V, std::size_t N&gt; </td></tr>
<tr class="memitem:af6e7300a096a88586556c7917591de6b template"><td class="memItemLeft">&#160;</td><td class="memItemRight"><a class="el" href="#af6e7300a096a88586556c7917591de6b">lookup_map</a> (std::array&lt; std::pair&lt; K, V &gt;, N &gt; &amp;&amp;, V) -&gt; lookup_map&lt; K, V, N, <a class="el" href="structjh_1_1hash.html">jh::hash</a>&lt; K &gt; &gt;</td></tr>
<tr class="memdesc:af6e7300a096a88586556c7917591de6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction guide for constructing <code><a class="el" href="structjh_1_1meta_1_1lookup__map.html" title="Fixed-capacity hash-based flat map providing switch-like lookup semantics.">lookup_map</a></code> with an explicit default value.  <br /></td></tr>
<tr class="memitem:ad297ee6f02e5a4f89a7cd047cfbdabe6" id="r_ad297ee6f02e5a4f89a7cd047cfbdabe6"><td class="memTemplParams" colspan="2">template&lt;typename Hash, typename K, typename V, std::size_t N&gt; </td></tr>
<tr class="memitem:ad297ee6f02e5a4f89a7cd047cfbdabe6 template"><td class="memItemLeft">&#160;</td><td class="memItemRight"><a class="el" href="#ad297ee6f02e5a4f89a7cd047cfbdabe6">lookup_map</a> (std::array&lt; std::pair&lt; K, V &gt;, N &gt; &amp;&amp;, V, Hash) -&gt; lookup_map&lt; K, V, N, Hash &gt;</td></tr>
<tr class="memdesc:ad297ee6f02e5a4f89a7cd047cfbdabe6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction guide for constructing <code><a class="el" href="structjh_1_1meta_1_1lookup__map.html" title="Fixed-capacity hash-based flat map providing switch-like lookup semantics.">lookup_map</a></code> using a user-provided hash.  <br /></td></tr>
<tr class="memitem:aa98f180d57188d3701042d8210983a18" id="r_aa98f180d57188d3701042d8210983a18"><td class="memTemplParams" colspan="2">template&lt;typename Hash, typename K, typename V, std::size_t N&gt; </td></tr>
<tr class="memitem:aa98f180d57188d3701042d8210983a18 template"><td class="memItemLeft">consteval auto&#160;</td><td class="memItemRight"><a class="el" href="#aa98f180d57188d3701042d8210983a18">make_lookup_map</a> (const std::array&lt; std::pair&lt; K, V &gt;, N &gt; &amp;init, V default_value=V{}, Hash hash_fn=Hash{})</td></tr>
<tr class="memdesc:aa98f180d57188d3701042d8210983a18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile-time constructor for <code><a class="el" href="structjh_1_1meta_1_1lookup__map.html" title="Fixed-capacity hash-based flat map providing switch-like lookup semantics.">lookup_map</a></code> with explicit hash.  <br /></td></tr>
<tr class="memitem:aebb111e2b317f369b56b79534b9c0cc4" id="r_aebb111e2b317f369b56b79534b9c0cc4"><td class="memTemplParams" colspan="2">template&lt;typename K, typename V, std::size_t N&gt; </td></tr>
<tr class="memitem:aebb111e2b317f369b56b79534b9c0cc4 template"><td class="memItemLeft">consteval auto&#160;</td><td class="memItemRight"><a class="el" href="#aebb111e2b317f369b56b79534b9c0cc4">make_lookup_map</a> (const std::array&lt; std::pair&lt; K, V &gt;, N &gt; &amp;init, V default_value=V{})</td></tr>
<tr class="memdesc:aebb111e2b317f369b56b79534b9c0cc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile-time constructor using automatically deduced <code><a class="el" href="structjh_1_1hash.html" title="Behaviorally deduced hash functor.">jh::hash&lt;K&gt;</a></code>.  <br /></td></tr>
<tr class="memitem:a01311c57cba89e217533d36f045a46d5" id="r_a01311c57cba89e217533d36f045a46d5"><td class="memTemplParams" colspan="2">template&lt;typename V, std::size_t N&gt; </td></tr>
<tr class="memitem:a01311c57cba89e217533d36f045a46d5 template"><td class="memItemLeft">consteval auto&#160;</td><td class="memItemRight"><a class="el" href="#a01311c57cba89e217533d36f045a46d5">make_lookup_map</a> (const std::array&lt; std::pair&lt; std::string_view, V &gt;, N &gt; &amp;init, V default_value=V{})</td></tr>
<tr class="memdesc:a01311c57cba89e217533d36f045a46d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile-time constructor for tables declared with <code>std::string_view</code> keys.  <br /></td></tr>
<tr class="memitem:a534dccf9ad19674e200f183630dd587a" id="r_a534dccf9ad19674e200f183630dd587a"><td class="memTemplParams" colspan="2">template&lt;std::uint16_t N&gt; </td></tr>
<tr class="memitem:a534dccf9ad19674e200f183630dd587a template"><td class="memItemLeft">std::ostream &amp;&#160;</td><td class="memItemRight"><a class="el" href="#a534dccf9ad19674e200f183630dd587a">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="structjh_1_1meta_1_1t__str.html">t_str</a>&lt; N &gt; &amp;str)</td></tr>
<tr class="memdesc:a534dccf9ad19674e200f183630dd587a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stream output operator for <code><a class="el" href="structjh_1_1meta_1_1t__str.html" title="Compile-time string wrapper for use as a non-type template parameter (NTTP).">t_str&lt;N&gt;</a></code>.  <br /></td></tr>
</table>
<a name="doc-typedef-members" id="doc-typedef-members"></a><h2 id="header-doc-typedef-members" class="groupheader">Typedef Documentation</h2>
<a id="a2c7c6d5726fe729281558cf3e1b39c73" name="a2c7c6d5726fe729281558cf3e1b39c73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c7c6d5726fe729281558cf3e1b39c73">&#9670;&#160;</a></span>deduce_type_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t I, typename Variant, template&lt; typename &gt; typename TpTrans&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a2c7c6d5726fe729281558cf3e1b39c73">jh::meta::deduce_type_t</a> = typename detail::deduce_type&lt;I, Variant, TpTrans&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts the transformed type of the I-th alternative in a variant. </p>
<p>This alias applies the user-provided transformation <code>TpTrans</code> to the <code>I</code>-th alternative of <code>Variant</code>. Before extraction, a full-variant validity check is performed: every alternative <code>T</code> in <code>Variant</code> must satisfy <code>TpTrans&lt;T&gt;::type</code> being a valid, non-void type. If any alternative fails this requirement, substitution fails and the alias cannot be instantiated.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">I</td><td>Index of the alternative in the variant. </td></tr>
    <tr><td class="paramname">Variant</td><td>A <code>std::variant</code> whose alternatives are transformed. </td></tr>
    <tr><td class="paramname">TpTrans</td><td>A unary metafunction template exposing <code>::type</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If the transformation is invalid for any alternative, this alias participates in SFINAE failure rather than producing a type. </dd></dl>

</div>
</div>
<a id="a21456508a218dd8558dc10e070097a80" name="a21456508a218dd8558dc10e070097a80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21456508a218dd8558dc10e070097a80">&#9670;&#160;</a></span>variant_collapse_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Variant, template&lt; typename &gt; typename TpTrans&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a21456508a218dd8558dc10e070097a80">jh::meta::variant_collapse_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line"><span class="keyword">typename</span> detail::variant_collapse_impl&lt;Variant, TpTrans&gt;::type</div>
</div><!-- fragment -->
<p>Attempts to collapse a transformed variant into a single uniform type. </p>
<p>Each alternative <code>T</code> in the input <code>Variant</code> is mapped through <code>TpTrans&lt;T&gt;::type</code>. If all mapped results are exactly the same type, that type is exposed as the result. If any alternative maps to a different type, collapse fails and the alias becomes <code>void</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Variant</td><td>A <code>std::variant</code> whose alternatives may collapse. </td></tr>
    <tr><td class="paramname">TpTrans</td><td>A unary metafunction template providing <code>::type</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Collapse does not permit mixed mappings. If uniformity cannot be proven, the resulting type is <code>void</code>. This mechanism allows users to detect the boundary at which alternatives can be considered belonging to the same external semantic family. </dd></dl>

</div>
</div>
<a id="acd983f119ed02295fe5560be5fddfe6c" name="acd983f119ed02295fe5560be5fddfe6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd983f119ed02295fe5560be5fddfe6c">&#9670;&#160;</a></span>variant_transform_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Variant, template&lt; typename &gt; typename TpTrans&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#acd983f119ed02295fe5560be5fddfe6c">jh::meta::variant_transform_t</a> = typename detail::variant_transform_impl&lt;Variant, TpTrans&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies a unary type transformation to every alternative in a variant. </p>
<p>The alias constructs a new <code>std::variant</code> whose alternatives are precisely <code>TpTrans&lt;T&gt;::type</code> for each alternative <code>T</code> in <code>Variant</code>.</p>
<dl class="section note"><dt>Note</dt><dd><b>No additional semantic validation is performed.</b> <br  />
 If the transformation leads to conflicting or duplicated alternatives, such as: <pre><code>
    std::variant&lt;TA, TB, ..., TA&gt;
</code></pre> the compiler's standard diagnostic for <code>std::variant</code> will report the error directly. <br  />
 This intentional design helps users discover logical mistakes in their ADT mappings without silently suppressing them.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Variant</td><td>The source <code>std::variant</code>. </td></tr>
    <tr><td class="paramname">TpTrans</td><td>A unary metafunction template providing <code>::type</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Transformation failure for any alternative results in SFINAE failure of this alias. No collapse or uniformity assumptions are made. </dd></dl>

</div>
</div>
<a name="doc-enum-members" id="doc-enum-members"></a><h2 id="header-doc-enum-members" class="groupheader">Enumeration Type Documentation</h2>
<a id="a7ea475ab0421edb9edb93189740da707" name="a7ea475ab0421edb9edb93189740da707"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ea475ab0421edb9edb93189740da707">&#9670;&#160;</a></span>c_hash</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a7ea475ab0421edb9edb93189740da707">jh::meta::c_hash</a> : std::uint8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel strong">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compile-time selectable hash algorithm tag (FNV, DJB2, SDBM, etc.). </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a7ea475ab0421edb9edb93189740da707aca0466d3124e039f7442eccafc2fd891" name="a7ea475ab0421edb9edb93189740da707aca0466d3124e039f7442eccafc2fd891"></a>fnv1a64&#160;</td><td class="fielddoc"><p>FNV-1a 64-bit hash. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7ea475ab0421edb9edb93189740da707a801754de2e3613d0a8384c2e15d8acd0" name="a7ea475ab0421edb9edb93189740da707a801754de2e3613d0a8384c2e15d8acd0"></a>fnv1_64&#160;</td><td class="fielddoc"><p>FNV-1 64-bit hash. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7ea475ab0421edb9edb93189740da707ad135fed35d7b519e59544d89c4710f86" name="a7ea475ab0421edb9edb93189740da707ad135fed35d7b519e59544d89c4710f86"></a>djb2&#160;</td><td class="fielddoc"><p>DJB2 hash (classic string hash). </p>
</td></tr>
<tr><td class="fieldname"><a id="a7ea475ab0421edb9edb93189740da707af507ae7f703754f0db87d15de56a7987" name="a7ea475ab0421edb9edb93189740da707af507ae7f703754f0db87d15de56a7987"></a>sdbm&#160;</td><td class="fielddoc"><p>SDBM hash (used in readdir, DBM). </p>
</td></tr>
<tr><td class="fieldname"><a id="a7ea475ab0421edb9edb93189740da707a9b8b9c08ae9b6e050210e9ff2a950116" name="a7ea475ab0421edb9edb93189740da707a9b8b9c08ae9b6e050210e9ff2a950116"></a>murmur64&#160;</td><td class="fielddoc"><p>constexpr-safe MurmurHash variant (seedless) </p>
</td></tr>
<tr><td class="fieldname"><a id="a7ea475ab0421edb9edb93189740da707ab3fae8c169390abead5d02af0f63d102" name="a7ea475ab0421edb9edb93189740da707ab3fae8c169390abead5d02af0f63d102"></a>xxhash64&#160;</td><td class="fielddoc"><p>constexpr xxHash64 variant (seedless) </p>
</td></tr>
</table>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="a5e3294b6489e7e73d1c0b040b9dbbc86" name="a5e3294b6489e7e73d1c0b040b9dbbc86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e3294b6489e7e73d1c0b040b9dbbc86">&#9670;&#160;</a></span>adl_apply()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F, <a class="el" href="conceptjh_1_1concepts_1_1tuple__like.html">jh::concepts::tuple_like</a> T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) jh::meta::adl_apply </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>ADL-enabled universal apply for tuple-like objects. </p>
<p>Invokes a callable object <code>f</code> with the unpacked elements of a tuple-like <code>t</code>, performing unqualified lookup for <code>get<em> so that both standard and user-defined tuple-likes
are supported.</em></code></p>
<p><code><em></em></code></p>
<p><code><em>
This function is conceptually equivalent to <code>std::apply</code>, but designed for broader compatibility: it requires only that the type model <code><a class="el" href="conceptjh_1_1concepts_1_1tuple__like.html" title="Concept recognizing tuple-like types.">jh::concepts::tuple_like</a></code>, not that <code>std::get</code> be specialized. Standard library tuples continue to resolve <code>std::get</code> normally, while user-defined types participate via ADL. </em></code></p>
<p><code><em></em></code></p>
<p><code><em></p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>Callable type.
</td></tr>
    <tr><td class="paramname">T</td><td>Tuple-like type satisfying <code><a class="el" href="conceptjh_1_1concepts_1_1tuple__like.html" title="Concept recognizing tuple-like types.">jh::concepts::tuple_like</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>Callable object to invoke. </td></tr>
    <tr><td class="paramname">t</td><td>Tuple-like object whose elements are unpacked and forwarded. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of <code>std::invoke(f, get&lt;I&gt;(t)...)</code>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>ADL lookup ensures correctness for user-defined tuple-like proxies and prevents illegal specialization of <code>std::get</code>. <br  />
 This approach is fully conforming and generates identical code to <code>std::apply</code> for standard tuple types. </dd></dl>
<p></em></code></p>

</div>
</div>
<a id="a0cef302115e1455eeb8d86afa4e0e9c9" name="a0cef302115e1455eeb8d86afa4e0e9c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cef302115e1455eeb8d86afa4e0e9c9">&#9670;&#160;</a></span>adl_apply_impl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F, class T, size_t... I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) jh::meta::adl_apply_impl </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::index_sequence&lt; I... &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internal implementation helper for <code><a class="el" href="#a5e3294b6489e7e73d1c0b040b9dbbc86" title="ADL-enabled universal apply for tuple-like objects.">jh::meta::adl_apply</a></code>. </p>
<p>Expands a tuple-like object <code>t</code> into individual elements and invokes <code>f</code> with them via unqualified <code>get<em> lookup.</em></code></p>
<p><code><em></em></code></p>
<p><code><em>
Unlike <code>std::apply</code>, this implementation deliberately omits <code>using std::get;</code> to preserve Argument-Dependent Lookup (ADL). Bringing <code>std::get</code> into scope would suppress ADL resolution and force all <code>get<em> calls to bind to <code>std::get</code>, breaking compatibility with user-defined tuple-like types that rely on ADL-visible <code>get<em> overloads.
</em></code></em></code></em></code></p>
<p><code><em><code><em><code><em></em></code></em></code></em></code></p>
<p><code><em><code><em><code><em></em></code></em></code></em></code></p>
<p><code><em><code><em><code><em>
This choice allows both standard tuple-likes
(<code>std::tuple</code>, <code>std::pair</code>, <code>std::array</code>) and user-defined tuple-like structures to be expanded uniformly without violating the one-definition rule for <code>std::get</code>. </em></code></em></code></em></code></p>
<p><code><em><code><em><code><em></em></code></em></code></em></code></p>
<p><code><em><code><em><code><em></em></code></em></code></em></code></p>
<p><code><em><code><em><code><em>
In summary, <b><code>using std::get</code> is incorrect here</b> because it prevents ADL participation, effectively disabling lookup of valid user-defined <code>get<em> functions.
</em></code></em></code></em></code></em></code></p>
<p><code><em><code><em><code><em><code><em></em></code></em></code></em></code></em></code></p>
<p><code><em><code><em><code><em><code><em></p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>Callable type.
</td></tr>
    <tr><td class="paramname">T</td><td>Tuple-like object type satisfying <code><a class="el" href="conceptjh_1_1concepts_1_1tuple__like.html" title="Concept recognizing tuple-like types.">jh::concepts::tuple_like</a></code>. </td></tr>
    <tr><td class="paramname">I...</td><td>Compile-time indices derived from <code>std::tuple_size_v&lt;T&gt;</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>Callable to be invoked with unpacked elements. </td></tr>
    <tr><td class="paramname">t</td><td>Tuple-like object to unpack. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of invoking <code>f</code> with the elements of <code>t</code>. </dd></dl>
<p></em></code></em></code></em></code></em></code></p>

</div>
</div>
<a id="a2c0eb782dc3e8316e05ea1696e271d28" name="a2c0eb782dc3e8316e05ea1696e271d28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c0eb782dc3e8316e05ea1696e271d28">&#9670;&#160;</a></span>decode_base64()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;TStr S&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto jh::meta::decode_base64 </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decode a Base64-encoded <code>TStr</code> literal at compile time. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">S</td><td>A <code>TStr</code> literal representing a Base64-encoded string. The template is enabled only when <code>S.is_base64()</code> is true.</td></tr>
  </table>
  </dd>
</dl>
<p>This function performs fully compile-time Base64 decoding when the encoded value is supplied as a non-type template parameter (NTTP). All validation is performed through the <code>TStr</code> constraint system, ensuring that the input literal satisfies Base64 structural rules at compile time. <br  />
 The function returns a <code><a class="el" href="structjh_1_1pod_1_1array.html" title="POD-compatible fixed-size array, similar in shape to std::array, but simpler and fully POD.">jh::pod::array</a></code> whose size matches the decoded payload length. Since the operation is constexpr-capable, the result may be used in constexpr contexts, static initialization, or as further NTTP input to other compile-time facilities. </p>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="structjh_1_1pod_1_1array.html" title="POD-compatible fixed-size array, similar in shape to std::array, but simpler and fully POD.">jh::pod::array&lt;std::uint8_t, N&gt;</a></code> containing the decoded bytes.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Since decoding occurs entirely at compile time, invalid Base64 input results in a compilation error rather than a runtime error. </dd></dl>

</div>
</div>
<a id="a400b34eb10b9eac45a74171977fb72b5" name="a400b34eb10b9eac45a74171977fb72b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a400b34eb10b9eac45a74171977fb72b5">&#9670;&#160;</a></span>decode_base64url()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;TStr S&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto jh::meta::decode_base64url </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decode a Base64URL-encoded <code>TStr</code> literal at compile time. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">S</td><td>A <code>TStr</code> literal representing Base64URL text, with or without padding. The template participates in overload resolution only when <code>S.is_base64url()</code> is true.</td></tr>
  </table>
  </dd>
</dl>
<p>This function evaluates Base64URL decoding entirely during compilation. Padded and non-padded Base64URL forms are supported, and the decoded output is produced as a POD-safe <code><a class="el" href="structjh_1_1pod_1_1array.html" title="POD-compatible fixed-size array, similar in shape to std::array, but simpler and fully POD.">jh::pod::array</a></code>. </p>
<p>Length rules for padded and non-padded Base64URL are applied through the <code>TStr</code> constraint rather than at runtime, guaranteeing correctness before code generation. </p>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="structjh_1_1pod_1_1array.html" title="POD-compatible fixed-size array, similar in shape to std::array, but simpler and fully POD.">jh::pod::array&lt;std::uint8_t, N&gt;</a></code> containing the decoded bytes. </dd></dl>

</div>
</div>
<a id="ad41d1719ddafa239b1004759108178f7" name="ad41d1719ddafa239b1004759108178f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad41d1719ddafa239b1004759108178f7">&#9670;&#160;</a></span>encode_base64()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::uint16_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto jh::meta::encode_base64 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structjh_1_1pod_1_1array.html">jh::pod::array</a>&lt; std::uint8_t, N &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>raw</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Encode a byte buffer into a Base64 literal at compile time. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>The size of the input byte buffer. The encoded size is determined automatically based on <code>N</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">raw</td><td>A <code><a class="el" href="structjh_1_1pod_1_1array.html" title="POD-compatible fixed-size array, similar in shape to std::array, but simpler and fully POD.">jh::pod::array&lt;std::uint8_t, N&gt;</a></code> representing the binary payload to encode.</td></tr>
  </table>
  </dd>
</dl>
<p>The function produces padded Base64 output (that is, with trailing '=' characters when required). The resulting text is stored in a <code>TStr&lt;M&gt;</code> compile-time string literal that includes a null terminator. </p>
<p>Because the output literal is returned as <code>TStr</code>, it may be used directly as an NTTP in subsequent compile-time operations such as: </p><ul>
<li>
constexpr decoding, </li>
<li>
compile-time hashing, </li>
<li>
static data construction, </li>
<li>
constexpr reflection pipelines. </li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>A <code>TStr&lt;M&gt;</code> containing the padded Base64 representation, terminated with a null character. </dd></dl>

</div>
</div>
<a id="a43b2aee38f3aba5d827faf90b7d39ff2" name="a43b2aee38f3aba5d827faf90b7d39ff2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43b2aee38f3aba5d827faf90b7d39ff2">&#9670;&#160;</a></span>encode_base64url()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::uint16_t N, class PadT = std::false_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto jh::meta::encode_base64url </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structjh_1_1pod_1_1array.html">jh::pod::array</a>&lt; std::uint8_t, N &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>raw</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PadT</td>          <td class="paramname"><span class="paramname"><em></em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Encode a byte buffer into a Base64URL literal at compile time. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>The size of the input byte buffer.</td></tr>
    <tr><td class="paramname">PadT</td><td>A boolean tag type controlling whether padding is emitted. The caller supplies an instance of <code>std::false_type{}</code> to generate unpadded Base64URL, or <code>std::true_type{}</code> to generate padded Base64URL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">raw</td><td>A <code><a class="el" href="structjh_1_1pod_1_1array.html" title="POD-compatible fixed-size array, similar in shape to std::array, but simpler and fully POD.">jh::pod::array&lt;std::uint8_t, N&gt;</a></code> representing the input bytes.</td></tr>
    <tr><td class="paramname">pad_tag</td><td>A value of type <code>PadT</code>. The caller must pass either <code>std::false_type{}</code> (no padding) or <code>std::true_type{}</code> (padding enabled). This parameter determines the encoding behavior and enables automatic type deduction for <code>PadT</code>.</td></tr>
  </table>
  </dd>
</dl>
<p>This function encodes the provided byte buffer into a Base64URL literal. Unlike the standard Base64 variant, padding is optional in Base64URL. The padding behavior is determined solely by the <code>pad_tag</code> parameter. </p>
<p>The resulting encoded text is returned as a <code>TStr&lt;M&gt;</code> instance that includes a null terminator. This enables further usage as an NTTP value in downstream compile-time operations. </p>
<dl class="section return"><dt>Returns</dt><dd>A <code>TStr&lt;M&gt;</code> containing either padded or non-padded Base64URL text depending on <code>pad_tag</code>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Use the following forms: <ul>
<li>
<code>encode_base64url(bytes, std::false_type{})</code> or default <code>encode_base64url(bytes)</code>for no padding </li>
<li>
<code>encode_base64url(bytes, std::true_type{})</code> for padded output </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a23867267b0112bff3318a821628224e8" name="a23867267b0112bff3318a821628224e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23867267b0112bff3318a821628224e8">&#9670;&#160;</a></span>lookup_map() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">jh::meta::lookup_map </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; std::pair&lt; K, V &gt;, N &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> -&gt;  lookup_map&lt; K, V, N, <a class="el" href="structjh_1_1hash.html">jh::hash</a>&lt; K &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deduction guide for constructing <code><a class="el" href="structjh_1_1meta_1_1lookup__map.html" title="Fixed-capacity hash-based flat map providing switch-like lookup semantics.">lookup_map</a></code> from an array of pairs. </p>
<p>The hash functor deduced here is <code><a class="el" href="structjh_1_1hash.html" title="Behaviorally deduced hash functor.">jh::hash&lt;K&gt;</a></code>. This is not a fixed hash: it is a dispatcher whose resolution order is: </p><ol>
<li>
<b>std::hash&lt;K&gt;</b> (always preferred if present) </li>
<li>
ADL-discovered <code>hash(K)</code> </li>
<li>
member function <code>K::hash()</code> </li>
</ol>
<p>Note that most <code>std::hash&lt;T&gt;</code> implementations in the standard library are <b>not</b> constexpr. Therefore, when this deduction guide selects an <code>std::hash&lt;K&gt;</code> that is not constexpr-friendly, compile-time evaluation of <code><a class="el" href="structjh_1_1meta_1_1lookup__map.html" title="Fixed-capacity hash-based flat map providing switch-like lookup semantics.">lookup_map</a></code> will fail. In such cases you must explicitly pass a constexpr hash. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K</td><td>Key type inferred from the pair array. </td></tr>
    <tr><td class="paramname">V</td><td>Value type. </td></tr>
    <tr><td class="paramname">N</td><td>Number of entries. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af6e7300a096a88586556c7917591de6b" name="af6e7300a096a88586556c7917591de6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6e7300a096a88586556c7917591de6b">&#9670;&#160;</a></span>lookup_map() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">jh::meta::lookup_map </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; std::pair&lt; K, V &gt;, N &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;) -&gt;  lookup_map&lt; K, V, N, <a class="el" href="structjh_1_1hash.html">jh::hash</a>&lt; K &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deduction guide for constructing <code><a class="el" href="structjh_1_1meta_1_1lookup__map.html" title="Fixed-capacity hash-based flat map providing switch-like lookup semantics.">lookup_map</a></code> with an explicit default value. </p>
<p>Uses <code><a class="el" href="structjh_1_1hash.html" title="Behaviorally deduced hash functor.">jh::hash&lt;K&gt;</a></code> as the hash dispatcher. If the selected hash source (typically <code>std::hash&lt;K&gt;</code>) is not constexpr-capable, compile-time instantiation cannot succeed. To construct a constexpr table, provide a custom constexpr hash functor explicitly.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K</td><td>Key type. </td></tr>
    <tr><td class="paramname">V</td><td>Value type. </td></tr>
    <tr><td class="paramname">N</td><td>Number of entries. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad297ee6f02e5a4f89a7cd047cfbdabe6" name="ad297ee6f02e5a4f89a7cd047cfbdabe6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad297ee6f02e5a4f89a7cd047cfbdabe6">&#9670;&#160;</a></span>lookup_map() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Hash, typename K, typename V, std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">jh::meta::lookup_map </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; std::pair&lt; K, V &gt;, N &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Hash</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;) -&gt;  lookup_map&lt; K, V, N, Hash &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deduction guide for constructing <code><a class="el" href="structjh_1_1meta_1_1lookup__map.html" title="Fixed-capacity hash-based flat map providing switch-like lookup semantics.">lookup_map</a></code> using a user-provided hash. </p>
<p>This overload bypasses the <code><a class="el" href="structjh_1_1hash.html" title="Behaviorally deduced hash functor.">jh::hash&lt;K&gt;</a></code> dispatcher entirely and uses the caller-specified <code>Hash</code>. When constexpr operation is required, supplying a constexpr-capable hash functor here is the recommended approach.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Hash</td><td>User-specified hash type. </td></tr>
    <tr><td class="paramname">K</td><td>Key type. </td></tr>
    <tr><td class="paramname">V</td><td>Value type. </td></tr>
    <tr><td class="paramname">N</td><td>Entry count. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aebb111e2b317f369b56b79534b9c0cc4" name="aebb111e2b317f369b56b79534b9c0cc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebb111e2b317f369b56b79534b9c0cc4">&#9670;&#160;</a></span>make_lookup_map() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto jh::meta::make_lookup_map </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; std::pair&lt; K, V &gt;, N &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>init</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V</td>          <td class="paramname"><span class="paramname"><em>default_value</em></span><span class="paramdefsep"> = </span><span class="paramdefval">V{}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel consteval">consteval</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compile-time constructor using automatically deduced <code><a class="el" href="structjh_1_1hash.html" title="Behaviorally deduced hash functor.">jh::hash&lt;K&gt;</a></code>. </p>
<p>Deduces the hash functor as <code><a class="el" href="structjh_1_1hash.html" title="Behaviorally deduced hash functor.">jh::hash&lt;K&gt;</a></code>, which dispatches hashing by prioritizing <code>std::hash&lt;K&gt;</code>. Since most standard-library hash implementations are not constexpr, deduction may select a non-constexpr hash, causing compile-time construction to fail. In such cases, the explicit-hash overload must be used.</p>
<p>This overload is safe when <code>K</code> itself provides a constexpr-capable hashing mechanism. Types satisfying this condition include: </p><ul>
<li>
user-defined types supplying a constexpr <code>std::hash&lt;K&gt;</code>, or </li>
<li>
<code><a class="el" href="structjh_1_1pod_1_1string__view.html" title="Read-only string view with POD layout.">jh::pod::string_view</a></code>, which supports constexpr hashing. </li>
</ul>
<h4>Usage example</h4>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacejh_1_1pod_1_1literals.html">jh::pod::literals</a>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// KeyType = jh::pod::string_view, which provides constexpr hashing.</span></div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> table =</div>
<div class="line">    <a class="code hl_function" href="#aa98f180d57188d3701042d8210983a18">jh::meta::make_lookup_map</a>(</div>
<div class="line">        std::array{</div>
<div class="line">            std::pair{ <span class="stringliteral">&quot;...&quot;</span>_psv, ValueType{...} },</div>
<div class="line">            ...</div>
<div class="line">            std::pair{ <span class="stringliteral">&quot;...&quot;</span>_psv, ValueType{...} }</div>
<div class="line">        },</div>
<div class="line">        ValueType{...});</div>
<div class="ttc" id="anamespacejh_1_1meta_html_aa98f180d57188d3701042d8210983a18"><div class="ttname"><a href="#aa98f180d57188d3701042d8210983a18">jh::meta::make_lookup_map</a></div><div class="ttdeci">consteval auto make_lookup_map(const std::array&lt; std::pair&lt; K, V &gt;, N &gt; &amp;init, V default_value=V{}, Hash hash_fn=Hash{})</div><div class="ttdoc">Compile-time constructor for lookup_map with explicit hash.</div><div class="ttdef"><b>Definition</b> lookup_map.h:496</div></div>
<div class="ttc" id="anamespacejh_1_1pod_1_1literals_html"><div class="ttname"><a href="namespacejh_1_1pod_1_1literals.html">jh::pod::literals</a></div><div class="ttdef"><b>Definition</b> string_view.h:403</div></div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K</td><td>Key type satisfying <code>extended_hashable</code>. </td></tr>
    <tr><td class="paramname">V</td><td>Value type. </td></tr>
    <tr><td class="paramname">N</td><td>Entry count.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">init</td><td>Key-value pairs. </td></tr>
    <tr><td class="paramname">default_value</td><td>Fallback value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa98f180d57188d3701042d8210983a18" name="aa98f180d57188d3701042d8210983a18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa98f180d57188d3701042d8210983a18">&#9670;&#160;</a></span>make_lookup_map() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Hash, typename K, typename V, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto jh::meta::make_lookup_map </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; std::pair&lt; K, V &gt;, N &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>init</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V</td>          <td class="paramname"><span class="paramname"><em>default_value</em></span><span class="paramdefsep"> = </span><span class="paramdefval">V{}</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Hash</td>          <td class="paramname"><span class="paramname"><em>hash_fn</em></span><span class="paramdefsep"> = </span><span class="paramdefval">Hash{}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel consteval">consteval</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compile-time constructor for <code><a class="el" href="structjh_1_1meta_1_1lookup__map.html" title="Fixed-capacity hash-based flat map providing switch-like lookup semantics.">lookup_map</a></code> with explicit hash. </p>
<p>Requires <code>Hash</code> to be explicitly provided. This is the most reliable way to construct a constexpr lookup table because no automatic hash deduction is used. Use this overload when: </p><ul>
<li>
the deduced <span class="tt"><a class="el" href="structjh_1_1hash.html" title="Behaviorally deduced hash functor.">jh::hash&lt;K&gt;</a></span> is not constexpr, or </li>
<li>
full control of hashing behavior is required. </li>
</ul>
<p>Standard-library <code>std::hash&lt;T&gt;</code> is usually not constexpr. If deduction would select such a hash, constexpr construction will fail; providing an explicit constexpr hash functor avoids this issue. </p>
<h4>Usage example</h4>
<div class="fragment"><div class="line"><span class="keyword">struct </span>MyHash {</div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keywordtype">size_t</span> operator()(KeyType k) <span class="keyword">const</span> <span class="keyword">noexcept</span> {</div>
<div class="line">        <span class="keywordflow">return</span> ...; <span class="comment">// constexpr-capable hashing</span></div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> table =</div>
<div class="line">    <a class="code hl_function" href="#aa98f180d57188d3701042d8210983a18">jh::meta::make_lookup_map&lt;MyHash&gt;</a>(</div>
<div class="line">        std::array{</div>
<div class="line">            std::pair{ KeyType{...}, ValueType{...} },</div>
<div class="line">            ...</div>
<div class="line">            std::pair{ KeyType{...}, ValueType{...} }</div>
<div class="line">        },</div>
<div class="line">        ValueType{...});</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Hash</td><td>Hash functor used for all entries. </td></tr>
    <tr><td class="paramname">K</td><td>Key type. </td></tr>
    <tr><td class="paramname">V</td><td>Value type. </td></tr>
    <tr><td class="paramname">N</td><td>Number of entries.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">init</td><td>Key-value pairs. </td></tr>
    <tr><td class="paramname">default_value</td><td>Value returned on lookup failure. </td></tr>
    <tr><td class="paramname">hash_fn</td><td>Explicit hash functor instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A fully constexpr lookup table. </dd></dl>

</div>
</div>
<a id="a01311c57cba89e217533d36f045a46d5" name="a01311c57cba89e217533d36f045a46d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01311c57cba89e217533d36f045a46d5">&#9670;&#160;</a></span>make_lookup_map() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto jh::meta::make_lookup_map </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; std::pair&lt; std::string_view, V &gt;, N &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>init</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V</td>          <td class="paramname"><span class="paramname"><em>default_value</em></span><span class="paramdefsep"> = </span><span class="paramdefval">V{}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel consteval">consteval</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compile-time constructor for tables declared with <code>std::string_view</code> keys. </p>
<p>This overload exists because <code>std::hash&lt;std::string_view&gt;</code> is not constexpr, which makes a compile-time table using <code>K = std::string_view</code> invalid. To preserve a natural declaration syntax using <span class="tt">"..."sv</span> while still supporting constexpr construction, this function converts all keys into <code><a class="el" href="structjh_1_1pod_1_1string__view.html" title="Read-only string view with POD layout.">jh::pod::string_view</a></code>, whose hashing is constexpr-capable and whose literal-backed storage never dangles.</p>
<p>Conceptually, this is a syntactic convenience: although the user writes keys as <span class="tt">std::string_view</span>, the actual stored key type is <code><a class="el" href="structjh_1_1pod_1_1string__view.html" title="Read-only string view with POD layout.">jh::pod::string_view</a></code>. The conversion is performed via <code>key_traits&lt;jh::pod::string_view&gt;</code>. </p>
<h4>Usage example</h4>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span>std::literals;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> table =</div>
<div class="line">    <a class="code hl_function" href="#aa98f180d57188d3701042d8210983a18">jh::meta::make_lookup_map</a>(</div>
<div class="line">        std::array{</div>
<div class="line">            std::pair{ <span class="stringliteral">&quot;...&quot;</span>sv, ValueType{...} },</div>
<div class="line">            ...</div>
<div class="line">            std::pair{ <span class="stringliteral">&quot;...&quot;</span>sv, ValueType{...} }</div>
<div class="line">        },</div>
<div class="line">        ValueType{...});</div>
<div class="line"><span class="comment">// The table stores keys as jh::pod::string_view internally.</span></div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">V</td><td>Value type. </td></tr>
    <tr><td class="paramname">N</td><td>Number of entries.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">init</td><td>Key-value pairs whose keys are written as <code>std::string_view</code>. </td></tr>
    <tr><td class="paramname">default_value</td><td>Fallback value for missing keys. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a534dccf9ad19674e200f183630dd587a" name="a534dccf9ad19674e200f183630dd587a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a534dccf9ad19674e200f183630dd587a">&#9670;&#160;</a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::uint16_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; jh::meta::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structjh_1_1meta_1_1t__str.html">t_str</a>&lt; N &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stream output operator for <code><a class="el" href="structjh_1_1meta_1_1t__str.html" title="Compile-time string wrapper for use as a non-type template parameter (NTTP).">t_str&lt;N&gt;</a></code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>Size of the compile-time string (including null terminator). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>The output stream. </td></tr>
    <tr><td class="paramname">str</td><td>The <code><a class="el" href="structjh_1_1meta_1_1t__str.html" title="Compile-time string wrapper for use as a non-type template parameter (NTTP).">t_str&lt;N&gt;</a></code> instance to print. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the output stream.</dd></dl>
<p>Writes the string's <code>std::string_view</code> to the given output stream. </p><ul>
<li>
This is the <b>default output representation</b>. </li>
<li>
It may be overridden by providing a higher-priority overload or explicitly bringing another overload into scope with <code>using</code>. </li>
<li>
The function is declared <code>inline</code>, which in C++17 and later does <b>not guarantee inlining</b>, but instead gives the function weak, foldable linkage semantics across translation units. </li>
</ul>
<dl class="section note"><dt>Note</dt><dd>The printed form is identical to the underlying string literal content (no quotes, escapes, or formatting applied). </dd></dl>

</div>
</div>
<a id="a77de538c0c5a10d264e4a41d80d29053" name="a77de538c0c5a10d264e4a41d80d29053"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77de538c0c5a10d264e4a41d80d29053">&#9670;&#160;</a></span>tuple_materialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tuple&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto jh::meta::tuple_materialize </td>
          <td>(</td>
          <td class="paramtype">const Tuple &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flattens a tuple-like object into a fully materialized std::tuple. </p>
<p>Public entry point for tuple flattening.</p>
<p>Recursively expands all nested <code>tuple_like</code> members within <code>T</code> and produces a single-level <code>std::tuple</code> containing their underlying elements.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Tuple</td><td>The input type modeling <code><a class="el" href="conceptjh_1_1concepts_1_1tuple__like.html" title="Concept recognizing tuple-like types.">jh::concepts::tuple_like</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The tuple-like object to flatten. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>std::tuple</code> with all nested contents expanded. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
</div> <!-- top -->
<hr class="footer"/>
<div class="footer">
    <img class="footer-logo" src="Ojing.svg" alt="Ojing"/>
    <div class="footer-text">
        JH-Toolkit v1.4.0 Â· Generated by Doxygen
    </div>
    <div class="footer-note">
        We primarily support embedded documentation views in IDEs (classic CLion).
        To ensure compatibility with embedded rendering, some example code in this
        documentation intentionally contains HTML entities.
        In certain cases, Doxygen does not unescape these entities correctly.
        This is a known limitation and currently has no workaround.
    </div>
</div>
</body>
</html>
