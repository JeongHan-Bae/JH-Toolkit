<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.16.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>JH-Toolkit: jh::pod Namespace Reference</title>
<link rel="icon" href="Jindallae.svg" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="Oree.svg"/></td>
  <td id="projectalign">
   <div id="projectname">JH-Toolkit<span id="projectnumber">&#160;v1.4.0</span>
   </div>
   <div id="projectbrief">An engineering-oriented C++20 toolkit with duck-typed concepts, static design, async coroutines, and semantic containers — header-only, RTTI-free, and concurrency-friendly.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.16.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('namespacejh_1_1pod.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">jh::pod Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:array" id="r_array"><td class="memItemLeft">struct &#160;</td><td class="memItemRight"><a class="el" href="structjh_1_1pod_1_1array.html">array</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">POD-compatible fixed-size array, similar in shape to <code>std::array</code>, but simpler and fully POD.  <a href="structjh_1_1pod_1_1array.html#details">More...</a><br /></td></tr>
<tr class="memitem:bitflags" id="r_bitflags"><td class="memItemLeft">struct &#160;</td><td class="memItemRight"><a class="el" href="structjh_1_1pod_1_1bitflags.html">bitflags</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">POD-compatible fixed-size bitflags structure.Generic fallback specialization for non-native sizes (e.g. 24, 120 bits, etc).  <a href="structjh_1_1pod_1_1bitflags.html#details">More...</a><br /></td></tr>
<tr class="memitem:bitflags_3C_208_20_3E" id="r_bitflags_3C_208_20_3E"><td class="memItemLeft">struct &#160;</td><td class="memItemRight"><a class="el" href="structjh_1_1pod_1_1bitflags_3_018_01_4.html">bitflags&lt; 8 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for 8-bit bitflags.  <a href="structjh_1_1pod_1_1bitflags_3_018_01_4.html#details">More...</a><br /></td></tr>
<tr class="memitem:bitflags_3C_2016_20_3E" id="r_bitflags_3C_2016_20_3E"><td class="memItemLeft">struct &#160;</td><td class="memItemRight"><a class="el" href="structjh_1_1pod_1_1bitflags_3_0116_01_4.html">bitflags&lt; 16 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for 16-bit bitflags.  <a href="structjh_1_1pod_1_1bitflags_3_0116_01_4.html#details">More...</a><br /></td></tr>
<tr class="memitem:bitflags_3C_2032_20_3E" id="r_bitflags_3C_2032_20_3E"><td class="memItemLeft">struct &#160;</td><td class="memItemRight"><a class="el" href="structjh_1_1pod_1_1bitflags_3_0132_01_4.html">bitflags&lt; 32 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for 32-bit bitflags.  <a href="structjh_1_1pod_1_1bitflags_3_0132_01_4.html#details">More...</a><br /></td></tr>
<tr class="memitem:bitflags_3C_2064_20_3E" id="r_bitflags_3C_2064_20_3E"><td class="memItemLeft">struct &#160;</td><td class="memItemRight"><a class="el" href="structjh_1_1pod_1_1bitflags_3_0164_01_4.html">bitflags&lt; 64 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for 64-bit bitflags.  <a href="structjh_1_1pod_1_1bitflags_3_0164_01_4.html#details">More...</a><br /></td></tr>
<tr class="memitem:bytes_5Fview" id="r_bytes_5Fview"><td class="memItemLeft">struct &#160;</td><td class="memItemRight"><a class="el" href="structjh_1_1pod_1_1bytes__view.html">bytes_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A read-only view over a block of raw bytes.  <a href="structjh_1_1pod_1_1bytes__view.html#details">More...</a><br /></td></tr>
<tr class="memitem:optional" id="r_optional"><td class="memItemLeft">struct &#160;</td><td class="memItemRight"><a class="el" href="structjh_1_1pod_1_1optional.html">optional</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">POD-compatible optional wrapper.  <a href="structjh_1_1pod_1_1optional.html#details">More...</a><br /></td></tr>
<tr class="memitem:pair" id="r_pair"><td class="memItemLeft">struct &#160;</td><td class="memItemRight"><a class="el" href="structjh_1_1pod_1_1pair.html">pair</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">POD-compatible aggregate of two values, equivalent in layout to a plain struct.  <a href="structjh_1_1pod_1_1pair.html#details">More...</a><br /></td></tr>
<tr class="memitem:span" id="r_span"><td class="memItemLeft">struct &#160;</td><td class="memItemRight"><a class="el" href="structjh_1_1pod_1_1span.html">span</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-owning typed view over a contiguous memory block.  <a href="structjh_1_1pod_1_1span.html#details">More...</a><br /></td></tr>
<tr class="memitem:string_5Fview" id="r_string_5Fview"><td class="memItemLeft">struct &#160;</td><td class="memItemRight"><a class="el" href="structjh_1_1pod_1_1string__view.html">string_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read-only string view with POD layout.  <a href="structjh_1_1pod_1_1string__view.html#details">More...</a><br /></td></tr>
<tr class="memitem:tuple" id="r_tuple"><td class="memItemLeft">struct &#160;</td><td class="memItemRight"><a class="el" href="structjh_1_1pod_1_1tuple.html">tuple</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">POD-compatible tuple type supporting structured bindings and tuple-like utilities.  <a href="structjh_1_1pod_1_1tuple.html#details">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-concepts" class="groupheader"><a id="concepts" name="concepts"></a>
Concepts</h2></td></tr>
<tr class="memitem:std_5Fuint" id="r_std_5Fuint"><td class="memItemLeft">concept &#160;</td><td class="memItemRight"><a class="el" href="conceptjh_1_1pod_1_1std__uint.html">std_uint</a></td></tr>
<tr class="memitem:trivial_5Fbytes" id="r_trivial_5Fbytes"><td class="memItemLeft">concept &#160;</td><td class="memItemRight"><a class="el" href="conceptjh_1_1pod_1_1trivial__bytes.html">trivial_bytes</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept for trivially layout-compatible types (POD-compatible memory view). <br /></td></tr>
<tr class="memitem:pod_5Flike" id="r_pod_5Flike"><td class="memItemLeft">concept &#160;</td><td class="memItemRight"><a class="el" href="conceptjh_1_1pod_1_1pod__like.html">pod_like</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept for types that are safe to treat as plain old data (POD). <br /></td></tr>
<tr class="memitem:cv_5Ffree_5Fpod_5Flike" id="r_cv_5Ffree_5Fpod_5Flike"><td class="memItemLeft">concept &#160;</td><td class="memItemRight"><a class="el" href="conceptjh_1_1pod_1_1cv__free__pod__like.html">cv_free_pod_like</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept for POD-like types that are free of <code>const</code> or <code>volatile</code> qualification. <br /></td></tr>
<tr class="memitem:streamable" id="r_streamable"><td class="memItemLeft">concept &#160;</td><td class="memItemRight"><a class="el" href="conceptjh_1_1pod_1_1streamable.html">streamable</a></td></tr>
<tr class="memitem:streamable_5Fpod" id="r_streamable_5Fpod"><td class="memItemLeft">concept &#160;</td><td class="memItemRight"><a class="el" href="conceptjh_1_1pod_1_1streamable__pod.html">streamable_pod</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:af93796d595c10e036e1637ff7e89b8eb" id="r_af93796d595c10e036e1637ff7e89b8eb"><td class="memTemplParams" colspan="2">template&lt;std_uint UInt&gt; </td></tr>
<tr class="memitem:af93796d595c10e036e1637ff7e89b8eb template"><td class="memItemLeft">constexpr auto&#160;</td><td class="memItemRight"><a class="el" href="#af93796d595c10e036e1637ff7e89b8eb">uint_to_bytes</a> (const UInt val)</td></tr>
<tr class="memdesc:af93796d595c10e036e1637ff7e89b8eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an unsigned integer into a little-endian byte array.  <br /></td></tr>
<tr class="memitem:a7f2c0f4dbc28504d1eea591a1b86b8b3" id="r_a7f2c0f4dbc28504d1eea591a1b86b8b3"><td class="memTemplParams" colspan="2">template&lt;std::uint16_t N&gt; </td></tr>
<tr class="memitem:a7f2c0f4dbc28504d1eea591a1b86b8b3 template"><td class="memItemLeft">constexpr auto&#160;</td><td class="memItemRight"><a class="el" href="#a7f2c0f4dbc28504d1eea591a1b86b8b3">bytes_to_uint</a> (const <a class="el" href="structjh_1_1pod_1_1array.html">array</a>&lt; std::uint8_t, N &gt; &amp;arr)</td></tr>
<tr class="memdesc:a7f2c0f4dbc28504d1eea591a1b86b8b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a little-endian byte array into an unsigned integer.  <br /></td></tr>
<tr class="memitem:ae76efa550c362f1ae8f1ef81ab3af6ca" id="r_ae76efa550c362f1ae8f1ef81ab3af6ca"><td class="memTemplParams" colspan="2"><a id="ae76efa550c362f1ae8f1ef81ab3af6ca" name="ae76efa550c362f1ae8f1ef81ab3af6ca"></a>
template&lt;std::uint16_t N&gt; </td></tr>
<tr class="memitem:ae76efa550c362f1ae8f1ef81ab3af6ca template"><td class="memItemLeft">constexpr <a class="el" href="structjh_1_1pod_1_1bitflags.html">bitflags</a>&lt; N &gt;&#160;</td><td class="memItemRight"><b>operator|</b> (const <a class="el" href="structjh_1_1pod_1_1bitflags.html">bitflags</a>&lt; N &gt; &amp;lhs, const <a class="el" href="structjh_1_1pod_1_1bitflags.html">bitflags</a>&lt; N &gt; &amp;rhs) noexcept</td></tr>
<tr class="memitem:a075040c344331963f215349d70ce85ce" id="r_a075040c344331963f215349d70ce85ce"><td class="memTemplParams" colspan="2"><a id="a075040c344331963f215349d70ce85ce" name="a075040c344331963f215349d70ce85ce"></a>
template&lt;std::uint16_t N&gt; </td></tr>
<tr class="memitem:a075040c344331963f215349d70ce85ce template"><td class="memItemLeft">constexpr <a class="el" href="structjh_1_1pod_1_1bitflags.html">bitflags</a>&lt; N &gt;&#160;</td><td class="memItemRight"><b>operator&amp;</b> (const <a class="el" href="structjh_1_1pod_1_1bitflags.html">bitflags</a>&lt; N &gt; &amp;lhs, const <a class="el" href="structjh_1_1pod_1_1bitflags.html">bitflags</a>&lt; N &gt; &amp;rhs) noexcept</td></tr>
<tr class="memitem:a4d782cb656a754abed1d13880e90e65e" id="r_a4d782cb656a754abed1d13880e90e65e"><td class="memTemplParams" colspan="2"><a id="a4d782cb656a754abed1d13880e90e65e" name="a4d782cb656a754abed1d13880e90e65e"></a>
template&lt;std::uint16_t N&gt; </td></tr>
<tr class="memitem:a4d782cb656a754abed1d13880e90e65e template"><td class="memItemLeft">constexpr <a class="el" href="structjh_1_1pod_1_1bitflags.html">bitflags</a>&lt; N &gt;&#160;</td><td class="memItemRight"><b>operator^</b> (const <a class="el" href="structjh_1_1pod_1_1bitflags.html">bitflags</a>&lt; N &gt; &amp;lhs, const <a class="el" href="structjh_1_1pod_1_1bitflags.html">bitflags</a>&lt; N &gt; &amp;rhs) noexcept</td></tr>
<tr class="memitem:a64b05cfa98921c301e564a719bfca31f" id="r_a64b05cfa98921c301e564a719bfca31f"><td class="memTemplParams" colspan="2"><a id="a64b05cfa98921c301e564a719bfca31f" name="a64b05cfa98921c301e564a719bfca31f"></a>
template&lt;std::uint16_t N&gt; </td></tr>
<tr class="memitem:a64b05cfa98921c301e564a719bfca31f template"><td class="memItemLeft">constexpr <a class="el" href="structjh_1_1pod_1_1bitflags.html">bitflags</a>&lt; N &gt;&#160;</td><td class="memItemRight"><b>operator~</b> (const <a class="el" href="structjh_1_1pod_1_1bitflags.html">bitflags</a>&lt; N &gt; &amp;v) noexcept</td></tr>
<tr class="memitem:a6d1f8391a51ac87a4d482400fea14800" id="r_a6d1f8391a51ac87a4d482400fea14800"><td class="memTemplParams" colspan="2">template&lt;std::uint16_t N&gt; </td></tr>
<tr class="memitem:a6d1f8391a51ac87a4d482400fea14800 template"><td class="memItemLeft">constexpr <a class="el" href="structjh_1_1pod_1_1array.html">array</a>&lt; std::uint8_t, N/8 &gt;&#160;</td><td class="memItemRight"><a class="el" href="#a6d1f8391a51ac87a4d482400fea14800">to_bytes</a> (<a class="el" href="structjh_1_1pod_1_1bitflags.html">bitflags</a>&lt; N &gt; f)</td></tr>
<tr class="memdesc:a6d1f8391a51ac87a4d482400fea14800"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize a <code><a class="el" href="structjh_1_1pod_1_1bitflags.html" title="POD-compatible fixed-size bitflags structure.Generic fallback specialization for non-native sizes (e....">bitflags&lt;N&gt;</a></code> into a little-endian byte array (snapshot).  <br /></td></tr>
<tr class="memitem:aa66f1d237ccedf73ed484408b86a48af" id="r_aa66f1d237ccedf73ed484408b86a48af"><td class="memTemplParams" colspan="2">template&lt;std::uint16_t N&gt; </td></tr>
<tr class="memitem:aa66f1d237ccedf73ed484408b86a48af template"><td class="memItemLeft">constexpr <a class="el" href="structjh_1_1pod_1_1bitflags.html">bitflags</a>&lt; N &gt;&#160;</td><td class="memItemRight"><a class="el" href="#aa66f1d237ccedf73ed484408b86a48af">from_bytes</a> (<a class="el" href="structjh_1_1pod_1_1array.html">array</a>&lt; std::uint8_t, N/8 &gt; arr)</td></tr>
<tr class="memdesc:aa66f1d237ccedf73ed484408b86a48af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserialize a <code><a class="el" href="structjh_1_1pod_1_1bitflags.html" title="POD-compatible fixed-size bitflags structure.Generic fallback specialization for non-native sizes (e....">bitflags&lt;N&gt;</a></code> from a byte array (snapshot).  <br /></td></tr>
<tr class="memitem:a718067e095218525842cfbed6ec96676" id="r_a718067e095218525842cfbed6ec96676"><td class="memTemplParams" colspan="2">template&lt;pod_like T&gt; </td></tr>
<tr class="memitem:a718067e095218525842cfbed6ec96676 template"><td class="memItemLeft">constexpr <a class="el" href="structjh_1_1pod_1_1optional.html">optional</a>&lt; T &gt;&#160;</td><td class="memItemRight"><a class="el" href="#a718067e095218525842cfbed6ec96676">make_optional</a> (const T &amp;value) noexcept</td></tr>
<tr class="memdesc:a718067e095218525842cfbed6ec96676"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an <code><a class="el" href="structjh_1_1pod_1_1optional.html" title="POD-compatible optional wrapper.">optional&lt;T&gt;</a></code> with a value.  <br /></td></tr>
<tr class="memitem:a6bba6c453485cf29669db16b9612291d" id="r_a6bba6c453485cf29669db16b9612291d"><td class="memTemplParams" colspan="2">template&lt;cv_free_pod_like T1, cv_free_pod_like T2&gt; </td></tr>
<tr class="memitem:a6bba6c453485cf29669db16b9612291d template"><td class="memItemLeft">constexpr auto&#160;</td><td class="memItemRight"><a class="el" href="#a6bba6c453485cf29669db16b9612291d">make_pair</a> (T1 first, T2 second) noexcept</td></tr>
<tr class="memdesc:a6bba6c453485cf29669db16b9612291d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a POD-compatible pair from two values.  <br /></td></tr>
<tr class="memitem:a2ec05225b7c40fedc3b23c55655d8c04" id="r_a2ec05225b7c40fedc3b23c55655d8c04"><td class="memTemplParams" colspan="2"><a id="a2ec05225b7c40fedc3b23c55655d8c04" name="a2ec05225b7c40fedc3b23c55655d8c04"></a>
template&lt;typename T, std::uint64_t N&gt; </td></tr>
<tr class="memitem:a2ec05225b7c40fedc3b23c55655d8c04 template"><td class="memItemLeft">constexpr <a class="el" href="structjh_1_1pod_1_1span.html">span</a>&lt; T &gt;&#160;</td><td class="memItemRight"><b>to_span</b> (T(&amp;arr)[N]) noexcept</td></tr>
<tr class="memdesc:a2ec05225b7c40fedc3b23c55655d8c04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create span from a raw array (<code>T[N]</code>). <br /></td></tr>
<tr class="memitem:af3494da3696f5e9a49efafb68146ee6f" id="r_af3494da3696f5e9a49efafb68146ee6f"><td class="memTemplParams" colspan="2"><a id="af3494da3696f5e9a49efafb68146ee6f" name="af3494da3696f5e9a49efafb68146ee6f"></a>
template&lt;typename T, std::uint64_t N&gt; </td></tr>
<tr class="memitem:af3494da3696f5e9a49efafb68146ee6f template"><td class="memItemLeft">constexpr <a class="el" href="structjh_1_1pod_1_1span.html">span</a>&lt; const T &gt;&#160;</td><td class="memItemRight"><b>to_span</b> (const T(&amp;arr)[N]) noexcept</td></tr>
<tr class="memdesc:af3494da3696f5e9a49efafb68146ee6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create span from a const raw array (<code>const T[N]</code>). <br /></td></tr>
<tr class="memitem:abb8f4c57e0f9a07020a1db4a5bee1169" id="r_abb8f4c57e0f9a07020a1db4a5bee1169"><td class="memTemplParams" colspan="2">template&lt;detail::linear_container C&gt; </td></tr>
<tr class="memitem:abb8f4c57e0f9a07020a1db4a5bee1169 template"><td class="memItemLeft">constexpr auto&#160;</td><td class="memItemRight"><a class="el" href="#abb8f4c57e0f9a07020a1db4a5bee1169">to_span</a> (C &amp;c) noexcept</td></tr>
<tr class="memdesc:abb8f4c57e0f9a07020a1db4a5bee1169"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a POD-compatible <code>span</code> from a linear container.  <br /></td></tr>
<tr class="memitem:a415fb4f94c0f99140a488220a726e21d" id="r_a415fb4f94c0f99140a488220a726e21d"><td class="memTemplParams" colspan="2"><a id="a415fb4f94c0f99140a488220a726e21d" name="a415fb4f94c0f99140a488220a726e21d"></a>
template&lt;streamable T, uint16_t N&gt; </td></tr>
<tr class="memitem:a415fb4f94c0f99140a488220a726e21d template"><td class="memItemLeft">std::ostream &amp;&#160;</td><td class="memItemRight"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="structjh_1_1pod_1_1array.html">jh::pod::array</a>&lt; T, N &gt; &amp;arr)</td></tr>
<tr class="memitem:a4402270ca7b06ece90bc1f2b128e68ba" id="r_a4402270ca7b06ece90bc1f2b128e68ba"><td class="memTemplParams" colspan="2"><a id="a4402270ca7b06ece90bc1f2b128e68ba" name="a4402270ca7b06ece90bc1f2b128e68ba"></a>
template&lt;uint16_t N&gt; </td></tr>
<tr class="memitem:a4402270ca7b06ece90bc1f2b128e68ba template"><td class="memItemLeft">std::ostream &amp;&#160;</td><td class="memItemRight"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="structjh_1_1pod_1_1array.html">jh::pod::array</a>&lt; char, N &gt; &amp;str)</td></tr>
<tr class="memitem:a122ba158d1c41c4331fe00568a2faa09" id="r_a122ba158d1c41c4331fe00568a2faa09"><td class="memItemLeft"><a id="a122ba158d1c41c4331fe00568a2faa09" name="a122ba158d1c41c4331fe00568a2faa09"></a>
std::ostream &amp;&#160;</td><td class="memItemRight"><b>operator&lt;&lt;</b> (std::ostream &amp;os, <a class="el" href="structjh_1_1typed_1_1monostate.html">jh::typed::monostate</a> &amp;)</td></tr>
<tr class="memitem:aae495b656792133162e85f2b5f90b408" id="r_aae495b656792133162e85f2b5f90b408"><td class="memTemplParams" colspan="2"><a id="aae495b656792133162e85f2b5f90b408" name="aae495b656792133162e85f2b5f90b408"></a>
template&lt;streamable T1, streamable T2&gt; </td></tr>
<tr class="memitem:aae495b656792133162e85f2b5f90b408 template"><td class="memItemLeft">std::ostream &amp;&#160;</td><td class="memItemRight"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="structjh_1_1pod_1_1pair.html">jh::pod::pair</a>&lt; T1, T2 &gt; &amp;t)</td></tr>
<tr class="memitem:abf0332bf7a16c71fe6ca3c6f321bc123" id="r_abf0332bf7a16c71fe6ca3c6f321bc123"><td class="memTemplParams" colspan="2"><a id="abf0332bf7a16c71fe6ca3c6f321bc123" name="abf0332bf7a16c71fe6ca3c6f321bc123"></a>
template&lt;streamable T&gt; </td></tr>
<tr class="memitem:abf0332bf7a16c71fe6ca3c6f321bc123 template"><td class="memItemLeft">std::ostream &amp;&#160;</td><td class="memItemRight"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="structjh_1_1pod_1_1optional.html">jh::pod::optional</a>&lt; T &gt; &amp;opt)</td></tr>
<tr class="memitem:a42570093fba78fa5d75b2bc3ae434969" id="r_a42570093fba78fa5d75b2bc3ae434969"><td class="memTemplParams" colspan="2"><a id="a42570093fba78fa5d75b2bc3ae434969" name="a42570093fba78fa5d75b2bc3ae434969"></a>
template&lt;std::uint16_t N&gt; </td></tr>
<tr class="memitem:a42570093fba78fa5d75b2bc3ae434969 template"><td class="memItemLeft">std::ostream &amp;&#160;</td><td class="memItemRight"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="structjh_1_1pod_1_1bitflags.html">jh::pod::bitflags</a>&lt; N &gt; &amp;flags)</td></tr>
<tr class="memitem:a07a7b48d6eb8d4871e9cffa6d0a4d8de" id="r_a07a7b48d6eb8d4871e9cffa6d0a4d8de"><td class="memItemLeft"><a id="a07a7b48d6eb8d4871e9cffa6d0a4d8de" name="a07a7b48d6eb8d4871e9cffa6d0a4d8de"></a>
std::ostream &amp;&#160;</td><td class="memItemRight"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="structjh_1_1pod_1_1bytes__view.html">jh::pod::bytes_view</a> bv)</td></tr>
<tr class="memitem:a190b1c6890f097ff4002d4d8626ada46" id="r_a190b1c6890f097ff4002d4d8626ada46"><td class="memTemplParams" colspan="2"><a id="a190b1c6890f097ff4002d4d8626ada46" name="a190b1c6890f097ff4002d4d8626ada46"></a>
template&lt;streamable T&gt; </td></tr>
<tr class="memitem:a190b1c6890f097ff4002d4d8626ada46 template"><td class="memItemLeft">std::ostream &amp;&#160;</td><td class="memItemRight"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="structjh_1_1pod_1_1span.html">span</a>&lt; T &gt; &amp;sp)</td></tr>
<tr class="memitem:a3a8db647b63ea906b49d605ec04dbb86" id="r_a3a8db647b63ea906b49d605ec04dbb86"><td class="memItemLeft"><a id="a3a8db647b63ea906b49d605ec04dbb86" name="a3a8db647b63ea906b49d605ec04dbb86"></a>
std::ostream &amp;&#160;</td><td class="memItemRight"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="structjh_1_1pod_1_1string__view.html">string_view</a> &amp;sv)</td></tr>
<tr class="memitem:a55641af4ddc430236667930018451022" id="r_a55641af4ddc430236667930018451022"><td class="memTemplParams" colspan="2"><a id="a55641af4ddc430236667930018451022" name="a55641af4ddc430236667930018451022"></a>
template&lt;streamable_pod Pod&gt; </td></tr>
<tr class="memitem:a55641af4ddc430236667930018451022 template"><td class="memItemLeft">std::string&#160;</td><td class="memItemRight"><b>to_string</b> (const Pod &amp;p)</td></tr>
<tr class="memitem:aaee9d1c09b00f63f746d25c8b8099488" id="r_aaee9d1c09b00f63f746d25c8b8099488"><td class="memTemplParams" colspan="2"><a id="aaee9d1c09b00f63f746d25c8b8099488" name="aaee9d1c09b00f63f746d25c8b8099488"></a>
template&lt;streamable... Ts&gt; </td></tr>
<tr class="memitem:aaee9d1c09b00f63f746d25c8b8099488 template"><td class="memItemLeft">std::ostream &amp;&#160;</td><td class="memItemRight"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="structjh_1_1pod_1_1tuple.html">jh::pod::tuple</a>&lt; Ts... &gt; &amp;t)</td></tr>
<tr class="memitem:ae1bd6e506220f11404194937e2be1cce" id="r_ae1bd6e506220f11404194937e2be1cce"><td class="memTemplParams" colspan="2"><a id="ae1bd6e506220f11404194937e2be1cce" name="ae1bd6e506220f11404194937e2be1cce"></a>
template&lt;std::size_t I, typename... Ts&gt; </td></tr>
<tr class="memitem:ae1bd6e506220f11404194937e2be1cce template"><td class="memItemLeft">constexpr decltype(auto)&#160;</td><td class="memItemRight"><b>get</b> (<a class="el" href="structjh_1_1pod_1_1tuple.html">tuple</a>&lt; Ts... &gt; &amp;t) noexcept</td></tr>
<tr class="memitem:a2c842a88452f24dd8d08839a2405f368" id="r_a2c842a88452f24dd8d08839a2405f368"><td class="memTemplParams" colspan="2"><a id="a2c842a88452f24dd8d08839a2405f368" name="a2c842a88452f24dd8d08839a2405f368"></a>
template&lt;std::size_t I, typename... Ts&gt; </td></tr>
<tr class="memitem:a2c842a88452f24dd8d08839a2405f368 template"><td class="memItemLeft">constexpr auto&#160;</td><td class="memItemRight"><b>get</b> (const <a class="el" href="structjh_1_1pod_1_1tuple.html">tuple</a>&lt; Ts... &gt; &amp;t) noexcept</td></tr>
<tr class="memitem:abf3360f159d9d476d3096d51599cce69" id="r_abf3360f159d9d476d3096d51599cce69"><td class="memTemplParams" colspan="2"><a id="abf3360f159d9d476d3096d51599cce69" name="abf3360f159d9d476d3096d51599cce69"></a>
template&lt;std::size_t I, typename T1, typename T2&gt; </td></tr>
<tr class="memitem:abf3360f159d9d476d3096d51599cce69 template"><td class="memItemLeft">constexpr decltype(auto)&#160;</td><td class="memItemRight"><b>get</b> (<a class="el" href="structjh_1_1pod_1_1pair.html">jh::pod::pair</a>&lt; T1, T2 &gt; &amp;p) noexcept</td></tr>
<tr class="memitem:affeb6a5b6a13a9f06730906d72b561cf" id="r_affeb6a5b6a13a9f06730906d72b561cf"><td class="memTemplParams" colspan="2"><a id="affeb6a5b6a13a9f06730906d72b561cf" name="affeb6a5b6a13a9f06730906d72b561cf"></a>
template&lt;std::size_t I, typename T1, typename T2&gt; </td></tr>
<tr class="memitem:affeb6a5b6a13a9f06730906d72b561cf template"><td class="memItemLeft">constexpr decltype(auto)&#160;</td><td class="memItemRight"><b>get</b> (const <a class="el" href="structjh_1_1pod_1_1pair.html">jh::pod::pair</a>&lt; T1, T2 &gt; &amp;p) noexcept</td></tr>
<tr class="memitem:ac623c9763124cea99b74690cf5c4ff07" id="r_ac623c9763124cea99b74690cf5c4ff07"><td class="memTemplParams" colspan="2"><a id="ac623c9763124cea99b74690cf5c4ff07" name="ac623c9763124cea99b74690cf5c4ff07"></a>
template&lt;std::size_t I, typename T, std::uint16_t N&gt; </td></tr>
<tr class="memitem:ac623c9763124cea99b74690cf5c4ff07 template"><td class="memItemLeft">constexpr decltype(auto)&#160;</td><td class="memItemRight"><b>get</b> (<a class="el" href="structjh_1_1pod_1_1array.html">jh::pod::array</a>&lt; T, N &gt; &amp;a) noexcept</td></tr>
<tr class="memitem:a6408a3a12eb5e743d20ea9d51c34a7c9" id="r_a6408a3a12eb5e743d20ea9d51c34a7c9"><td class="memTemplParams" colspan="2"><a id="a6408a3a12eb5e743d20ea9d51c34a7c9" name="a6408a3a12eb5e743d20ea9d51c34a7c9"></a>
template&lt;std::size_t I, typename T, std::uint16_t N&gt; </td></tr>
<tr class="memitem:a6408a3a12eb5e743d20ea9d51c34a7c9 template"><td class="memItemLeft">constexpr decltype(auto)&#160;</td><td class="memItemRight"><b>get</b> (const <a class="el" href="structjh_1_1pod_1_1array.html">jh::pod::array</a>&lt; T, N &gt; &amp;a) noexcept</td></tr>
<tr class="memitem:a9feeff694ec7515b0c23c78aa7ada0f4" id="r_a9feeff694ec7515b0c23c78aa7ada0f4"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:a9feeff694ec7515b0c23c78aa7ada0f4 template"><td class="memItemLeft">constexpr auto&#160;</td><td class="memItemRight"><a class="el" href="#a9feeff694ec7515b0c23c78aa7ada0f4">make_tuple</a> (Ts &amp;&amp;... args) noexcept</td></tr>
<tr class="memdesc:a9feeff694ec7515b0c23c78aa7ada0f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a POD-compatible tuple from given arguments.  <br /></td></tr>
<tr class="memitem:a72c322f015f289981d0fb6afcf46b7aa" id="r_a72c322f015f289981d0fb6afcf46b7aa"><td class="memTemplParams" colspan="2"><a id="a72c322f015f289981d0fb6afcf46b7aa" name="a72c322f015f289981d0fb6afcf46b7aa"></a>
template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:a72c322f015f289981d0fb6afcf46b7aa template"><td class="memItemLeft">constexpr bool&#160;</td><td class="memItemRight"><b>operator==</b> (const <a class="el" href="structjh_1_1pod_1_1tuple.html">tuple</a>&lt; Ts... &gt; &amp;lhs, const <a class="el" href="structjh_1_1pod_1_1tuple.html">tuple</a>&lt; Ts... &gt; &amp;rhs) noexcept</td></tr>
<tr class="memitem:ab9e38a6121efa1d1b0ecf1ce98839ebf" id="r_ab9e38a6121efa1d1b0ecf1ce98839ebf"><td class="memTemplParams" colspan="2"><a id="ab9e38a6121efa1d1b0ecf1ce98839ebf" name="ab9e38a6121efa1d1b0ecf1ce98839ebf"></a>
template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:ab9e38a6121efa1d1b0ecf1ce98839ebf template"><td class="memItemLeft">constexpr bool&#160;</td><td class="memItemRight"><b>operator!=</b> (const <a class="el" href="structjh_1_1pod_1_1tuple.html">tuple</a>&lt; Ts... &gt; &amp;lhs, const <a class="el" href="structjh_1_1pod_1_1tuple.html">tuple</a>&lt; Ts... &gt; &amp;rhs) noexcept</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-var-members" class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:aca802e7cca57b1c34f4d4877c914d035" id="r_aca802e7cca57b1c34f4d4877c914d035"><td class="memItemLeft"><a id="aca802e7cca57b1c34f4d4877c914d035" name="aca802e7cca57b1c34f4d4877c914d035"></a>
constexpr std::uint16_t&#160;</td><td class="memItemRight"><b>max_pod_array_bytes</b> = 16 * 1024</td></tr>
<tr class="memdesc:aca802e7cca57b1c34f4d4877c914d035"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum size of a POD array (16KB). This is a compile-time constant. <br /></td></tr>
<tr class="memitem:a8721ba190c9c5f34c6d5a07381547fec" id="r_a8721ba190c9c5f34c6d5a07381547fec"><td class="memItemLeft"><a id="a8721ba190c9c5f34c6d5a07381547fec" name="a8721ba190c9c5f34c6d5a07381547fec"></a>
constexpr std::uint16_t&#160;</td><td class="memItemRight"><b>max_pod_bitflags_bytes</b> = 4 * 1024</td></tr>
<tr class="memdesc:a8721ba190c9c5f34c6d5a07381547fec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum allowed size of a POD bitflags structure: 4KB (4096 bytes). <br /></td></tr>
<tr class="memitem:a8d3a506649b370b47953d790bd66edb6" id="r_a8d3a506649b370b47953d790bd66edb6"><td class="memTemplParams" colspan="2"><a id="a8d3a506649b370b47953d790bd66edb6" name="a8d3a506649b370b47953d790bd66edb6"></a>
template&lt;std::uint16_t N&gt; </td></tr>
<tr class="memitem:a8d3a506649b370b47953d790bd66edb6 template"><td class="memItemLeft">constexpr bool&#160;</td><td class="memItemRight"><b>is_native_bitflags</b> = N == 8 || N == 16 || N == 32 || N == 64</td></tr>
</table>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="a7f2c0f4dbc28504d1eea591a1b86b8b3" name="a7f2c0f4dbc28504d1eea591a1b86b8b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f2c0f4dbc28504d1eea591a1b86b8b3">&#9670;&#160;</a></span>bytes_to_uint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::uint16_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto jh::pod::bytes_to_uint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structjh_1_1pod_1_1array.html">array</a>&lt; std::uint8_t, N &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>arr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a little-endian byte array into an unsigned integer. </p>
<dl class="section note"><dt>Note</dt><dd>Only valid for native sizes: 1, 2, 4, 8 bytes.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>Byte count. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>Input array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Corresponding unsigned integer of size N * 8. </dd></dl>

</div>
</div>
<a id="aa66f1d237ccedf73ed484408b86a48af" name="aa66f1d237ccedf73ed484408b86a48af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa66f1d237ccedf73ed484408b86a48af">&#9670;&#160;</a></span>from_bytes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::uint16_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structjh_1_1pod_1_1bitflags.html">bitflags</a>&lt; N &gt; jh::pod::from_bytes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structjh_1_1pod_1_1array.html">array</a>&lt; std::uint8_t, N/8 &gt;</td>          <td class="paramname"><span class="paramname"><em>arr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deserialize a <code><a class="el" href="structjh_1_1pod_1_1bitflags.html" title="POD-compatible fixed-size bitflags structure.Generic fallback specialization for non-native sizes (e....">bitflags&lt;N&gt;</a></code> from a byte array (snapshot). </p>
<dl class="section note"><dt>Note</dt><dd>Only the array's raw content is used. No semantic validation is performed. </dd></dl>

</div>
</div>
<a id="a718067e095218525842cfbed6ec96676" name="a718067e095218525842cfbed6ec96676"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a718067e095218525842cfbed6ec96676">&#9670;&#160;</a></span>make_optional()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;pod_like T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structjh_1_1pod_1_1optional.html">optional</a>&lt; T &gt; jh::pod::make_optional </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an <code><a class="el" href="structjh_1_1pod_1_1optional.html" title="POD-compatible optional wrapper.">optional&lt;T&gt;</a></code> with a value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Value to copy into optional. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Filled <code><a class="el" href="structjh_1_1pod_1_1optional.html" title="POD-compatible optional wrapper.">optional&lt;T&gt;</a></code> with <code>.has() == true</code>. </dd></dl>

</div>
</div>
<a id="a6bba6c453485cf29669db16b9612291d" name="a6bba6c453485cf29669db16b9612291d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bba6c453485cf29669db16b9612291d">&#9670;&#160;</a></span>make_pair()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;cv_free_pod_like T1, cv_free_pod_like T2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto jh::pod::make_pair </td>
          <td>(</td>
          <td class="paramtype">T1</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2</td>          <td class="paramname"><span class="paramname"><em>second</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a POD-compatible pair from two values. </p>
<p>This function aligns with <code>std::make_pair</code> for interface consistency. It performs no special handling beyond aggregate initialization and exists solely to provide a familiar, STL-compatible API name.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>Type of the first element. </td></tr>
    <tr><td class="paramname">T2</td><td>Type of the second element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>First element value. </td></tr>
    <tr><td class="paramname">second</td><td>Second element value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="structjh_1_1pod_1_1pair.html" title="POD-compatible aggregate of two values, equivalent in layout to a plain struct.">jh::pod::pair&lt;T1, T2&gt;</a></code> containing the given elements.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structjh_1_1pod_1_1pair.html" title="POD-compatible aggregate of two values, equivalent in layout to a plain struct.">jh::pod::pair</a> </dd></dl>

</div>
</div>
<a id="a9feeff694ec7515b0c23c78aa7ada0f4" name="a9feeff694ec7515b0c23c78aa7ada0f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9feeff694ec7515b0c23c78aa7ada0f4">&#9670;&#160;</a></span>make_tuple()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto jh::pod::make_tuple </td>
          <td>(</td>
          <td class="paramtype">Ts &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a POD-compatible tuple from given arguments. </p>
<p>This is the general-purpose tuple construction interface aligned with <code>std::make_tuple</code>, but restricted to POD-compatible types. Each element is assigned by index, ensuring consistent aggregate initialization semantics across compilers.</p>
<ul>
<li>
Portable alternative to direct brace initialization </li>
<li>
Preserves POD guarantees of <code><a class="el" href="structjh_1_1pod_1_1tuple.html" title="POD-compatible tuple type supporting structured bindings and tuple-like utilities.">jh::pod::tuple</a></code> </li>
<li>
Automatically decays arguments to their underlying types </li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Arrays and string literals decay to pointers when passed by value. To preserve the complete POD content and avoid type decay, wrap them explicitly with <code><a class="el" href="structjh_1_1pod_1_1array.html" title="POD-compatible fixed-size array, similar in shape to std::array, but simpler and fully POD.">jh::pod::array&lt;T, N&gt;</a></code> or <code><a class="el" href="structjh_1_1pod_1_1array.html">jh::pod::array&lt;char, N&gt;</a></code> when constructing tuples.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Ts</td><td>Variadic list of POD-compatible argument types. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>The values to store in the tuple. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="structjh_1_1pod_1_1tuple.html" title="POD-compatible tuple type supporting structured bindings and tuple-like utilities.">jh::pod::tuple</a></code> containing the given values.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structjh_1_1pod_1_1tuple.html" title="POD-compatible tuple type supporting structured bindings and tuple-like utilities.">jh::pod::tuple</a> </dd></dl>

</div>
</div>
<a id="a6d1f8391a51ac87a4d482400fea14800" name="a6d1f8391a51ac87a4d482400fea14800"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d1f8391a51ac87a4d482400fea14800">&#9670;&#160;</a></span>to_bytes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::uint16_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structjh_1_1pod_1_1array.html">array</a>&lt; std::uint8_t, N/8 &gt; jh::pod::to_bytes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structjh_1_1pod_1_1bitflags.html">bitflags</a>&lt; N &gt;</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serialize a <code><a class="el" href="structjh_1_1pod_1_1bitflags.html" title="POD-compatible fixed-size bitflags structure.Generic fallback specialization for non-native sizes (e....">bitflags&lt;N&gt;</a></code> into a little-endian byte array (snapshot). </p>
<dl class="section note"><dt>Note</dt><dd>The output is always little-endian, regardless of host architecture. </dd></dl>

</div>
</div>
<a id="abb8f4c57e0f9a07020a1db4a5bee1169" name="abb8f4c57e0f9a07020a1db4a5bee1169"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb8f4c57e0f9a07020a1db4a5bee1169">&#9670;&#160;</a></span>to_span()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;detail::linear_container C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto jh::pod::to_span </td>
          <td>(</td>
          <td class="paramtype">C &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a POD-compatible <code>span</code> from a linear container. </p>
<p>This function constructs a <code><a class="el" href="structjh_1_1pod_1_1span.html" title="Non-owning typed view over a contiguous memory block.">span&lt;T&gt;</a></code> that references the contiguous data region of a container <code>C</code>. The access method (field, member function, or ADL helper) is determined at compile time according to the precomputed <code>linear_status&lt;C&gt;</code>. </p>
<h4>Design Rationale</h4>
<p>Accessor detection follows a fixed precedence: <br  />
<b>ADL</b> (<code>get_data()</code>, <code>get_size()</code>) → <b>field</b> (<code>data</code>, <code>len</code>) → <b>member function</b> (<code>data()</code>, <code>size()</code>). <br  />
 This allows users to explicitly provide ADL overloads to override internal members when the container layout is not standard or may be misleading. </p>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>
<code>data</code> and <code>data()</code> are mutually exclusive — defining both is undefined behavior. </li>
<li>
<code>len</code> and <code>size()</code> may coexist, but they are expected to report identical lengths. </li>
<li>
If your container exposes inconsistent or unexpected accessors, you can define <code>my_ns::get_size(my_ns::MyContainer)</code> or <code>get_data()</code> via ADL to override detection. </li>
<li>
If even ADL overrides cannot match your intended semantics, do not use this helper — manually construct <code>span{ptr, len}</code> instead. </li>
<li>
This is a syntactic convenience, not a semantic requirement. </li>
</ul>
</dd></dl>
<h4>Return Value</h4>
<p>Returns a non-owning <code><a class="el" href="structjh_1_1pod_1_1span.html" title="Non-owning typed view over a contiguous memory block.">span&lt;Elem&gt;</a></code> referencing the same contiguous memory as the source container. </p>

</div>
</div>
<a id="af93796d595c10e036e1637ff7e89b8eb" name="af93796d595c10e036e1637ff7e89b8eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af93796d595c10e036e1637ff7e89b8eb">&#9670;&#160;</a></span>uint_to_bytes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std_uint UInt&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto jh::pod::uint_to_bytes </td>
          <td>(</td>
          <td class="paramtype">const UInt</td>          <td class="paramname"><span class="paramname"><em>val</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert an unsigned integer into a little-endian byte array. </p>
<dl class="section note"><dt>Note</dt><dd>Always <span class="tt">little-endian</span>, regardless of platform endianness.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">UInt</td><td>Must be one of: <span class="tt">uint8_t</span>, <span class="tt">uint16_t</span>, <span class="tt">uint32_t</span>, <span class="tt">uint64_t</span>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The input value to encode. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code><a class="el" href="structjh_1_1pod_1_1array.html" title="POD-compatible fixed-size array, similar in shape to std::array, but simpler and fully POD.">array&lt;uint8_t, sizeof(UInt)&gt;</a></code> encoded in little-endian order. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
</div> <!-- top -->
<hr class="footer"/>
<div class="footer">
    <img class="footer-logo" src="Ojing.svg" alt="Ojing"/>
    <div class="footer-text">
        JH-Toolkit v1.4.0 · Generated by Doxygen
    </div>
    <div class="footer-note">
        We primarily support embedded documentation views in IDEs (classic CLion).
        To ensure compatibility with embedded rendering, some example code in this
        documentation intentionally contains HTML entities.
        In certain cases, Doxygen does not unescape these entities correctly.
        This is a known limitation and currently has no workaround.
    </div>
</div>
</body>
</html>
