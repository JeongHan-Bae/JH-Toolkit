<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.16.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>JH-Toolkit: include/jh/metax/adl_apply.h File Reference</title>
<link rel="icon" href="Jindallae.svg" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="Oree.svg"/></td>
  <td id="projectalign">
   <div id="projectname">JH-Toolkit<span id="projectnumber">&#160;v1.4.0</span>
   </div>
   <div id="projectbrief">An engineering-oriented C++20 toolkit with duck-typed concepts, static design, async coroutines, and semantic containers — header-only, RTTI-free, and concurrency-friendly.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.16.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('adl__apply_8h.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">adl_apply.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>ADL-enabled universal tuple application utility — extends <code>std::apply</code> to arbitrary tuple-like structures, including user-defined proxies and view elements.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="">jh/conceptual/tuple_like.h</a>&quot;</code><br />
<code>#include &lt;functional&gt;</code><br />
<code>#include &lt;tuple&gt;</code><br />
<code>#include &lt;utility&gt;</code><br />
<code>#include &lt;type_traits&gt;</code><br />
</div>
<p><a href="">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a0cef302115e1455eeb8d86afa4e0e9c9" id="r_a0cef302115e1455eeb8d86afa4e0e9c9"><td class="memTemplParams" colspan="2">template&lt;class F, class T, size_t... I&gt; </td></tr>
<tr class="memitem:a0cef302115e1455eeb8d86afa4e0e9c9 template"><td class="memItemLeft">constexpr decltype(auto)&#160;</td><td class="memItemRight"><a class="el" href="namespacejh_1_1meta.html#a0cef302115e1455eeb8d86afa4e0e9c9">jh::meta::adl_apply_impl</a> (F &amp;&amp;f, T &amp;&amp;t, std::index_sequence&lt; I... &gt;)</td></tr>
<tr class="memdesc:a0cef302115e1455eeb8d86afa4e0e9c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal implementation helper for <code><a class="el" href="namespacejh_1_1meta.html#a5e3294b6489e7e73d1c0b040b9dbbc86" title="ADL-enabled universal apply for tuple-like objects.">jh::meta::adl_apply</a></code>.  <br /></td></tr>
<tr class="memitem:a5e3294b6489e7e73d1c0b040b9dbbc86" id="r_a5e3294b6489e7e73d1c0b040b9dbbc86"><td class="memTemplParams" colspan="2">template&lt;class F, <a class="el" href="conceptjh_1_1concepts_1_1tuple__like.html">jh::concepts::tuple_like</a> T&gt; </td></tr>
<tr class="memitem:a5e3294b6489e7e73d1c0b040b9dbbc86 template"><td class="memItemLeft">constexpr decltype(auto)&#160;</td><td class="memItemRight"><a class="el" href="namespacejh_1_1meta.html#a5e3294b6489e7e73d1c0b040b9dbbc86">jh::meta::adl_apply</a> (F &amp;&amp;f, T &amp;&amp;t) noexcept(noexcept(<a class="el" href="namespacejh_1_1meta.html#a0cef302115e1455eeb8d86afa4e0e9c9">adl_apply_impl</a>(std::forward&lt; F &gt;(f), std::forward&lt; T &gt;(t), std::make_index_sequence&lt; std::tuple_size_v&lt; std::remove_cvref_t&lt; T &gt; &gt; &gt;{})))</td></tr>
<tr class="memdesc:a5e3294b6489e7e73d1c0b040b9dbbc86"><td class="mdescLeft">&#160;</td><td class="mdescRight">ADL-enabled universal apply for tuple-like objects.  <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><p>ADL-enabled universal tuple application utility — extends <code>std::apply</code> to arbitrary tuple-like structures, including user-defined proxies and view elements. </p>
<dl class="section copyright"><dt>Copyright</dt><dd>Copyright 2025 JeongHan-Bae &lt;mastropseudo@gmail.com&gt; <br  />
 Licensed under the Apache License, Version 2.0 (the "License"); <br  />
 you may not use this file except in compliance with the License.<br  />
 You may obtain a copy of the License at<br  />
 <br  />
 <a href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a><br  />
 <br  />
 Unless required by applicable law or agreed to in writing, software<br  />
 distributed under the License is distributed on an "AS IS" BASIS,<br  />
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.<br  />
 See the License for the specific language governing permissions and<br  />
 limitations under the License.<br  />
 <br  />
 Full license: <a href="https://github.com/JeongHan-Bae/JH-Toolkit?tab=Apache-2.0-1-ov-file#readme">GitHub</a></dd></dl>
<dl class="section author"><dt>Author</dt><dd>JeongHan-Bae <a href="#" onclick="location.href='mai'+'lto:'+'mas'+'tr'+'ops'+'eu'+'do@'+'gm'+'ail'+'.c'+'om'; return false;">mastr<span class="obfuscator">.nosp@m.</span>opse<span class="obfuscator">.nosp@m.</span>udo@g<span class="obfuscator">.nosp@m.</span>mail<span class="obfuscator">.nosp@m.</span>.com</a></dd></dl>
<p>The <code><a class="el" href="namespacejh_1_1meta.html#a5e3294b6489e7e73d1c0b040b9dbbc86" title="ADL-enabled universal apply for tuple-like objects.">jh::meta::adl_apply</a></code> function is a generalized alternative to <code>std::apply</code> that allows invocation of callables on both standard and user-defined <em>tuple-like</em> objects. It performs unqualified lookup for <code>get<em> to enable
Argument-Dependent Lookup (ADL), thereby extending support beyond the
standard tuple family.
</em></code></p>
<p><code><em></em></code></p>
<p><code><em></p><h3>Motivation</h3>
<p></em></code></p>
<p><code><em>
</em></code></p>
<p><code><em>
The C++ standard restricts <code>std::apply</code> to built-in tuple-like types (<code>std::tuple</code>, <code>std::pair</code>, <code>std::array</code>), because <code>std::apply</code> directly calls <code>std::get<em>.
However:
</em></code></em></code></p>
<p><code><em><code><em>
</p><ul>
<li>
User-defined <code>get<em> functions cannot reside in <code>std</code> namespace; </em></code></li>
<li>
<code><em><code>std::get</code> cannot be specialized for non-standard types; </em></code></li>
<li>
<code><em>C++ nevertheless permits defining <code>tuple_size</code> and <code>tuple_element</code> for custom structures; </em></code></li>
<li>
<code><em>Thus, a large class of <em>tuple-like proxies</em> (e.g., <code>jh::ranges::zip_reference_view</code> supporting <code><a class="el" href="classjh_1_1ranges_1_1zip__view.html" title="A C++20-compatible implementation of std::ranges::zip_view.">jh::ranges::zip_view</a></code>) as well as a lot of third-party defined tuple-like proxies cannot work with <code>std::apply</code>. </em></code></li>
</ul>
<p></em></code></em></code></p>
<p><code><em><code><em><code><em></em></code></em></code></em></code></p>
<p><code><em><code><em><code><em>
<code><a class="el" href="namespacejh_1_1meta.html#a5e3294b6489e7e73d1c0b040b9dbbc86" title="ADL-enabled universal apply for tuple-like objects.">jh::meta::adl_apply</a></code> bridges this semantic gap by employing unqualified <code>get<em> calls, so both standard and ADL-visible
overloads participate in lookup. It effectively becomes a
<b>universal apply</b> for all tuple-like types.
</em></code></em></code></em></code></em></code></p>
<p><code><em><code><em><code><em><code><em></em></code></em></code></em></code></em></code></p>
<p><code><em><code><em><code><em><code><em></p><h3>Supported types</h3>
<p></em></code></em></code></em></code></em></code></p>
<p><code><em><code><em><code><em><code><em>
</p><ul>
<li>
<b>Standard tuple-likes:</b> <code>std::tuple</code>, <code>std::pair</code>, <code>std::array</code>. </li>
<li>
<b>User-defined tuple-likes:</b> types modeling <code><a class="el" href="conceptjh_1_1concepts_1_1tuple__like.html" title="Concept recognizing tuple-like types.">jh::concepts::tuple_like</a></code> (i.e., define <code>tuple_size</code> / <code>tuple_element</code> and expose ADL-visible <code>get<em>).
  </em></code></li>
<li>
<code><em><b>Proxy-based ranges:</b> view elements such as
      <code>jh::ranges::zip_reference_view</code>. </em></code></li>
</ul>
<p></em></code></em></code></em></code></em></code></p>
<p><code><em><code><em><code><em><code><em><code><em></p><h3>Usage example</h3>
<p></em></code></em></code></em></code></em></code></em></code></p>
<p><code><em><code><em><code><em><code><em><code><em>
</p><div class="fragment"><div class="line"><span class="keyword">namespace </span>demo {</div>
<div class="line">  <span class="keyword">struct </span>proxy { <span class="keywordtype">int</span> i; <span class="keywordtype">double</span> d; };</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Define ADL-visible get&lt;I&gt; overloads</span></div>
<div class="line">  <span class="keyword">template</span>&lt;std::<span class="keywordtype">size_t</span> I&gt;</div>
<div class="line">  <span class="keyword">decltype</span>(<span class="keyword">auto</span>) get(proxy &amp;p) <span class="keyword">noexcept</span> {</div>
<div class="line">    <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (I == 0) <span class="keywordflow">return</span> (p.i);</div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">return</span> (p.d);</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span><a class="code hl_namespace" href="namespacestd.html">std</a> {</div>
<div class="line">  <span class="keyword">template</span>&lt;&gt;</div>
<div class="line">  <span class="keyword">struct </span>std::tuple_size&lt;proxy&gt; : std::integral_constant&lt;size_t, 2&gt; {};</div>
<div class="line">  <span class="keyword">template</span>&lt;<span class="keywordtype">size_t</span> I&gt;</div>
<div class="line">  <span class="keyword">struct </span>std::tuple_element&lt;I, proxy&gt; {</div>
<div class="line">    <span class="keyword">using </span>type = std::conditional_t&lt;I == 0, int, double&gt;;</div>
<div class="line">  };</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">demo::proxy p{1, 3.14};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Works for both std and ADL get&lt;I&gt;</span></div>
<div class="line"><a class="code hl_function" href="namespacejh_1_1meta.html#a5e3294b6489e7e73d1c0b040b9dbbc86">jh::meta::adl_apply</a>([](<span class="keyword">auto</span> &amp;&amp;x, <span class="keyword">auto</span> &amp;&amp;y) {</div>
<div class="line">  std::cout &lt;&lt; x &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; y &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="line">}, p);</div>
<div class="ttc" id="anamespacejh_1_1meta_html_a5e3294b6489e7e73d1c0b040b9dbbc86"><div class="ttname"><a href="namespacejh_1_1meta.html#a5e3294b6489e7e73d1c0b040b9dbbc86">jh::meta::adl_apply</a></div><div class="ttdeci">constexpr decltype(auto) adl_apply(F &amp;&amp;f, T &amp;&amp;t) noexcept(noexcept(adl_apply_impl(std::forward&lt; F &gt;(f), std::forward&lt; T &gt;(t), std::make_index_sequence&lt; std::tuple_size_v&lt; std::remove_cvref_t&lt; T &gt; &gt; &gt;{})))</div><div class="ttdoc">ADL-enabled universal apply for tuple-like objects.</div><div class="ttdef"><b>Definition</b> adl_apply.h:218</div></div>
<div class="ttc" id="anamespacestd_html"><div class="ttname"><a href="namespacestd.html">std</a></div><div class="ttdef"><b>Definition</b> flatten_proxy.h:180</div></div>
</div><!-- fragment --><p></em></code></em></code></em></code></em></code></em></code></p>
<p><code><em><code><em><code><em><code><em><code><em></p><h3>Behavior summary</h3>
<p></em></code></em></code></em></code></em></code></em></code></p>
<p><code><em><code><em><code><em><code><em><code><em>
</p><ul>
<li>
Performs unqualified lookup for <code>get<em> — enabling ADL discovery.
  </em></code></li>
<li>
<code><em>Expands index sequence from <code>std::tuple_size_v&lt;T&gt;</code>. </em></code></li>
<li>
<code><em>Perfect-forwards both callable and tuple object.
  </em></code></li>
<li>
<code><em>Propagates <code>noexcept</code> and <code>constexpr</code> guarantees. </em></code></li>
</ul>
<p></em></code></em></code></em></code></em></code></em></code></p>
<p><code><em><code><em><code><em><code><em><code><em><code><em></p><h3>Integration example (with collect)</h3>
<p></em></code></em></code></em></code></em></code></em></code></em></code></p>
<p><code><em><code><em><code><em><code><em><code><em><code><em>
</p><div class="fragment"><div class="line"><span class="keyword">auto</span> result = range</div>
<div class="line">  | <a class="code hl_variable" href="namespacejh_1_1ranges_1_1views.html#ad8bed1059cdf6c1295582749bd03983c">jh::ranges::views::enumerate</a>()</div>
<div class="line">  | <a class="code hl_variable" href="namespacejh_1_1ranges.html#ae066e3cad87b5bec3c061fc290e8ad73">jh::ranges::collect&lt;std::vector&lt;std::pair&lt;size_t, std::string&gt;</a>&gt;&gt;();</div>
<div class="ttc" id="anamespacejh_1_1ranges_1_1views_html_ad8bed1059cdf6c1295582749bd03983c"><div class="ttname"><a href="namespacejh_1_1ranges_1_1views.html#ad8bed1059cdf6c1295582749bd03983c">jh::ranges::views::enumerate</a></div><div class="ttdeci">constexpr detail::enumerate_fn enumerate</div><div class="ttdoc">The user-facing enumerate adaptor.</div><div class="ttdef"><b>Definition</b> enumerate.h:149</div></div>
<div class="ttc" id="anamespacejh_1_1ranges_html_ae066e3cad87b5bec3c061fc290e8ad73"><div class="ttname"><a href="namespacejh_1_1ranges.html#ae066e3cad87b5bec3c061fc290e8ad73">jh::ranges::collect</a></div><div class="ttdeci">constexpr collect_fn&lt; C &gt; collect</div><div class="ttdoc">Global instance of the collect adaptor.</div><div class="ttdef"><b>Definition</b> collect.h:375</div></div>
</div><!-- fragment --><p></em></code></em></code></em></code></em></code></em></code></em></code></p>
<p><code><em><code><em><code><em><code><em><code><em><code><em></em></code></em></code></em></code></em></code></em></code></em></code></p>
<p><code><em><code><em><code><em><code><em><code><em><code><em>
In this example, <code>enumerate()</code> yields a tuple-like proxy containing an index and reference. <code>collect</code> internally employs <code><a class="el" href="namespacejh_1_1meta.html#a5e3294b6489e7e73d1c0b040b9dbbc86" title="ADL-enabled universal apply for tuple-like objects.">jh::meta::adl_apply</a></code> to unpack the proxy into actual <code>std::pair&lt;size_t, std::string&gt;</code> values via <code>emplace_back()</code>. </em></code></em></code></em></code></em></code></em></code></em></code></p>
<p><code><em><code><em><code><em><code><em><code><em><code><em></em></code></em></code></em></code></em></code></em></code></em></code></p>
<p><code><em><code><em><code><em><code><em><code><em><code><em></p><h3>Design rationale</h3>
<p></em></code></em></code></em></code></em></code></em></code></em></code></p>
<p><code><em><code><em><code><em><code><em><code><em><code><em>
</p><ul>
<li>
<b>Language conformance:</b> avoids illegal specialization of <code>std::get</code>. </li>
<li>
<b>ADL openness:</b> honors user-defined <code>get<em> functions.
  </em></code></li>
<li>
<code><em><b>Compile-time safety:</b> constrained by <code><a class="el" href="conceptjh_1_1concepts_1_1tuple__like.html" title="Concept recognizing tuple-like types.">jh::concepts::tuple_like</a></code>. </em></code></li>
<li>
<code><em><b>Zero-overhead abstraction:</b> identical assembly as <code>std::apply</code> for STL tuples. </em></code></li>
</ul>
<p></em></code></em></code></em></code></em></code></em></code></em></code></p>
<p><code><em><code><em><code><em><code><em><code><em><code><em><code><em></p><dl class="section see"><dt>See also</dt><dd><a class="el" href="conceptjh_1_1concepts_1_1tuple__like.html" title="Concept recognizing tuple-like types.">jh::concepts::tuple_like</a>
</dd>
<dd>
std::apply</dd></dl>
<dl class="section version"><dt>Version</dt><dd><pre>1.3.x</pre> </dd></dl>
<dl class="section date"><dt>Date</dt><dd><pre>2025</pre> </dd></dl>
<p></em></code></em></code></em></code></em></code></em></code></em></code></em></code></p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
</div> <!-- top -->
<hr class="footer"/>
<div class="footer">
    <img class="footer-logo" src="Ojing.svg" alt="Ojing"/>
    <div class="footer-text">
        JH-Toolkit v1.4.0 · Generated by Doxygen
    </div>
    <div class="footer-note">
        We primarily support embedded documentation views in IDEs (classic CLion).
        To ensure compatibility with embedded rendering, some example code in this
        documentation intentionally contains HTML entities.
        In certain cases, Doxygen does not unescape these entities correctly.
        This is a known limitation and currently has no workaround.
    </div>
</div>
</body>
</html>
