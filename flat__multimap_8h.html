<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.16.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>JH-Toolkit: include/jh/core/flat_multimap.h File Reference</title>
<link rel="icon" href="Jindallae.svg" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="Oree.svg"/></td>
  <td id="projectalign">
   <div id="projectname">JH-Toolkit<span id="projectnumber">&#160;v1.4.0</span>
   </div>
   <div id="projectbrief">An engineering-oriented C++20 toolkit with duck-typed concepts, static design, async coroutines, and semantic containers — header-only, RTTI-free, and concurrency-friendly.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.16.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('flat__multimap_8h.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">flat_multimap.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Flat ordered multimap container.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;vector&gt;</code><br />
<code>#include &lt;algorithm&gt;</code><br />
<code>#include &lt;memory&gt;</code><br />
<code>#include &lt;utility&gt;</code><br />
<code>#include &lt;type_traits&gt;</code><br />
<code>#include &lt;cstddef&gt;</code><br />
<code>#include &lt;stdexcept&gt;</code><br />
<code>#include &quot;<a class="el" href="">jh/conceptual/tuple_like.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="">jh/conceptual/container_traits.h</a>&quot;</code><br />
</div>
<p><a href="">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:jh_3A_3Aflat_5Fmultimap_3C_20K_2C_20V_2C_20Alloc_20_3E" id="r_jh_3A_3Aflat_5Fmultimap_3C_20K_2C_20V_2C_20Alloc_20_3E"><td class="memItemLeft">class &#160;</td><td class="memItemRight"><a class="el" href="classjh_1_1flat__multimap.html">jh::flat_multimap&lt; K, V, Alloc &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flat ordered multimap implemented as a sorted contiguous container.  <a href="classjh_1_1flat__multimap.html#details">More...</a><br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Flat ordered multimap container. </p>
<dl class="section copyright"><dt>Copyright</dt><dd>Copyright 2025 JeongHan-Bae &lt;mastropseudo@gmail.com&gt; <br  />
 Licensed under the Apache License, Version 2.0 (the "License"); <br  />
 you may not use this file except in compliance with the License.<br  />
 You may obtain a copy of the License at<br  />
 <br  />
 <a href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a><br  />
 <br  />
 Unless required by applicable law or agreed to in writing, software<br  />
 distributed under the License is distributed on an "AS IS" BASIS,<br  />
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.<br  />
 See the License for the specific language governing permissions and<br  />
 limitations under the License.<br  />
 <br  />
 Full license: <a href="https://github.com/JeongHan-Bae/JH-Toolkit?tab=Apache-2.0-1-ov-file#readme">GitHub</a></dd></dl>
<dl class="section author"><dt>Author</dt><dd>JeongHan-Bae <a href="#" onclick="location.href='mai'+'lto:'+'mas'+'tr'+'ops'+'eu'+'do@'+'gm'+'ail'+'.c'+'om'; return false;">&lt;mastropseudo@gmail.com&gt;</a></dd></dl>
<h3>Design Rationale — Why <code>flat_multimap</code> Exists</h3>
<p><code><a class="el" href="classjh_1_1flat__multimap.html" title="Flat ordered multimap implemented as a sorted contiguous container.">jh::flat_multimap&lt;K,V&gt;</a></code> is <b>not</b> an extension of <code>ordered_map</code> to support multiple values per key, nor is it a tree-based multimap variant. It exists to serve a <b>fundamentally different access pattern</b>. </p>
<p>In practical systems, a multimap is rarely used merely because "a key can have multiple values". Instead, the defining operations are: </p>
<ul>
<li>
efficient <b>range queries</b> for a single key (<code>equal_range</code>), </li>
<li>
batch processing of all values associated with a key, </li>
<li>
bulk erasure of all entries for a key (<code>erase(key)</code>). </li>
</ul>
<p>These operations are <b>structurally hostile</b> to tree-based containers that maintain balance via rotations. In a contiguous AVL tree, removing a range of equivalent keys would require repeated node removal, each potentially triggering rebalancing and rotations. The resulting cost is not only higher, but also less predictable. </p>
<p>For this reason, the <code>ordered_*</code> family deliberately does <b>not</b> provide bulk-erasure or multimap-style range deletion APIs. Their design goal is <b>stable, per-element operations</b> with bounded rebalancing cost — a goal that conflicts with multimap semantics. </p>
<h3>Flat Multimap: Turning an Algorithm into a Container</h3>
<p><code>flat_multimap</code> embraces a different principle: </p>
<blockquote class="doxtable">
<p><b>Store elements contiguously, keep them stably sorted by key, and express multimap semantics as range operations over a flat sequence.</b> </p>
</blockquote>
<p>Internally, the container is little more than a <code>std::vector&lt;std::pair&lt;K,V&gt;&gt;</code> maintained in sorted order. Multimap operations are implemented using binary search (<code>lower_bound</code>, <code>upper_bound</code>) and contiguous range operations on the underlying storage. </p>
<p>This effectively <b>packages the "sorted vector + binary search"; algorithm into a first-class container</b>, with explicit semantics for: </p>
<ul>
<li>
contiguous storage of equivalent keys, </li>
<li>
range-oriented lookup, </li>
<li>
batch erasure with a single compaction step. </li>
</ul>
<p>In workloads such as in-memory tables, indexing layers, routing maps, or subscription registries, this model aligns naturally with the dominant access patterns: scan, group, and rebuild. </p>
<h3>Why Not Extend the AVL-Based <code>ordered_map</code>?</h3>
<p>While it is theoretically possible to add multimap support to a contiguous AVL structure, doing so would compromise its core invariants: </p>
<ul>
<li>
range deletion would trigger repeated rotations, </li>
<li>
erase(key) would devolve into multiple independent erase operations, </li>
<li>
cost predictability would degrade under multimap workloads. </li>
</ul>
<p>Rather than overloading the <code>ordered_*</code> containers with semantics they are ill-suited for, <code>flat_multimap</code> provides a <b>purpose-built structure</b> whose behavior is transparent and intentionally biased toward bulk and range-oriented operations. </p>
<h3>Why There Is No <code>flat_multiset</code></h3>
<p>A multiset variant would add little semantic value. A sorted sequence of keys with duplicates is already fully expressible as a <code>std::vector&lt;K&gt;</code> with <code>std::stable_sort</code>. </p>
<p>Unlike <code>flat_multimap</code>, which must expose key-value association and range-based deletion, a hypothetical <code>flat_multiset</code> would amount to a thin wrapper over an existing algorithm without providing meaningful additional structure or guarantees. </p>
<h3>About Performance</h3>
<p>Benchmarks (Apple Silicon M3, LLVM clang++20, 2025) compare <code><a class="el" href="classjh_1_1flat__multimap.html" title="Flat ordered multimap implemented as a sorted contiguous container.">jh::flat_multimap</a></code> against <code>std::multimap</code> under representative workloads. Measurements were taken at both <code>-O0</code> and <code>-O3 -march=native</code>, with consistent trends observed across optimization levels. </p>
<table class="doxtable">
<tr>
<th>Operation</th><th><code>std::multimap</code></th><th><code><a class="el" href="classjh_1_1flat__multimap.html" title="Flat ordered multimap implemented as a sorted contiguous container.">jh::flat_multimap</a></code></th><th>Notes</th></tr>
<tr>
<td>Random insert (5k)</td><td>faster</td><td>slower</td><td>tree insertion avoids bulk movement</td></tr>
<tr>
<td>Ordered insert (5k)</td><td>slower, higher variance</td><td>consistently faster</td><td>contiguous insertion dominates</td></tr>
<tr>
<td>Bulk construction (50k)</td><td>allocator-dominated</td><td>≈ 2-4× faster</td><td>single append + stable sort</td></tr>
<tr>
<td>Random lookup</td><td>slightly faster</td><td>slightly slower</td><td>binary search vs pointer traversal</td></tr>
<tr>
<td>Iteration</td><td>pointer chasing</td><td>≈ 50-90× faster</td><td>sequential memory traversal</td></tr>
<tr>
<td>Erase by key</td><td>faster</td><td>slower</td><td>range compaction cost</td></tr>
</table>
<h4>Observed Behavior</h4>
<ul>
<li>
Large-scale construction using <code>bulk_insert</code> consistently outperforms node-based multimap insertion at 50k elements and beyond.  </li>
<li>
Sequential iteration shows a decisive advantage for <code>flat_multimap</code>, often exceeding one order of magnitude.  </li>
<li>
Lookup and erase operations are generally slower than <code>std::multimap</code> under low-pressure workloads, reflecting the cost of binary search and contiguous range compaction. <br  />
 Under high-density datasets (e.g. ≥ 1M elements with dense key distributions), lookup performance converges toward that of <code>std::multimap</code>, as contiguous memory layout and cacheline locality increasingly dominate pointer-based traversal costs.  </li>
<li>
Performance characteristics remain stable across optimization levels, indicating that results are dominated by memory layout and access patterns rather than compiler-specific optimizations.  </li>
</ul>
<h3>Design Summary</h3>
<p>The final design of <code>flat_multimap</code> follows the same fundamental philosophy as the <code>ordered_*</code> family: prioritizing cache locality, high hit rates, and contiguous memory layout over optimal asymptotic performance for individual operations. </p>
<p>For small datasets, incremental insertion via <code>insert</code> or <code>emplace</code> is sufficient and convenient. As the container grows beyond a few thousand elements (typically around 5k entries), bulk-oriented construction is strongly recommended to preserve predictable performance characteristics. </p>
<p>Compared to <code>std::multimap</code>, <code>flat_multimap</code> deliberately trades a portion of lookup and erase performance (on the order of ~30% under low-pressure workloads) in exchange for: </p>
<ul>
<li>
significantly improved L1/L2 cache hit rates, </li>
<li>
fully contiguous storage with no allocator-induced fragmentation, </li>
<li>
more stable performance at larger scales. </li>
</ul>
<p>While pointer-based containers often perform well in microbenchmarks executed in isolation, such measurements typically assume an idealized environment with no long-term allocator pressure or memory fragmentation. In real-world systems, contiguous containers tend to exhibit more stable behavior over time due to their compact layout and predictable access patterns. </p>
<p><code>flat_multimap</code> is therefore intended as a locality-optimized, range-oriented structure for large in-memory datasets, rather than as a drop-in replacement for tree-based multimaps in all scenarios. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
</div> <!-- top -->
<hr class="footer"/>
<div class="footer">
    <img class="footer-logo" src="Ojing.svg" alt="Ojing"/>
    <div class="footer-text">
        JH-Toolkit v1.4.0 · Generated by Doxygen
    </div>
    <div class="footer-note">
        We primarily support embedded documentation views in IDEs (classic CLion).
        To ensure compatibility with embedded rendering, some example code in this
        documentation intentionally contains HTML entities.
        In certain cases, Doxygen does not unescape these entities correctly.
        This is a known limitation and currently has no workaround.
    </div>
</div>
</body>
</html>
