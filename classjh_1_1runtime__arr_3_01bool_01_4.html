<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.16.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>JH-Toolkit: jh::runtime_arr&lt; bool &gt; Class Reference</title>
<link rel="icon" href="Jindallae.svg" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="Oree.svg"/></td>
  <td id="projectalign">
   <div id="projectname">JH-Toolkit<span id="projectnumber">&#160;v1.4.0</span>
   </div>
   <div id="projectbrief">An engineering-oriented C++20 toolkit with duck-typed concepts, static design, async coroutines, and semantic containers — header-only, RTTI-free, and concurrency-friendly.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.16.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('classjh_1_1runtime__arr_3_01bool_01_4.html','','classjh_1_1runtime__arr_3_01bool_01_4-members'); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">jh::runtime_arr&lt; bool &gt; Class Reference<span class="mlabels"><span class="mlabel final">final</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>Specialized implementation of <code><a class="el" href="classjh_1_1runtime__arr_3_01bool_01_4.html" title="Specialized implementation of jh::runtime_arr&lt;bool&gt; — a compact, bit-packed boolean array.">jh::runtime_arr&lt;bool&gt;</a></code> — a compact, bit-packed boolean array.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="">jh/core/runtime_arr.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:bit_5Fref" id="r_bit_5Fref"><td class="memItemLeft">struct &#160;</td><td class="memItemRight"><a class="el" href="structjh_1_1runtime__arr_3_01bool_01_4_1_1bit__ref.html">bit_ref</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal reference proxy for single bit access.  <a href="structjh_1_1runtime__arr_3_01bool_01_4_1_1bit__ref.html#details">More...</a><br /></td></tr>
<tr class="memitem:bit_5Fiterator" id="r_bit_5Fiterator"><td class="memItemLeft">struct &#160;</td><td class="memItemRight"><a class="el" href="structjh_1_1runtime__arr_3_01bool_01_4_1_1bit__iterator.html">bit_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator over individual bits in the bit-packed array.  <a href="structjh_1_1runtime__arr_3_01bool_01_4_1_1bit__iterator.html#details">More...</a><br /></td></tr>
<tr class="memitem:bit_5Fconst_5Fiterator" id="r_bit_5Fconst_5Fiterator"><td class="memItemLeft">struct &#160;</td><td class="memItemRight"><a class="el" href="structjh_1_1runtime__arr_3_01bool_01_4_1_1bit__const__iterator.html">bit_const_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const iterator over individual bits in the bit-packed array.  <a href="structjh_1_1runtime__arr_3_01bool_01_4_1_1bit__const__iterator.html#details">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-types" class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aa99a0b31509e876615f99184e8aaf485" id="r_aa99a0b31509e876615f99184e8aaf485"><td class="memItemLeft"><a id="aa99a0b31509e876615f99184e8aaf485" name="aa99a0b31509e876615f99184e8aaf485"></a>
using&#160;</td><td class="memItemRight"><b>raw_type</b> = std::uint64_t</td></tr>
<tr class="memitem:ab10853e65dc8719e3cce5d24da7002ce" id="r_ab10853e65dc8719e3cce5d24da7002ce"><td class="memItemLeft"><a id="ab10853e65dc8719e3cce5d24da7002ce" name="ab10853e65dc8719e3cce5d24da7002ce"></a>
using&#160;</td><td class="memItemRight"><b>value_type</b> = bool</td></tr>
<tr class="memitem:a12de3db21f35b8601e8ecb1d3ee3cc4c" id="r_a12de3db21f35b8601e8ecb1d3ee3cc4c"><td class="memItemLeft"><a id="a12de3db21f35b8601e8ecb1d3ee3cc4c" name="a12de3db21f35b8601e8ecb1d3ee3cc4c"></a>
using&#160;</td><td class="memItemRight"><b>size_type</b> = std::uint64_t</td></tr>
<tr class="memitem:a47604f6d28c5c772f53bbef1bdbdcc72" id="r_a47604f6d28c5c772f53bbef1bdbdcc72"><td class="memItemLeft"><a id="a47604f6d28c5c772f53bbef1bdbdcc72" name="a47604f6d28c5c772f53bbef1bdbdcc72"></a>
using&#160;</td><td class="memItemRight"><b>difference_type</b> = std::ptrdiff_t</td></tr>
<tr class="memitem:a7fda99189cb9e3d6f406bb5e4c1c67dc" id="r_a7fda99189cb9e3d6f406bb5e4c1c67dc"><td class="memItemLeft"><a id="a7fda99189cb9e3d6f406bb5e4c1c67dc" name="a7fda99189cb9e3d6f406bb5e4c1c67dc"></a>
using&#160;</td><td class="memItemRight"><b>reference</b> = <a class="el" href="structjh_1_1runtime__arr_3_01bool_01_4_1_1bit__ref.html">bit_ref</a></td></tr>
<tr class="memitem:aa5225cc9e4310f9b50c0a52f7eb46822" id="r_aa5225cc9e4310f9b50c0a52f7eb46822"><td class="memItemLeft"><a id="aa5225cc9e4310f9b50c0a52f7eb46822" name="aa5225cc9e4310f9b50c0a52f7eb46822"></a>
using&#160;</td><td class="memItemRight"><b>const_reference</b> = bool</td></tr>
<tr class="memitem:a3766d7508dd8f51abd056f486ccbb3e6" id="r_a3766d7508dd8f51abd056f486ccbb3e6"><td class="memItemLeft"><a id="a3766d7508dd8f51abd056f486ccbb3e6" name="a3766d7508dd8f51abd056f486ccbb3e6"></a>
using&#160;</td><td class="memItemRight"><b>iterator</b> = <a class="el" href="structjh_1_1runtime__arr_3_01bool_01_4_1_1bit__iterator.html">bit_iterator</a></td></tr>
<tr class="memitem:a0ba1e17efa0f2beb2afb8f33a619e8d6" id="r_a0ba1e17efa0f2beb2afb8f33a619e8d6"><td class="memItemLeft"><a id="a0ba1e17efa0f2beb2afb8f33a619e8d6" name="a0ba1e17efa0f2beb2afb8f33a619e8d6"></a>
using&#160;</td><td class="memItemRight"><b>const_iterator</b> = <a class="el" href="structjh_1_1runtime__arr_3_01bool_01_4_1_1bit__const__iterator.html">bit_const_iterator</a></td></tr>
<tr class="memitem:aa7a9136db1823b8dd65f07ca9779a5c1" id="r_aa7a9136db1823b8dd65f07ca9779a5c1"><td class="memItemLeft"><a id="aa7a9136db1823b8dd65f07ca9779a5c1" name="aa7a9136db1823b8dd65f07ca9779a5c1"></a>
using&#160;</td><td class="memItemRight"><b>pointer</b></td></tr>
<tr class="memdesc:aa7a9136db1823b8dd65f07ca9779a5c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer type. <br /></td></tr>
<tr class="memitem:a90b40d1b38338b0de98e9a6bf245a2b0" id="r_a90b40d1b38338b0de98e9a6bf245a2b0"><td class="memItemLeft"><a id="a90b40d1b38338b0de98e9a6bf245a2b0" name="a90b40d1b38338b0de98e9a6bf245a2b0"></a>
using&#160;</td><td class="memItemRight"><b>const_pointer</b></td></tr>
<tr class="memdesc:a90b40d1b38338b0de98e9a6bf245a2b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const pointer type. <br /></td></tr>
<tr class="memitem:a9601a63c341606c910915f7a1242ad6e" id="r_a9601a63c341606c910915f7a1242ad6e"><td class="memItemLeft"><a id="a9601a63c341606c910915f7a1242ad6e" name="a9601a63c341606c910915f7a1242ad6e"></a>
using&#160;</td><td class="memItemRight"><b>allocator_type</b></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a71eab497ab66de805e35ad2ee0a6238f" id="r_a71eab497ab66de805e35ad2ee0a6238f"><td class="memItemLeft">&#160;</td><td class="memItemRight"><a class="el" href="#a71eab497ab66de805e35ad2ee0a6238f">runtime_arr</a> (std::uint64_t <a class="el" href="#ac6499d84305124953b21a2458902413c">size</a>)</td></tr>
<tr class="memdesc:a71eab497ab66de805e35ad2ee0a6238f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a bit-packed boolean runtime array with all bits zero-initialized.  <br /></td></tr>
<tr class="memitem:acf95a550fb69b5c1c4196258fb8e581c" id="r_acf95a550fb69b5c1c4196258fb8e581c"><td class="memItemLeft">&#160;</td><td class="memItemRight"><a class="el" href="#acf95a550fb69b5c1c4196258fb8e581c">runtime_arr</a> (std::vector&lt; bool &gt; &amp;&amp;vec)</td></tr>
<tr class="memdesc:acf95a550fb69b5c1c4196258fb8e581c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a bit-packed array by moving data from a <code>std::vector&lt;bool&gt;</code>.  <br /></td></tr>
<tr class="memitem:ae8f6c3c869d4b7deb4961202b0757b45" id="r_ae8f6c3c869d4b7deb4961202b0757b45"><td class="memItemLeft">&#160;</td><td class="memItemRight"><a class="el" href="#ae8f6c3c869d4b7deb4961202b0757b45">runtime_arr</a> (std::initializer_list&lt; bool &gt; init)</td></tr>
<tr class="memdesc:ae8f6c3c869d4b7deb4961202b0757b45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a bit-packed boolean runtime array from an initializer list.  <br /></td></tr>
<tr class="memitem:a9419cf99074d6a074a181102cc3aac5f" id="r_a9419cf99074d6a074a181102cc3aac5f"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIt&gt; <br />
requires (<a class="el" href="conceptjh_1_1concepts_1_1forward__iterator.html">jh::concepts::forward_iterator</a>&lt;ForwardIt&gt; &amp;&amp; std::convertible_to&lt;typename ForwardIt::value_type, value_type&gt;)</td></tr>
<tr class="memitem:a9419cf99074d6a074a181102cc3aac5f template"><td class="memItemLeft">&#160;</td><td class="memItemRight"><a class="el" href="#a9419cf99074d6a074a181102cc3aac5f">runtime_arr</a> (ForwardIt first, ForwardIt last)</td></tr>
<tr class="memdesc:a9419cf99074d6a074a181102cc3aac5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a bit-packed array from a range of boolean values.  <br /></td></tr>
<tr class="memitem:ac6499d84305124953b21a2458902413c" id="r_ac6499d84305124953b21a2458902413c"><td class="memItemLeft">size_type&#160;</td><td class="memItemRight"><a class="el" href="#ac6499d84305124953b21a2458902413c">size</a> () const noexcept</td></tr>
<tr class="memdesc:ac6499d84305124953b21a2458902413c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in the array.  <br /></td></tr>
<tr class="memitem:a346ef097f22aea5c97f2513dc512b51e" id="r_a346ef097f22aea5c97f2513dc512b51e"><td class="memItemLeft">bool&#160;</td><td class="memItemRight"><a class="el" href="#a346ef097f22aea5c97f2513dc512b51e">empty</a> () const noexcept</td></tr>
<tr class="memdesc:a346ef097f22aea5c97f2513dc512b51e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the array is empty.  <br /></td></tr>
<tr class="memitem:a9f16b30a3fb84936d7b664c0c10b3da3" id="r_a9f16b30a3fb84936d7b664c0c10b3da3"><td class="memItemLeft">raw_type *&#160;</td><td class="memItemRight"><a class="el" href="#a9f16b30a3fb84936d7b664c0c10b3da3">raw_data</a> () noexcept</td></tr>
<tr class="memdesc:a9f16b30a3fb84936d7b664c0c10b3da3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides mutable access to the underlying word buffer.  <br /></td></tr>
<tr class="memitem:ae799ec0f99656a3c3101374ded1ebf0e" id="r_ae799ec0f99656a3c3101374ded1ebf0e"><td class="memItemLeft">const raw_type *&#160;</td><td class="memItemRight"><a class="el" href="#ae799ec0f99656a3c3101374ded1ebf0e">raw_data</a> () const noexcept</td></tr>
<tr class="memdesc:ae799ec0f99656a3c3101374ded1ebf0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides const access to the underlying word buffer.  <br /></td></tr>
<tr class="memitem:a8edc8c849f99dbad23b688f58256eb72" id="r_a8edc8c849f99dbad23b688f58256eb72"><td class="memItemLeft">size_type&#160;</td><td class="memItemRight"><a class="el" href="#a8edc8c849f99dbad23b688f58256eb72">raw_word_count</a> () const noexcept</td></tr>
<tr class="memdesc:a8edc8c849f99dbad23b688f58256eb72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of 64-bit words used internally to store all bits.  <br /></td></tr>
<tr class="memitem:a2123bcf12c8d0d1f1d54aee78f617519" id="r_a2123bcf12c8d0d1f1d54aee78f617519"><td class="memItemLeft">reference&#160;</td><td class="memItemRight"><a class="el" href="#a2123bcf12c8d0d1f1d54aee78f617519">operator[]</a> (std::uint64_t i) noexcept</td></tr>
<tr class="memdesc:a2123bcf12c8d0d1f1d54aee78f617519"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unchecked bit access (read/write).  <br /></td></tr>
<tr class="memitem:a4e730db56106e04c76a6ebf5eb002872" id="r_a4e730db56106e04c76a6ebf5eb002872"><td class="memItemLeft">value_type&#160;</td><td class="memItemRight"><a class="el" href="#a4e730db56106e04c76a6ebf5eb002872">operator[]</a> (std::uint64_t i) const noexcept</td></tr>
<tr class="memdesc:a4e730db56106e04c76a6ebf5eb002872"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unchecked const bit access (read-only).  <br /></td></tr>
<tr class="memitem:a8b1c279984f4b9739ff11d51ba753440" id="r_a8b1c279984f4b9739ff11d51ba753440"><td class="memItemLeft">reference&#160;</td><td class="memItemRight"><a class="el" href="#a8b1c279984f4b9739ff11d51ba753440">at</a> (std::uint64_t i)</td></tr>
<tr class="memdesc:a8b1c279984f4b9739ff11d51ba753440"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bounds-checked bit access (read/write).  <br /></td></tr>
<tr class="memitem:ab111e8bb70047884fb360b24c08fe683" id="r_ab111e8bb70047884fb360b24c08fe683"><td class="memItemLeft">value_type&#160;</td><td class="memItemRight"><a class="el" href="#ab111e8bb70047884fb360b24c08fe683">at</a> (std::uint64_t i) const</td></tr>
<tr class="memdesc:ab111e8bb70047884fb360b24c08fe683"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const bounds-checked bit access (read-only).  <br /></td></tr>
<tr class="memitem:a48286d83562d511c3f2166dd1e069508" id="r_a48286d83562d511c3f2166dd1e069508"><td class="memItemLeft">void&#160;</td><td class="memItemRight"><a class="el" href="#a48286d83562d511c3f2166dd1e069508">set</a> (std::uint64_t i, bool val=true)</td></tr>
<tr class="memdesc:a48286d83562d511c3f2166dd1e069508"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets or clears the bit at given index.  <br /></td></tr>
<tr class="memitem:a6327809b0400edcb799886db8a9baa47" id="r_a6327809b0400edcb799886db8a9baa47"><td class="memItemLeft">void&#160;</td><td class="memItemRight"><a class="el" href="#a6327809b0400edcb799886db8a9baa47">unset</a> (std::uint64_t i)</td></tr>
<tr class="memdesc:a6327809b0400edcb799886db8a9baa47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the bit at given index.  <br /></td></tr>
<tr class="memitem:aaf0bb20a39547e8ce2ba2945ca3282ae" id="r_aaf0bb20a39547e8ce2ba2945ca3282ae"><td class="memItemLeft">value_type&#160;</td><td class="memItemRight"><a class="el" href="#aaf0bb20a39547e8ce2ba2945ca3282ae">test</a> (std::uint64_t i) const</td></tr>
<tr class="memdesc:aaf0bb20a39547e8ce2ba2945ca3282ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests if the bit at index is set.  <br /></td></tr>
<tr class="memitem:a5e6383122da73f10315ac279a0fd350e" id="r_a5e6383122da73f10315ac279a0fd350e"><td class="memItemLeft">void&#160;</td><td class="memItemRight"><a class="el" href="#a5e6383122da73f10315ac279a0fd350e">reset_all</a> () noexcept</td></tr>
<tr class="memdesc:a5e6383122da73f10315ac279a0fd350e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets all bits in the bit-packed array to zero.  <br /></td></tr>
<tr class="memitem:acb37452af174c0d08a3275ef34e41b32" id="r_acb37452af174c0d08a3275ef34e41b32"><td class="memItemLeft">&#160;</td><td class="memItemRight"><a class="el" href="#acb37452af174c0d08a3275ef34e41b32">runtime_arr</a> (runtime_arr &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:acb37452af174c0d08a3275ef34e41b32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor — transfers ownership of the bit-packed buffer.  <br /></td></tr>
<tr class="memitem:a2d8821621a9ad24da60f52d73f0b50d5" id="r_a2d8821621a9ad24da60f52d73f0b50d5"><td class="memItemLeft"><a class="el" href="#a71eab497ab66de805e35ad2ee0a6238f">runtime_arr</a>&lt; bool &gt; &amp;&#160;</td><td class="memItemRight"><a class="el" href="#a2d8821621a9ad24da60f52d73f0b50d5">operator=</a> (<a class="el" href="#a71eab497ab66de805e35ad2ee0a6238f">runtime_arr</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:a2d8821621a9ad24da60f52d73f0b50d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator — transfers ownership of the bit-packed buffer.  <br /></td></tr>
<tr class="memitem:ad26e47c9a94647fc6babbce42a771495" id="r_ad26e47c9a94647fc6babbce42a771495"><td class="memItemLeft">&#160;</td><td class="memItemRight"><a class="el" href="#ad26e47c9a94647fc6babbce42a771495">operator std::vector&lt; bool &gt;</a> () &amp;&amp;</td></tr>
<tr class="memdesc:ad26e47c9a94647fc6babbce42a771495"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the bit array into std::vector&lt;bool&gt;. Elements are copied bit-by-bit.  <br /></td></tr>
<tr class="memitem:abd8d0d24d9416c194ee54a59c81a2cc8" id="r_abd8d0d24d9416c194ee54a59c81a2cc8"><td class="memItemLeft"><a id="abd8d0d24d9416c194ee54a59c81a2cc8" name="abd8d0d24d9416c194ee54a59c81a2cc8"></a>
iterator&#160;</td><td class="memItemRight"><b>begin</b> () noexcept</td></tr>
<tr class="memdesc:abd8d0d24d9416c194ee54a59c81a2cc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutable begin iterator over bits. <br /></td></tr>
<tr class="memitem:a74a30f45693ff0176a35fbc7b53172de" id="r_a74a30f45693ff0176a35fbc7b53172de"><td class="memItemLeft"><a id="a74a30f45693ff0176a35fbc7b53172de" name="a74a30f45693ff0176a35fbc7b53172de"></a>
iterator&#160;</td><td class="memItemRight"><b>end</b> () noexcept</td></tr>
<tr class="memdesc:a74a30f45693ff0176a35fbc7b53172de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutable end iterator over bits. <br /></td></tr>
<tr class="memitem:a8692fac59b025dcada4cfd91f32ea4bc" id="r_a8692fac59b025dcada4cfd91f32ea4bc"><td class="memItemLeft"><a id="a8692fac59b025dcada4cfd91f32ea4bc" name="a8692fac59b025dcada4cfd91f32ea4bc"></a>
const_iterator&#160;</td><td class="memItemRight"><b>begin</b> () const noexcept</td></tr>
<tr class="memdesc:a8692fac59b025dcada4cfd91f32ea4bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const begin iterator over bits. <br /></td></tr>
<tr class="memitem:aa5a7b9025a8c5d200ba858dfe1855cec" id="r_aa5a7b9025a8c5d200ba858dfe1855cec"><td class="memItemLeft"><a id="aa5a7b9025a8c5d200ba858dfe1855cec" name="aa5a7b9025a8c5d200ba858dfe1855cec"></a>
const_iterator&#160;</td><td class="memItemRight"><b>end</b> () const noexcept</td></tr>
<tr class="memdesc:aa5a7b9025a8c5d200ba858dfe1855cec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const end iterator over bits. <br /></td></tr>
<tr class="memitem:a11adaafc11234b263374f52c6aab4280" id="r_a11adaafc11234b263374f52c6aab4280"><td class="memItemLeft"><a id="a11adaafc11234b263374f52c6aab4280" name="a11adaafc11234b263374f52c6aab4280"></a>
const_iterator&#160;</td><td class="memItemRight"><b>cbegin</b> () const noexcept</td></tr>
<tr class="memdesc:a11adaafc11234b263374f52c6aab4280"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const begin iterator over bits. <br /></td></tr>
<tr class="memitem:ad776562ca2a08094f58e01ce50b08f0e" id="r_ad776562ca2a08094f58e01ce50b08f0e"><td class="memItemLeft"><a id="ad776562ca2a08094f58e01ce50b08f0e" name="ad776562ca2a08094f58e01ce50b08f0e"></a>
const_iterator&#160;</td><td class="memItemRight"><b>cend</b> () const noexcept</td></tr>
<tr class="memdesc:ad776562ca2a08094f58e01ce50b08f0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const end iterator over bits. <br /></td></tr>
<tr class="memitem:a73f8a64a883b89b0ad6f7cb4e0655a06" id="r_a73f8a64a883b89b0ad6f7cb4e0655a06"><td class="memItemLeft">void&#160;</td><td class="memItemRight"><a class="el" href="#a73f8a64a883b89b0ad6f7cb4e0655a06">data</a> () const =delete</td></tr>
<tr class="memdesc:a73f8a64a883b89b0ad6f7cb4e0655a06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deleted <code><a class="el" href="#a73f8a64a883b89b0ad6f7cb4e0655a06" title="Deleted data() function — raw pointer access is not valid for bit-packed layout.">data()</a></code> function — raw pointer access is not valid for bit-packed layout.  <br /></td></tr>
<tr class="memitem:a872faf87a7d4b6b5007c4310b3ce9db2" id="r_a872faf87a7d4b6b5007c4310b3ce9db2"><td class="memItemLeft">&#160;</td><td class="memItemRight"><a class="el" href="#a872faf87a7d4b6b5007c4310b3ce9db2">runtime_arr</a> (std::uint64_t <a class="el" href="#ac6499d84305124953b21a2458902413c">size</a>, auto)=delete</td></tr>
<tr class="memdesc:a872faf87a7d4b6b5007c4310b3ce9db2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deleted allocator-based constructor.  <br /></td></tr>
<tr class="memitem:acf511177a43bb57be772cec2ca271917" id="r_acf511177a43bb57be772cec2ca271917"><td class="memItemLeft"><a id="acf511177a43bb57be772cec2ca271917" name="acf511177a43bb57be772cec2ca271917"></a>
std::span&lt; value_type &gt;&#160;</td><td class="memItemRight"><b>as_span</b> ()=delete</td></tr>
<tr class="memdesc:acf511177a43bb57be772cec2ca271917"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deleted — bit-packed array cannot expose a contiguous span of bools. <br /></td></tr>
<tr class="memitem:a292912ede53fdeb0c1362f21ed979712" id="r_a292912ede53fdeb0c1362f21ed979712"><td class="memItemLeft"><a id="a292912ede53fdeb0c1362f21ed979712" name="a292912ede53fdeb0c1362f21ed979712"></a>
std::span&lt; const value_type &gt;&#160;</td><td class="memItemRight"><b>as_span</b> () const =delete</td></tr>
<tr class="memdesc:a292912ede53fdeb0c1362f21ed979712"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deleted — const version; contiguous view over bits is not representable. <br /></td></tr>
<tr class="memitem:a3d077be8ec790beb8c06d0cded6a2c79" id="r_a3d077be8ec790beb8c06d0cded6a2c79"><td class="memItemLeft"><a id="a3d077be8ec790beb8c06d0cded6a2c79" name="a3d077be8ec790beb8c06d0cded6a2c79"></a>
&#160;</td><td class="memItemRight"><b>runtime_arr</b> (const runtime_arr &amp;)=delete</td></tr>
<tr class="memdesc:a3d077be8ec790beb8c06d0cded6a2c79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor deleted — bit array is non-copyable by design. <br /></td></tr>
<tr class="memitem:acd7aa7629a3be8379658ec87017e1485" id="r_acd7aa7629a3be8379658ec87017e1485"><td class="memItemLeft"><a id="acd7aa7629a3be8379658ec87017e1485" name="acd7aa7629a3be8379658ec87017e1485"></a>
<a class="el" href="#a71eab497ab66de805e35ad2ee0a6238f">runtime_arr</a> &amp;&#160;</td><td class="memItemRight"><b>operator=</b> (const <a class="el" href="#a71eab497ab66de805e35ad2ee0a6238f">runtime_arr</a> &amp;)=delete</td></tr>
<tr class="memdesc:acd7aa7629a3be8379658ec87017e1485"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment deleted — bit array is non-copyable by design. <br /></td></tr>
<tr class="memitem:ac811ed28b9b1aef06521b90a3c6e2988" id="r_ac811ed28b9b1aef06521b90a3c6e2988"><td class="memItemLeft">&#160;</td><td class="memItemRight"><a class="el" href="classjh_1_1runtime__arr.html#ac811ed28b9b1aef06521b90a3c6e2988">operator std::vector&lt; bool &gt;</a> () &amp;&amp;</td></tr>
<tr class="memdesc:ac811ed28b9b1aef06521b90a3c6e2988"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the array into a <code>std::vector&lt;T&gt;</code> by moving its contents.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-static-methods" class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a8c8d53fdcfc96c41aa64a940854087ea" id="r_a8c8d53fdcfc96c41aa64a940854087ea"><td class="memItemLeft"><a id="a8c8d53fdcfc96c41aa64a940854087ea" name="a8c8d53fdcfc96c41aa64a940854087ea"></a>
static bool&#160;</td><td class="memItemRight"><b>is_static_built</b> ()</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-static-attribs" class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:aae396ba33982ab1802bbcc3350b8436a" id="r_aae396ba33982ab1802bbcc3350b8436a"><td class="memItemLeft"><a id="aae396ba33982ab1802bbcc3350b8436a" name="aae396ba33982ab1802bbcc3350b8436a"></a>
static constexpr uninitialized_t&#160;</td><td class="memItemRight"><b>uninitialized</b></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Specialized implementation of <code><a class="el" href="classjh_1_1runtime__arr_3_01bool_01_4.html" title="Specialized implementation of jh::runtime_arr&lt;bool&gt; — a compact, bit-packed boolean array.">jh::runtime_arr&lt;bool&gt;</a></code> — a compact, bit-packed boolean array. </p>
<h4>Overview</h4>
<p>This specialization provides a <b>memory-efficient representation</b> for <code>bool</code> values, storing them as individual bits within 64-bit words (<code>uint64_t[]</code>). Each bit represents a boolean value, achieving <b>8× memory compression</b> compared to the generic <code>runtime_arr&lt;T, Alloc&gt;</code> template (which stores one byte per <code>bool</code>). </p>
<p>Its purpose is not raw speed but <b>spatial density</b> and <b>fragmentation reduction</b> — ideal for large logical masks, flags, and occupancy bitfields. </p>
<h4>Relation to Generic Template</h4>
<p>This specialization mirrors the structure of the generic <code>runtime_arr&lt;T, Alloc&gt;</code>, but modifies or disables certain operations that are incompatible with bit-level storage. </p>
<table class="doxtable">
<tr>
<th>Semantics</th><th>Generic Member</th><th>Bool Specialization Equivalent</th><th>Notes</th></tr>
<tr>
<td>Raw access</td><td><code><a class="el" href="#a73f8a64a883b89b0ad6f7cb4e0655a06" title="Deleted data() function — raw pointer access is not valid for bit-packed layout.">data()</a></code>, <code><a class="el" href="#acf511177a43bb57be772cec2ca271917" title="Deleted — bit-packed array cannot expose a contiguous span of bools.">as_span()</a></code></td><td>❌ Deleted</td><td>Direct pointer access invalid for bit-packed layout.</td></tr>
<tr>
<td>Element access</td><td><code>operator[](i)</code></td><td>✅ Reimplemented</td><td>Non-const returns <code><a class="el" href="structjh_1_1runtime__arr_3_01bool_01_4_1_1bit__ref.html" title="Internal reference proxy for single bit access.">bit_ref</a></code>, const returns <code>bool</code>.</td></tr>
<tr>
<td>Bounded access</td><td><code>at(i)</code></td><td>✅ Reimplemented</td><td>Same proxy/value semantics with range checking.</td></tr>
<tr>
<td>Bulk reset</td><td><code><a class="el" href="#a5e6383122da73f10315ac279a0fd350e" title="Resets all bits in the bit-packed array to zero.">reset_all()</a></code></td><td>✅ Implemented</td><td>Clears all bits via <code>std::memset()</code>.</td></tr>
<tr>
<td>Bit manipulation</td><td>(none)</td><td>✅ <code><a class="el" href="#a48286d83562d511c3f2166dd1e069508" title="Sets or clears the bit at given index.">set()</a></code>, <code><a class="el" href="#a6327809b0400edcb799886db8a9baa47" title="Clears the bit at given index.">unset()</a></code>, <code><a class="el" href="#aaf0bb20a39547e8ce2ba2945ca3282ae" title="Tests if the bit at index is set.">test()</a></code></td><td>New API for direct bit operations.</td></tr>
<tr>
<td>Allocator constructor</td><td><code>runtime_arr(size, Alloc)</code></td><td>❌ Deleted</td><td>Custom allocators not supported for bit layout.</td></tr>
<tr>
<td>Copy semantics</td><td>❌ Deleted</td><td>❌ Deleted</td><td>Copying disallowed to prevent shallow duplication.</td></tr>
<tr>
<td>Move semantics</td><td>✅ Supported</td><td>✅ Supported</td><td>Safe ownership transfer via RAII.</td></tr>
</table>
<h4>Core Characteristics</h4>
<ul>
<li>
Stores bits compactly in 64-bit words (<code>uint64_t[]</code>). </li>
<li>
Uses <code><a class="el" href="structjh_1_1runtime__arr_3_01bool_01_4_1_1bit__ref.html" title="Internal reference proxy for single bit access.">bit_ref</a></code> proxies for writable element access. </li>
<li>
Const accessors return plain <code>bool</code> values. </li>
<li>
Implements <code><a class="el" href="structjh_1_1runtime__arr_3_01bool_01_4_1_1bit__iterator.html" title="Iterator over individual bits in the bit-packed array.">bit_iterator</a></code> for STL-style traversal. </li>
<li>
Provides low-level access via <code><a class="el" href="#a9f16b30a3fb84936d7b664c0c10b3da3" title="Provides mutable access to the underlying word buffer.">raw_data()</a></code> and <code><a class="el" href="#a8edc8c849f99dbad23b688f58256eb72" title="Returns the number of 64-bit words used internally to store all bits.">raw_word_count()</a></code>. </li>
<li>
Not a contiguous range (proxy elements are non-trivial). </li>
</ul>
<h4>Usage Guidance</h4>
<p>This specialization is automatically selected when <code>T == bool</code> and the allocator parameter is omitted: </p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classjh_1_1runtime__arr.html">jh::runtime_arr&lt;bool&gt;</a> bits(128);</div>
<div class="line">bits.set(3);</div>
<div class="line">bits.unset(1);</div>
<div class="line"><span class="keywordtype">bool</span> b = bits.test(3);</div>
<div class="ttc" id="aclassjh_1_1runtime__arr_html"><div class="ttname"><a href="classjh_1_1runtime__arr.html">jh::runtime_arr</a></div><div class="ttdoc">A move-only, fixed-capacity array with runtime-determined length and RAII-based ownership.</div><div class="ttdef"><b>Definition</b> runtime_arr.h:365</div></div>
</div><!-- fragment --><h4>To disable bit packing:</h4>
<p>Use <code><a class="el" href="classjh_1_1runtime__arr.html" title="A move-only, fixed-capacity array with runtime-determined length and RAII-based ownership.">jh::runtime_arr&lt;bool, jh::runtime_arr_helper::bool_flat_alloc&gt;</a></code> to obtain a <b>byte-based layout</b> (one byte per <code>bool</code>). This form is also the baseline used in all performance comparisons below. </p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classjh_1_1runtime__arr.html">jh::runtime_arr&lt;bool, jh::runtime_arr_helper::bool_flat_alloc&gt;</a> plain(256);</div>
<div class="line">plain[0] = <span class="keyword">true</span>;  <span class="comment">// Stored as 1 byte per bool</span></div>
</div><!-- fragment --><h4>Behavior Summary</h4>
<table class="doxtable">
<tr>
<th>Aspect</th><th>Generic <code>runtime_arr&lt;T&gt;</code></th><th>Specialized <code><a class="el" href="classjh_1_1runtime__arr_3_01bool_01_4.html" title="Specialized implementation of jh::runtime_arr&lt;bool&gt; — a compact, bit-packed boolean array.">runtime_arr&lt;bool&gt;</a></code></th></tr>
<tr>
<td>Storage layout</td><td>Contiguous <code>T[]</code></td><td>Bit-packed (<code>uint64_t[]</code>)</td></tr>
<tr>
<td>Element access</td><td>Direct reference</td><td>Proxy (<code><a class="el" href="structjh_1_1runtime__arr_3_01bool_01_4_1_1bit__ref.html" title="Internal reference proxy for single bit access.">bit_ref</a></code>) / value (<code>bool</code>)</td></tr>
<tr>
<td><code><a class="el" href="#a73f8a64a883b89b0ad6f7cb4e0655a06" title="Deleted data() function — raw pointer access is not valid for bit-packed layout.">data()</a></code> / <code><a class="el" href="#acf511177a43bb57be772cec2ca271917" title="Deleted — bit-packed array cannot expose a contiguous span of bools.">as_span()</a></code></td><td>✅</td><td>❌ Deleted</td></tr>
<tr>
<td>Allocator awareness</td><td>✅</td><td>❌ Deleted</td></tr>
<tr>
<td>Copy semantics</td><td>❌</td><td>❌</td></tr>
<tr>
<td>Move semantics</td><td>✅</td><td>✅</td></tr>
<tr>
<td><code><a class="el" href="#a5e6383122da73f10315ac279a0fd350e" title="Resets all bits in the bit-packed array to zero.">reset_all()</a></code></td><td>Element-wise reset</td><td>Zero bits via <code>memset()</code></td></tr>
<tr>
<td>Primary use</td><td>General runtime array</td><td>Compact boolean bitset</td></tr>
</table>
<h4>Performance Characteristics</h4>
<p>Microbenchmark results for <code><a class="el" href="classjh_1_1runtime__arr_3_01bool_01_4.html" title="Specialized implementation of jh::runtime_arr&lt;bool&gt; — a compact, bit-packed boolean array.">jh::runtime_arr&lt;bool&gt;</a></code> versus its byte-based counterpart <code><a class="el" href="classjh_1_1runtime__arr.html" title="A move-only, fixed-capacity array with runtime-determined length and RAII-based ownership.">jh::runtime_arr&lt;bool, jh::runtime_arr_helper::bool_flat_alloc&gt;</a></code>, collected on <b>Apple Silicon M3</b> with <b>LLVM clang++ 20</b> (2025), under the following setup: </p>
<ul>
<li>
Array sizes: 1,024 and 1,000,000 elements </li>
<li>
Bernoulli(0.5) data distribution </li>
<li>
Catch2 microbenchmark harness </li>
<li>
Single-threaded, in-cache workload </li>
</ul>
<h5>Empirical results</h5>
<table class="doxtable">
<tr>
<th rowspan="2">Optimization</th><th colspan="3">N = 1,000,000 elements</th><th colspan="3">N = 1,024 elements</th></tr>
<tr>
<th><a class="el" href="#a48286d83562d511c3f2166dd1e069508" title="Sets or clears the bit at given index.">set()</a></th><th>read()</th><th><a class="el" href="#a5e6383122da73f10315ac279a0fd350e" title="Resets all bits in the bit-packed array to zero.">reset_all()</a></th><th><a class="el" href="#a48286d83562d511c3f2166dd1e069508" title="Sets or clears the bit at given index.">set()</a></th><th>read()</th><th><a class="el" href="#a5e6383122da73f10315ac279a0fd350e" title="Resets all bits in the bit-packed array to zero.">reset_all()</a></th></tr>
<tr>
<td>-O0</td><td>~20× slower</td><td>~2.8× slower</td><td>~2.8× slower</td><td>~0.3× faster</td><td>~2.3× slower</td><td>~2.3× slower</td></tr>
<tr>
<td>-O2</td><td>~38× slower</td><td>~160× slower</td><td>~130× slower</td><td>~0.55× faster</td><td>~61× slower</td><td>~60× slower</td></tr>
<tr>
<td>-O3</td><td>~59× slower</td><td>~140× slower</td><td>~130× slower</td><td>~0.6× faster</td><td>~62× slower</td><td>~61× slower</td></tr>
<tr>
<td>-Ofast</td><td>~51× slower</td><td>~150× slower</td><td>~125× slower</td><td>~0.5× faster</td><td>~61× slower</td><td>~59× slower</td></tr>
</table>
<h5>Interpretation</h5>
<ul>
<li>
<b>Small arrays (≤1K):</b> Bit-packing may outperform byte-based storage in write-heavy scenarios due to 8× lower memory bandwidth usage. Reads and resets remain slower due to bit masking overhead. </li>
<li>
<b>Large arrays (≥1M):</b> Bitwise access overhead dominates; <code><a class="el" href="#a48286d83562d511c3f2166dd1e069508" title="Sets or clears the bit at given index.">set()</a></code> is typically ~30-60× slower, and <code>read()</code> / <code><a class="el" href="#a5e6383122da73f10315ac279a0fd350e" title="Resets all bits in the bit-packed array to zero.">reset_all()</a></code> are ~120-160×± slower but mostly memory-bound. </li>
<li>
<b>Optimization scaling:</b> <code>-O2</code> already achieves full inlining; <code>-O3</code> and <code>-Ofast</code> differences are within measurement noise (±2%). </li>
<li>
<b>Static instantiation:</b> A precompiled specialization provides a <b>debug fallback</b>, mitigating <code>-O0</code> template inlining overhead. </li>
</ul>
<p>In summary, this specialization trades raw performance for memory compactness. It is most useful for boolean masks, sparse flags, and occupancy grids where space efficiency outweighs per-bit access cost. </p>
<h4>Notes</h4>
<ul>
<li>
Each bit resides in a 64-bit word. </li>
<li>
Thread safety is not guaranteed for concurrent modification. </li>
<li>
RAII-managed, deterministic destruction. </li>
</ul>
<dl class="section see"><dt>See also</dt><dd><ul>
<li>
<code><a class="el" href="classjh_1_1runtime__arr.html" title="A move-only, fixed-capacity array with runtime-determined length and RAII-based ownership.">jh::runtime_arr&lt;T, Alloc&gt;</a></code> — generic version. </li>
<li>
<code><a class="el" href="classjh_1_1runtime__arr.html" title="A move-only, fixed-capacity array with runtime-determined length and RAII-based ownership.">jh::runtime_arr&lt;bool, runtime_arr_helper::bool_flat_alloc&gt;</a></code> — byte-based baseline. </li>
<li>
<code><a class="el" href="structjh_1_1runtime__arr_3_01bool_01_4_1_1bit__ref.html" title="Internal reference proxy for single bit access.">jh::runtime_arr&lt;bool&gt;::bit_ref</a></code> — proxy reference for writable bits. </li>
<li>
<code><a class="el" href="structjh_1_1runtime__arr_3_01bool_01_4_1_1bit__iterator.html" title="Iterator over individual bits in the bit-packed array.">jh::runtime_arr&lt;bool&gt;::bit_iterator</a></code> — <a class="el" href="structjh_1_1iterator.html" title="Forward declaration of jh::iterator&lt;Container&gt;.">iterator</a> class for bit traversal. </li>
</ul>
</dd></dl>
</div><a name="doc-constructors" id="doc-constructors"></a><h2 id="header-doc-constructors" class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a71eab497ab66de805e35ad2ee0a6238f" name="a71eab497ab66de805e35ad2ee0a6238f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71eab497ab66de805e35ad2ee0a6238f">&#9670;&#160;</a></span>runtime_arr() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classjh_1_1runtime__arr.html">jh::runtime_arr</a>&lt; bool &gt;::runtime_arr </td>
          <td>(</td>
          <td class="paramtype">std::uint64_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel explicit">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a bit-packed boolean runtime array with all bits zero-initialized. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="#ac6499d84305124953b21a2458902413c" title="Returns the number of elements in the array.">size</a></td><td>Number of logical bits to allocate and initialize.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Behavior</b> </p><ul>
<li>
Allocates <code>ceil(size / 64)</code> 64-bit words via <code>new[]</code>. </li>
<li>
All bits are cleared to zero (<code>false</code>). </li>
<li>
Each bit is accessible through <code><a class="el" href="structjh_1_1runtime__arr_3_01bool_01_4_1_1bit__ref.html" title="Internal reference proxy for single bit access.">bit_ref</a></code> proxy references. </li>
<li>
Ownership is RAII-managed using <code>std::unique_ptr&lt;uint64_t[]&gt;</code>. </li>
<li>
Allocator parameters are not supported for bit-packed storage. </li>
</ul>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>
Move-only; copy operations are deleted. </li>
<li>
Use <code><a class="el" href="#a48286d83562d511c3f2166dd1e069508" title="Sets or clears the bit at given index.">set()</a></code>, <code><a class="el" href="#a6327809b0400edcb799886db8a9baa47" title="Clears the bit at given index.">unset()</a></code>, <code><a class="el" href="#aaf0bb20a39547e8ce2ba2945ca3282ae" title="Tests if the bit at index is set.">test()</a></code>, and <code><a class="el" href="#a5e6383122da73f10315ac279a0fd350e" title="Resets all bits in the bit-packed array to zero.">reset_all()</a></code> for bit manipulation. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="acf95a550fb69b5c1c4196258fb8e581c" name="acf95a550fb69b5c1c4196258fb8e581c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf95a550fb69b5c1c4196258fb8e581c">&#9670;&#160;</a></span>runtime_arr() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classjh_1_1runtime__arr.html">jh::runtime_arr</a>&lt; bool &gt;::runtime_arr </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; bool &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>vec</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel explicit">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a bit-packed array by moving data from a <code>std::vector&lt;bool&gt;</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>Rvalue reference to <code>std::vector&lt;bool&gt;</code> whose elements are copied bitwise.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Behavior</b> </p><ul>
<li>
Allocates sufficient 64-bit words to store <code>vec.size()</code> bits. </li>
<li>
Each element of <code>vec</code> is copied into the corresponding bit position. </li>
<li>
Ownership and lifetime are RAII-managed internally. </li>
<li>
The source vector remains valid but its contents are not preserved after the operation. </li>
</ul>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>
Copying is bitwise; no shared memory with the original vector. </li>
<li>
Move-only type — copy construction and assignment are deleted. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ae8f6c3c869d4b7deb4961202b0757b45" name="ae8f6c3c869d4b7deb4961202b0757b45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8f6c3c869d4b7deb4961202b0757b45">&#9670;&#160;</a></span>runtime_arr() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classjh_1_1runtime__arr.html">jh::runtime_arr</a>&lt; bool &gt;::runtime_arr </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; bool &gt;</td>          <td class="paramname"><span class="paramname"><em>init</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a bit-packed boolean runtime array from an initializer list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">init</td><td>Initializer list of boolean values.</td></tr>
  </table>
  </dd>
</dl>
<p>Allocates the minimal number of 64-bit words required to represent all elements in <code>init</code>. Each bit is initialized according to the list values using <code>set(i, v)</code>. </p>
<ul>
<li>
Storage is bit-packed: 64 elements per 64-bit word. </li>
<li>
Managed via <code>std::unique_ptr&lt;uint64_t[]&gt;</code>. </li>
<li>
Does not use allocators. </li>
<li>
Move-only type; copy operations are deleted. </li>
</ul>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>If allocation fails. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9419cf99074d6a074a181102cc3aac5f" name="a9419cf99074d6a074a181102cc3aac5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9419cf99074d6a074a181102cc3aac5f">&#9670;&#160;</a></span>runtime_arr() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIt&gt; <br />
requires (<a class="el" href="conceptjh_1_1concepts_1_1forward__iterator.html">jh::concepts::forward_iterator</a>&lt;ForwardIt&gt; &amp;&amp; std::convertible_to&lt;typename ForwardIt::value_type, value_type&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classjh_1_1runtime__arr.html">jh::runtime_arr</a>&lt; bool &gt;::runtime_arr </td>
          <td>(</td>
          <td class="paramtype">ForwardIt</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt</td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a bit-packed array from a range of boolean values. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ForwardIt</td><td>Iterator type satisfying <code><a class="el" href="conceptjh_1_1concepts_1_1forward__iterator.html" title="Concept for multi-pass, readable, and self-sentinel iterators.">jh::concepts::forward_iterator</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Iterator to the start of the range. </td></tr>
    <tr><td class="paramname">last</td><td>Iterator to the end of the range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>If the iterator range is invalid.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Behavior</b> </p><ul>
<li>
Computes the number of elements using <code>std::distance(first, last)</code>. </li>
<li>
Allocates enough 64-bit words to store all bits. </li>
<li>
Clears all bits to zero, then copies values from the input range bitwise. </li>
<li>
Throws <code>std::invalid_argument</code> if the range length is negative. </li>
</ul>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>
Supports any forward iterator, including container iterators and <code>std::span</code>. </li>
<li>
Single-pass input iterators are not supported. </li>
<li>
Resulting array is bit-packed and non-resizable. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="acb37452af174c0d08a3275ef34e41b32" name="acb37452af174c0d08a3275ef34e41b32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb37452af174c0d08a3275ef34e41b32">&#9670;&#160;</a></span>runtime_arr() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classjh_1_1runtime__arr.html">jh::runtime_arr</a>&lt; bool &gt;::runtime_arr </td>
          <td>(</td>
          <td class="paramtype">runtime_arr&lt; bool &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor — transfers ownership of the bit-packed buffer. </p>
<p><b>Behavior</b> </p><ul>
<li>
Transfers ownership of the internal <code>uint64_t[]</code> buffer from <code>other</code> to <code>*this</code>. </li>
<li>
After the move, <code>other</code> is left in an empty but valid state (<code><a class="el" href="#ac6499d84305124953b21a2458902413c" title="Returns the number of elements in the array.">size()</a> == 0</code>, <code><a class="el" href="#a9f16b30a3fb84936d7b664c0c10b3da3" title="Provides mutable access to the underlying word buffer.">raw_data()</a> == nullptr</code>). </li>
<li>
No memory allocation or bit copy is performed — the operation is <b>O(1)</b>. </li>
</ul>
<p><b>Rationale</b> </p>
<p>Move semantics allow efficient transfer of large bitsets across scopes, especially when benchmarking or composing higher-level containers. Copying remains disabled to avoid accidental deep duplication of bit-packed data. </p>

</div>
</div>
<a id="a872faf87a7d4b6b5007c4310b3ce9db2" name="a872faf87a7d4b6b5007c4310b3ce9db2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a872faf87a7d4b6b5007c4310b3ce9db2">&#9670;&#160;</a></span>runtime_arr() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classjh_1_1runtime__arr.html">jh::runtime_arr</a>&lt; bool &gt;::runtime_arr </td>
          <td>(</td>
          <td class="paramtype">std::uint64_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">auto</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel delete">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deleted allocator-based constructor. </p>
<p><b>Behavior</b> </p>
<p>The <code><a class="el" href="classjh_1_1runtime__arr_3_01bool_01_4.html" title="Specialized implementation of jh::runtime_arr&lt;bool&gt; — a compact, bit-packed boolean array.">runtime_arr&lt;bool&gt;</a></code> specialization does not support allocator-based construction because its layout is bit-packed rather than byte-based. All allocation is performed internally via <code>new[]</code> with RAII management. </p>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>
Allocator granularity (bytes) is incompatible with bit-level storage. </li>
<li>
Use <code><a class="el" href="#a71eab497ab66de805e35ad2ee0a6238f" title="Constructs a bit-packed boolean runtime array with all bits zero-initialized.">runtime_arr&lt;bool, runtime_arr_helper::bool_flat_alloc&gt;</a></code> for a byte-based boolean array that supports allocator semantics. </li>
</ul>
</dd></dl>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="a8b1c279984f4b9739ff11d51ba753440" name="a8b1c279984f4b9739ff11d51ba753440"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b1c279984f4b9739ff11d51ba753440">&#9670;&#160;</a></span>at() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">reference <a class="el" href="classjh_1_1runtime__arr.html">jh::runtime_arr</a>&lt; bool &gt;::at </td>
          <td>(</td>
          <td class="paramtype">std::uint64_t</td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bounds-checked bit access (read/write). </p>
<p>Returns a proxy reference to the bit at the specified index, performing explicit range checking. If <code>i &gt;= <a class="el" href="#ac6499d84305124953b21a2458902413c" title="Returns the number of elements in the array.">size()</a></code>, an <code>std::out_of_range</code> exception is thrown.</p>
<p>Equivalent to <code>operator[]</code> but with explicit bounds validation. Mirrors the semantics of <code>std::vector&lt;bool&gt;::at()</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Bit index within <code>[0, <a class="el" href="#ac6499d84305124953b21a2458902413c" title="Returns the number of elements in the array.">size()</a>)</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bit reference proxy representing the target bit. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>If <code>i &gt;= <a class="el" href="#ac6499d84305124953b21a2458902413c" title="Returns the number of elements in the array.">size()</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a2123bcf12c8d0d1f1d54aee78f617519" title="Unchecked bit access (read/write).">operator[]()</a> </dd></dl>

</div>
</div>
<a id="ab111e8bb70047884fb360b24c08fe683" name="ab111e8bb70047884fb360b24c08fe683"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab111e8bb70047884fb360b24c08fe683">&#9670;&#160;</a></span>at() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">value_type <a class="el" href="classjh_1_1runtime__arr.html">jh::runtime_arr</a>&lt; bool &gt;::at </td>
          <td>(</td>
          <td class="paramtype">std::uint64_t</td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Const bounds-checked bit access (read-only). </p>
<p>Returns the boolean value of the bit at the specified index, performing explicit range checking. If <code>i &gt;= <a class="el" href="#ac6499d84305124953b21a2458902413c" title="Returns the number of elements in the array.">size()</a></code>, an <code>std::out_of_range</code> exception is thrown.</p>
<p>Mirrors <code>std::vector&lt;bool&gt;::at()</code> semantics — returning a plain <code>bool</code> rather than a proxy for const access. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Bit index within <code>[0, <a class="el" href="#ac6499d84305124953b21a2458902413c" title="Returns the number of elements in the array.">size()</a>)</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Boolean value of the bit. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>If <code>i &gt;= <a class="el" href="#ac6499d84305124953b21a2458902413c" title="Returns the number of elements in the array.">size()</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a2123bcf12c8d0d1f1d54aee78f617519" title="Unchecked bit access (read/write).">operator[]()</a> </dd></dl>

</div>
</div>
<a id="a73f8a64a883b89b0ad6f7cb4e0655a06" name="a73f8a64a883b89b0ad6f7cb4e0655a06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73f8a64a883b89b0ad6f7cb4e0655a06">&#9670;&#160;</a></span>data()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classjh_1_1runtime__arr.html">jh::runtime_arr</a>&lt; bool &gt;::data </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel delete">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deleted <code><a class="el" href="#a73f8a64a883b89b0ad6f7cb4e0655a06" title="Deleted data() function — raw pointer access is not valid for bit-packed layout.">data()</a></code> function — raw pointer access is not valid for bit-packed layout. </p>
<p><b>Behavior</b> </p><ul>
<li>
This specialization intentionally deletes <code><a class="el" href="#a73f8a64a883b89b0ad6f7cb4e0655a06" title="Deleted data() function — raw pointer access is not valid for bit-packed layout.">data()</a></code> to prevent treating the bit-packed storage as a contiguous <code>bool*</code> array. </li>
<li>
Internally, elements are stored as bits within 64-bit words, not as individual bytes. </li>
</ul>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>
Use <code><a class="el" href="#a9f16b30a3fb84936d7b664c0c10b3da3" title="Provides mutable access to the underlying word buffer.">raw_data()</a></code> and <code><a class="el" href="#a8edc8c849f99dbad23b688f58256eb72" title="Returns the number of 64-bit words used internally to store all bits.">raw_word_count()</a></code> to access the underlying <code>uint64_t</code> storage for low-level operations. </li>
<li>
This deletion ensures type safety and prevents undefined behavior due to misaligned access. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a346ef097f22aea5c97f2513dc512b51e" name="a346ef097f22aea5c97f2513dc512b51e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a346ef097f22aea5c97f2513dc512b51e">&#9670;&#160;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classjh_1_1runtime__arr.html">jh::runtime_arr</a>&lt; bool &gt;::empty </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether the array is empty. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code><a class="el" href="#ac6499d84305124953b21a2458902413c" title="Returns the number of elements in the array.">size()</a> == 0</code>, otherwise <code>false</code>. </dd></dl>

</div>
</div>
<a id="ad26e47c9a94647fc6babbce42a771495" name="ad26e47c9a94647fc6babbce42a771495"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad26e47c9a94647fc6babbce42a771495">&#9670;&#160;</a></span>operator std::vector&lt; bool &gt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classjh_1_1runtime__arr.html">jh::runtime_arr</a>&lt; bool &gt;::operator std::vector&lt; bool &gt; </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel explicit">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts the bit array into std::vector&lt;bool&gt;. Elements are copied bit-by-bit. </p>
<dl class="section note"><dt>Note</dt><dd>This operation consumes the array (clears and resets storage). </dd></dl>

</div>
</div>
<a id="ac811ed28b9b1aef06521b90a3c6e2988" name="ac811ed28b9b1aef06521b90a3c6e2988"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac811ed28b9b1aef06521b90a3c6e2988">&#9670;&#160;</a></span>operator std::vector&lt; bool &gt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classjh_1_1runtime__arr.html">jh::runtime_arr</a>&lt; bool, <a class="el" href="structjh_1_1typed_1_1monostate.html">typed::monostate</a> &gt;::operator std::vector&lt; bool &gt; </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel explicit">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts the array into a <code>std::vector&lt;T&gt;</code> by moving its contents. </p>
<p>This conversion performs a one-way ownership transfer from <code>runtime_arr&lt;T&gt;</code> to <code>std::vector&lt;T&gt;</code>, consuming the source in the process. After the conversion, the original <code><a class="el" href="classjh_1_1runtime__arr.html" title="A move-only, fixed-capacity array with runtime-determined length and RAII-based ownership.">runtime_arr</a></code> becomes an empty, valid but unspecified object (<code><a class="el" href="#ac6499d84305124953b21a2458902413c" title="Returns the number of elements in the array.">size()</a> == 0</code>, <code><a class="el" href="#a73f8a64a883b89b0ad6f7cb4e0655a06" title="Deleted data() function — raw pointer access is not valid for bit-packed layout.">data()</a> == nullptr</code>).</p>
<p><b>Behavior</b> </p><ul>
<li>
<b>POD-like types (<code>jh::pod_like&lt;T&gt;</code>):</b> Performs a raw <code>std::memcpy</code> for maximal performance. The operation is equivalent to copying a contiguous byte buffer. </li>
<li>
<b>Non-POD types:</b> Uses <code>std::make_move_iterator</code> to move-construct each element into the target vector, ensuring proper object semantics. </li>
</ul>
<p><b>Symmetry</b> </p>
<p>This operator complements the constructor <code>runtime_arr(std::vector&lt;T&gt;&amp;&amp;)</code>, enabling seamless two-way transfer between <code>std::vector&lt;T&gt;</code> and <code>runtime_arr&lt;T&gt;</code> with full move semantics. Both conversions leave the source container in a valid but empty state, ensuring safe RAII destruction. </p>
<dl class="section note"><dt>Note</dt><dd>This operator is only available on rvalues (<code>runtime_arr&lt;T&gt;&amp;&amp;</code>), preventing accidental copies. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>runtime_arr(std::vector&lt;T&gt;&amp;&amp;) </dd></dl>

</div>
</div>
<a id="a2d8821621a9ad24da60f52d73f0b50d5" name="a2d8821621a9ad24da60f52d73f0b50d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d8821621a9ad24da60f52d73f0b50d5">&#9670;&#160;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a71eab497ab66de805e35ad2ee0a6238f">runtime_arr</a>&lt; bool &gt; &amp; <a class="el" href="classjh_1_1runtime__arr.html">jh::runtime_arr</a>&lt; bool &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a71eab497ab66de805e35ad2ee0a6238f">runtime_arr</a>&lt; bool &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment operator — transfers ownership of the bit-packed buffer. </p>
<p><b>Behavior</b> </p><ul>
<li>
Releases any existing owned buffer. </li>
<li>
Takes ownership of <code>other</code>'s bit-packed storage. </li>
<li>
Leaves <code>other</code> empty and valid. </li>
<li>
Performs no memory allocation or element-wise operation. </li>
</ul>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<p>This operator is <code>noexcept</code> and preserves RAII semantics. Copy assignment remains deleted to enforce unique ownership. </p>

</div>
</div>
<a id="a4e730db56106e04c76a6ebf5eb002872" name="a4e730db56106e04c76a6ebf5eb002872"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e730db56106e04c76a6ebf5eb002872">&#9670;&#160;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">value_type <a class="el" href="classjh_1_1runtime__arr.html">jh::runtime_arr</a>&lt; bool &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">std::uint64_t</td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unchecked const bit access (read-only). </p>
<p>Provides read-only access to the bit at the specified index without bounds checking (undefined behavior if out of range). Returns the boolean value corresponding to the bit's state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Bit index within <code>[0, <a class="el" href="#ac6499d84305124953b21a2458902413c" title="Returns the number of elements in the array.">size()</a>)</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Boolean value of the bit. </dd></dl>

</div>
</div>
<a id="a2123bcf12c8d0d1f1d54aee78f617519" name="a2123bcf12c8d0d1f1d54aee78f617519"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2123bcf12c8d0d1f1d54aee78f617519">&#9670;&#160;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reference <a class="el" href="classjh_1_1runtime__arr.html">jh::runtime_arr</a>&lt; bool &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">std::uint64_t</td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unchecked bit access (read/write). </p>
<p>Returns a proxy reference to the bit at the specified index without performing bounds checking (undefined behavior if out of range). Equivalent to <code>*(<a class="el" href="#a73f8a64a883b89b0ad6f7cb4e0655a06" title="Deleted data() function — raw pointer access is not valid for bit-packed layout.">data()</a> + index)</code> in semantics, but operates on a bit-packed storage layout.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Bit index within <code>[0, <a class="el" href="#ac6499d84305124953b21a2458902413c" title="Returns the number of elements in the array.">size()</a>)</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference proxy object representing the targeted bit. </dd></dl>

</div>
</div>
<a id="ae799ec0f99656a3c3101374ded1ebf0e" name="ae799ec0f99656a3c3101374ded1ebf0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae799ec0f99656a3c3101374ded1ebf0e">&#9670;&#160;</a></span>raw_data() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const raw_type * <a class="el" href="classjh_1_1runtime__arr.html">jh::runtime_arr</a>&lt; bool &gt;::raw_data </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides const access to the underlying word buffer. </p>
<p><b>Behavior</b> </p><ul>
<li>
Returns a const pointer to the <code>uint64_t</code> buffer. </li>
<li>
Useful for inspection or bitwise read-only operations. </li>
</ul>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>
Equivalent to the mutable form, but guarantees const-correct access. </li>
<li>
Replaces <code>const <a class="el" href="#a73f8a64a883b89b0ad6f7cb4e0655a06" title="Deleted data() function — raw pointer access is not valid for bit-packed layout.">data()</a></code> from the generic <code>runtime_arr&lt;T&gt;</code> template. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a9f16b30a3fb84936d7b664c0c10b3da3" name="a9f16b30a3fb84936d7b664c0c10b3da3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f16b30a3fb84936d7b664c0c10b3da3">&#9670;&#160;</a></span>raw_data() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">raw_type * <a class="el" href="classjh_1_1runtime__arr.html">jh::runtime_arr</a>&lt; bool &gt;::raw_data </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides mutable access to the underlying word buffer. </p>
<p><b>Behavior</b> </p><ul>
<li>
Returns a pointer to the internal <code>uint64_t</code> storage array. </li>
<li>
Each word contains 64 logical bits of packed boolean data. </li>
<li>
Intended for low-level bitwise operations, serialization, or direct memory inspection. </li>
</ul>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>
This function replaces <code><a class="el" href="#a73f8a64a883b89b0ad6f7cb4e0655a06" title="Deleted data() function — raw pointer access is not valid for bit-packed layout.">data()</a></code> from the generic template, since the bit-packed layout is <b>not</b> contiguous in <code>bool</code> units. </li>
<li>
Users must manually interpret the bit positions when reading or writing raw words. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a8edc8c849f99dbad23b688f58256eb72" name="a8edc8c849f99dbad23b688f58256eb72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8edc8c849f99dbad23b688f58256eb72">&#9670;&#160;</a></span>raw_word_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classjh_1_1runtime__arr.html">jh::runtime_arr</a>&lt; bool &gt;::raw_word_count </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of 64-bit words used internally to store all bits. </p>
<p><b>Behavior</b> </p><ul>
<li>
Computes <code>(<a class="el" href="#ac6499d84305124953b21a2458902413c" title="Returns the number of elements in the array.">size()</a> + 63) / 64</code>, rounding up to the nearest full word. </li>
<li>
Matches the physical storage capacity, not just logical bit count. </li>
</ul>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>
Used in conjunction with <code><a class="el" href="#a9f16b30a3fb84936d7b664c0c10b3da3" title="Provides mutable access to the underlying word buffer.">raw_data()</a></code> for raw memory operations. </li>
<li>
Provided as a safe, constexpr-accessible alternative to manual division. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a5e6383122da73f10315ac279a0fd350e" name="a5e6383122da73f10315ac279a0fd350e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e6383122da73f10315ac279a0fd350e">&#9670;&#160;</a></span>reset_all()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classjh_1_1runtime__arr.html">jh::runtime_arr</a>&lt; bool &gt;::reset_all </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resets all bits in the bit-packed array to zero. </p>
<p><b>Behavior</b> </p><ul>
<li>
Clears all stored bits by setting every underlying 64-bit word to <code>0</code>. </li>
<li>
After the call, all logical elements read as <code>false</code>. </li>
</ul>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>
This replaces the generic <code><a class="el" href="#a5e6383122da73f10315ac279a0fd350e" title="Resets all bits in the bit-packed array to zero.">reset_all()</a></code> implementation for <code>runtime_arr&lt;T&gt;</code>, which performs element-wise assignment. </li>
<li>
Uses <code>std::memset</code> for efficient zeroing of the bit storage buffer. </li>
<li>
Equivalent to <code>std::fill(<a class="el" href="#abd8d0d24d9416c194ee54a59c81a2cc8" title="Mutable begin iterator over bits.">begin()</a>, <a class="el" href="#a74a30f45693ff0176a35fbc7b53172de" title="Mutable end iterator over bits.">end()</a>, false)</code> but significantly faster. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a48286d83562d511c3f2166dd1e069508" name="a48286d83562d511c3f2166dd1e069508"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48286d83562d511c3f2166dd1e069508">&#9670;&#160;</a></span>set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classjh_1_1runtime__arr.html">jh::runtime_arr</a>&lt; bool &gt;::set </td>
          <td>(</td>
          <td class="paramtype">std::uint64_t</td>          <td class="paramname"><span class="paramname"><em>i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>val</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets or clears the bit at given index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Bit index </td></tr>
    <tr><td class="paramname">val</td><td>Bit value to assign (<code>true</code> by default) </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if i out of bounds </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac6499d84305124953b21a2458902413c" name="ac6499d84305124953b21a2458902413c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6499d84305124953b21a2458902413c">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classjh_1_1runtime__arr.html">jh::runtime_arr</a>&lt; bool &gt;::size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements in the array. </p>
<dl class="section return"><dt>Returns</dt><dd>Number of elements currently stored. </dd></dl>

</div>
</div>
<a id="aaf0bb20a39547e8ce2ba2945ca3282ae" name="aaf0bb20a39547e8ce2ba2945ca3282ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf0bb20a39547e8ce2ba2945ca3282ae">&#9670;&#160;</a></span>test()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">value_type <a class="el" href="classjh_1_1runtime__arr.html">jh::runtime_arr</a>&lt; bool &gt;::test </td>
          <td>(</td>
          <td class="paramtype">std::uint64_t</td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests if the bit at index is set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Bit index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if bit is <span class="tt">1</span>, <code>false</code> if <span class="tt">0</span> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if i out of bounds </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6327809b0400edcb799886db8a9baa47" name="a6327809b0400edcb799886db8a9baa47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6327809b0400edcb799886db8a9baa47">&#9670;&#160;</a></span>unset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classjh_1_1runtime__arr.html">jh::runtime_arr</a>&lt; bool &gt;::unset </td>
          <td>(</td>
          <td class="paramtype">std::uint64_t</td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears the bit at given index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Bit index </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if i out of bounds </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/jh/core/<a class="el" href="">runtime_arr.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
</div> <!-- top -->
<hr class="footer"/>
<div class="footer">
    <img class="footer-logo" src="Ojing.svg" alt="Ojing"/>
    <div class="footer-text">
        JH-Toolkit v1.4.0 · Generated by Doxygen
    </div>
    <div class="footer-note">
        We primarily support embedded documentation views in IDEs (classic CLion).
        To ensure compatibility with embedded rendering, some example code in this
        documentation intentionally contains HTML entities.
        In certain cases, Doxygen does not unescape these entities correctly.
        This is a known limitation and currently has no workaround.
    </div>
</div>
</body>
</html>
