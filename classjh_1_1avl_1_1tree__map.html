<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.16.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>JH-Toolkit: jh::avl::tree_map&lt; K, V, Alloc &gt; Class Template Reference</title>
<link rel="icon" href="Jindallae.svg" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="Oree.svg"/></td>
  <td id="projectalign">
   <div id="projectname">JH-Toolkit<span id="projectnumber">&#160;v1.4.0</span>
   </div>
   <div id="projectbrief">An engineering-oriented C++20 toolkit with duck-typed concepts, static design, async coroutines, and semantic containers — header-only, RTTI-free, and concurrency-friendly.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.16.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('classjh_1_1avl_1_1tree__map.html','','classjh_1_1avl_1_1tree__map-members'); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">jh::avl::tree_map&lt; K, V, Alloc &gt; Class Template Reference<span class="mlabels"><span class="mlabel final">final</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>Contiguous-array AVL tree used by <code><a class="el" href="namespacejh.html#adc97eb86056b9268c8b5c7378587c2be" title="Ordered associative map based on a contiguous-array AVL tree.">jh::ordered_map</a></code> and <code><a class="el" href="namespacejh.html#a7d49c250af115c5a63acb88c1b38c3ec" title="Ordered associative set based on a contiguous-array AVL tree.">jh::ordered_set</a></code>.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="">jh/core/ordered_map.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:iterator" id="r_iterator"><td class="memItemLeft">struct &#160;</td><td class="memItemRight"><a class="el" href="structjh_1_1avl_1_1tree__map_1_1iterator.html">iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bidirectional iterator providing in-order traversal.  <a href="structjh_1_1avl_1_1tree__map_1_1iterator.html#details">More...</a><br /></td></tr>
<tr class="memitem:const_5Fiterator" id="r_const_5Fiterator"><td class="memItemLeft">struct &#160;</td><td class="memItemRight"><a class="el" href="structjh_1_1avl_1_1tree__map_1_1const__iterator.html">const_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const bidirectional iterator for in-order traversal.  <a href="structjh_1_1avl_1_1tree__map_1_1const__iterator.html#details">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-types" class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a40a81f679b9c9bddf8a3daa0a59197a5" id="r_a40a81f679b9c9bddf8a3daa0a59197a5"><td class="memItemLeft"><a id="a40a81f679b9c9bddf8a3daa0a59197a5" name="a40a81f679b9c9bddf8a3daa0a59197a5"></a>
using&#160;</td><td class="memItemRight"><b>vector_type</b> = detail::node_vector_type&lt;K, V, Alloc&gt;</td></tr>
<tr class="memdesc:a40a81f679b9c9bddf8a3daa0a59197a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector storage type for all nodes. <br /></td></tr>
<tr class="memitem:a25de9175a7df73402418dfe22d7501ad" id="r_a25de9175a7df73402418dfe22d7501ad"><td class="memItemLeft"><a id="a25de9175a7df73402418dfe22d7501ad" name="a25de9175a7df73402418dfe22d7501ad"></a>
using&#160;</td><td class="memItemRight"><b>value_type</b> = detail::value_t&lt;K, V&gt;</td></tr>
<tr class="memdesc:a25de9175a7df73402418dfe22d7501ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Public value type (<code>K</code> for set, <code>std::pair&lt;const K, V&gt;</code> for map). <br /></td></tr>
<tr class="memitem:ae9593f170539c50863517dfd18e8d28a" id="r_ae9593f170539c50863517dfd18e8d28a"><td class="memItemLeft">using&#160;</td><td class="memItemRight"><a class="el" href="#ae9593f170539c50863517dfd18e8d28a">reverse_iterator</a> = std::reverse_iterator&lt;<a class="el" href="structjh_1_1avl_1_1tree__map_1_1iterator.html">iterator</a>&gt;</td></tr>
<tr class="memdesc:ae9593f170539c50863517dfd18e8d28a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse iterator type.  <br /></td></tr>
<tr class="memitem:a94927512ed290484105fa42e90d225d7" id="r_a94927512ed290484105fa42e90d225d7"><td class="memItemLeft">using&#160;</td><td class="memItemRight"><a class="el" href="#a94927512ed290484105fa42e90d225d7">const_reverse_iterator</a> = std::reverse_iterator&lt;<a class="el" href="structjh_1_1avl_1_1tree__map_1_1const__iterator.html">const_iterator</a>&gt;</td></tr>
<tr class="memdesc:a94927512ed290484105fa42e90d225d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const reverse iterator type.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5b72fe2921a19e705aa742099bc72d84" id="r_a5b72fe2921a19e705aa742099bc72d84"><td class="memItemLeft"><a id="a5b72fe2921a19e705aa742099bc72d84" name="a5b72fe2921a19e705aa742099bc72d84"></a>
&#160;</td><td class="memItemRight"><b>tree_map</b> () noexcept(noexcept(alloc_type()))</td></tr>
<tr class="memdesc:a5b72fe2921a19e705aa742099bc72d84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor creating an empty tree with default allocator. <br /></td></tr>
<tr class="memitem:a70d9f020249432da83330f77880d0562" id="r_a70d9f020249432da83330f77880d0562"><td class="memItemLeft">&#160;</td><td class="memItemRight"><a class="el" href="#a70d9f020249432da83330f77880d0562">tree_map</a> (const Alloc &amp;alloc)</td></tr>
<tr class="memdesc:a70d9f020249432da83330f77880d0562"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an empty tree with a specified allocator.  <br /></td></tr>
<tr class="memitem:ae9f22b3346b3b3d3bdadd67f0877bf60" id="r_ae9f22b3346b3b3d3bdadd67f0877bf60"><td class="memTemplParams" colspan="2">template&lt;typename K_, typename V_, typename Alloc_&gt; </td></tr>
<tr class="memitem:ae9f22b3346b3b3d3bdadd67f0877bf60 template"><td class="memItemLeft">&#160;</td><td class="memItemRight"><a class="el" href="#ae9f22b3346b3b3d3bdadd67f0877bf60">tree_map</a> (const tree_map&lt; K_, V_, Alloc_ &gt; &amp;other)</td></tr>
<tr class="memdesc:ae9f22b3346b3b3d3bdadd67f0877bf60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy-construct from another tree whose canonical key/value types match this tree and whose allocator type is identical.  <br /></td></tr>
<tr class="memitem:ae9f22b3346b3b3d3bdadd67f0877bf60" id="r_ae9f22b3346b3b3d3bdadd67f0877bf60"><td class="memTemplParams" colspan="2">template&lt;typename K_, typename V_, typename Alloc_&gt; </td></tr>
<tr class="memitem:ae9f22b3346b3b3d3bdadd67f0877bf60 template"><td class="memItemLeft">&#160;</td><td class="memItemRight"><a class="el" href="#ae9f22b3346b3b3d3bdadd67f0877bf60">tree_map</a> (const tree_map&lt; K_, V_, Alloc_ &gt; &amp;other)</td></tr>
<tr class="memdesc:ae9f22b3346b3b3d3bdadd67f0877bf60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy-construct from another tree whose canonical key/value types match this tree, using a rebound default allocator.  <br /></td></tr>
<tr class="memitem:ada3d1478e5816bf3891bed7ce16c40ba" id="r_ada3d1478e5816bf3891bed7ce16c40ba"><td class="memTemplParams" colspan="2">template&lt;typename K_, typename V_, typename Alloc_&gt; </td></tr>
<tr class="memitem:ada3d1478e5816bf3891bed7ce16c40ba template"><td class="memItemLeft">&#160;</td><td class="memItemRight"><a class="el" href="#ada3d1478e5816bf3891bed7ce16c40ba">tree_map</a> (const tree_map&lt; K_, V_, Alloc_ &gt; &amp;other, const Alloc &amp;alloc)</td></tr>
<tr class="memdesc:ada3d1478e5816bf3891bed7ce16c40ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy-construct from another tree whose canonical key/value types match this tree, using a user-supplied allocator.  <br /></td></tr>
<tr class="memitem:a3bde3657471bc2ced530929ee8b12ad2" id="r_a3bde3657471bc2ced530929ee8b12ad2"><td class="memTemplParams" colspan="2">template&lt;typename K_, typename V_, typename Alloc_&gt; </td></tr>
<tr class="memitem:a3bde3657471bc2ced530929ee8b12ad2 template"><td class="memItemLeft">&#160;</td><td class="memItemRight"><a class="el" href="#a3bde3657471bc2ced530929ee8b12ad2">tree_map</a> (tree_map&lt; K_, V_, Alloc_ &gt; &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:a3bde3657471bc2ced530929ee8b12ad2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move-construct from another tree whose canonical key/value types match this tree and whose allocator type is identical.  <br /></td></tr>
<tr class="memitem:a9b1bc7bd9cd172a620aa317d74a9aa34" id="r_a9b1bc7bd9cd172a620aa317d74a9aa34"><td class="memTemplParams" colspan="2">template&lt;typename K_, typename V_, typename Alloc_&gt; </td></tr>
<tr class="memitem:a9b1bc7bd9cd172a620aa317d74a9aa34 template"><td class="memItemLeft">&#160;</td><td class="memItemRight"><a class="el" href="#a9b1bc7bd9cd172a620aa317d74a9aa34">tree_map</a> (tree_map&lt; K_, V_, Alloc_ &gt; &amp;&amp;other)</td></tr>
<tr class="memdesc:a9b1bc7bd9cd172a620aa317d74a9aa34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move-construct from another tree whose canonical key/value types match this tree, using a rebound default allocator.  <br /></td></tr>
<tr class="memitem:a306197bf40fcf07fb9d599285406212b" id="r_a306197bf40fcf07fb9d599285406212b"><td class="memTemplParams" colspan="2">template&lt;typename K_, typename V_, typename Alloc_&gt; </td></tr>
<tr class="memitem:a306197bf40fcf07fb9d599285406212b template"><td class="memItemLeft">&#160;</td><td class="memItemRight"><a class="el" href="#a306197bf40fcf07fb9d599285406212b">tree_map</a> (tree_map&lt; K_, V_, Alloc_ &gt; &amp;&amp;other, const Alloc &amp;alloc)</td></tr>
<tr class="memdesc:a306197bf40fcf07fb9d599285406212b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move-construct from another tree whose canonical key/value types match this tree, using a user-supplied allocator.  <br /></td></tr>
<tr class="memitem:a5b8d6f0d9e6bd7c196e825cba002b646" id="r_a5b8d6f0d9e6bd7c196e825cba002b646"><td class="memItemLeft"><a class="el" href="structjh_1_1avl_1_1tree__map_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight"><a class="el" href="#a5b8d6f0d9e6bd7c196e825cba002b646">begin</a> ()</td></tr>
<tr class="memdesc:a5b8d6f0d9e6bd7c196e825cba002b646"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an iterator to the smallest element.  <br /></td></tr>
<tr class="memitem:a8a853f97d468ebc517ae421526a31b42" id="r_a8a853f97d468ebc517ae421526a31b42"><td class="memItemLeft"><a class="el" href="structjh_1_1avl_1_1tree__map_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight"><a class="el" href="#a8a853f97d468ebc517ae421526a31b42">end</a> ()</td></tr>
<tr class="memdesc:a8a853f97d468ebc517ae421526a31b42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the past-the-end iterator.  <br /></td></tr>
<tr class="memitem:a69c943c681f9012516cf6902d6f01e8b" id="r_a69c943c681f9012516cf6902d6f01e8b"><td class="memItemLeft"><a class="el" href="structjh_1_1avl_1_1tree__map_1_1const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight"><a class="el" href="#a69c943c681f9012516cf6902d6f01e8b">begin</a> () const</td></tr>
<tr class="memdesc:a69c943c681f9012516cf6902d6f01e8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const iterator to the smallest element.  <br /></td></tr>
<tr class="memitem:a97f3688ceca198b84f9ab96230b9059b" id="r_a97f3688ceca198b84f9ab96230b9059b"><td class="memItemLeft"><a id="a97f3688ceca198b84f9ab96230b9059b" name="a97f3688ceca198b84f9ab96230b9059b"></a>
<a class="el" href="structjh_1_1avl_1_1tree__map_1_1const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight"><b>end</b> () const</td></tr>
<tr class="memdesc:a97f3688ceca198b84f9ab96230b9059b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the const past-the-end iterator. <br /></td></tr>
<tr class="memitem:a8a212ea5c888a1b76c466d423d48da42" id="r_a8a212ea5c888a1b76c466d423d48da42"><td class="memItemLeft"><a class="el" href="structjh_1_1avl_1_1tree__map_1_1const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight"><a class="el" href="#a8a212ea5c888a1b76c466d423d48da42">cbegin</a> () const</td></tr>
<tr class="memdesc:a8a212ea5c888a1b76c466d423d48da42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const iterator to the first element.  <br /></td></tr>
<tr class="memitem:afe120fb480aa2c50a4f532b77223f4b1" id="r_afe120fb480aa2c50a4f532b77223f4b1"><td class="memItemLeft"><a class="el" href="structjh_1_1avl_1_1tree__map_1_1const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight"><a class="el" href="#afe120fb480aa2c50a4f532b77223f4b1">cend</a> () const</td></tr>
<tr class="memdesc:afe120fb480aa2c50a4f532b77223f4b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the const past-the-end iterator.  <br /></td></tr>
<tr class="memitem:aa8bcd9da7375893c15d982b7f93f7de4" id="r_aa8bcd9da7375893c15d982b7f93f7de4"><td class="memItemLeft"><a class="el" href="#ae9593f170539c50863517dfd18e8d28a">reverse_iterator</a>&#160;</td><td class="memItemRight"><a class="el" href="#aa8bcd9da7375893c15d982b7f93f7de4">rbegin</a> ()</td></tr>
<tr class="memdesc:aa8bcd9da7375893c15d982b7f93f7de4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reverse iterator to the last element.  <br /></td></tr>
<tr class="memitem:abab95b31b2267ec3ebb4d6ad6d07063d" id="r_abab95b31b2267ec3ebb4d6ad6d07063d"><td class="memItemLeft"><a class="el" href="#ae9593f170539c50863517dfd18e8d28a">reverse_iterator</a>&#160;</td><td class="memItemRight"><a class="el" href="#abab95b31b2267ec3ebb4d6ad6d07063d">rend</a> ()</td></tr>
<tr class="memdesc:abab95b31b2267ec3ebb4d6ad6d07063d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the reverse past-the-end iterator.  <br /></td></tr>
<tr class="memitem:a89e0a86254e8c10257f5db6001a68b54" id="r_a89e0a86254e8c10257f5db6001a68b54"><td class="memItemLeft"><a class="el" href="#a94927512ed290484105fa42e90d225d7">const_reverse_iterator</a>&#160;</td><td class="memItemRight"><a class="el" href="#a89e0a86254e8c10257f5db6001a68b54">rbegin</a> () const</td></tr>
<tr class="memdesc:a89e0a86254e8c10257f5db6001a68b54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const reverse iterator to the last element.  <br /></td></tr>
<tr class="memitem:a989f84dfac9c4962148ce2029188e8d3" id="r_a989f84dfac9c4962148ce2029188e8d3"><td class="memItemLeft"><a class="el" href="#a94927512ed290484105fa42e90d225d7">const_reverse_iterator</a>&#160;</td><td class="memItemRight"><a class="el" href="#a989f84dfac9c4962148ce2029188e8d3">rend</a> () const</td></tr>
<tr class="memdesc:a989f84dfac9c4962148ce2029188e8d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the const reverse past-the-end iterator.  <br /></td></tr>
<tr class="memitem:a177ba6c84038c069382cfa8340db1e73" id="r_a177ba6c84038c069382cfa8340db1e73"><td class="memItemLeft"><a class="el" href="#a94927512ed290484105fa42e90d225d7">const_reverse_iterator</a>&#160;</td><td class="memItemRight"><a class="el" href="#a177ba6c84038c069382cfa8340db1e73">crbegin</a> () const</td></tr>
<tr class="memdesc:a177ba6c84038c069382cfa8340db1e73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const reverse iterator to the last element.  <br /></td></tr>
<tr class="memitem:a67f9a8d531276aa9c92afd3b16a5562d" id="r_a67f9a8d531276aa9c92afd3b16a5562d"><td class="memItemLeft"><a class="el" href="#a94927512ed290484105fa42e90d225d7">const_reverse_iterator</a>&#160;</td><td class="memItemRight"><a class="el" href="#a67f9a8d531276aa9c92afd3b16a5562d">crend</a> () const</td></tr>
<tr class="memdesc:a67f9a8d531276aa9c92afd3b16a5562d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the const reverse past-the-end iterator.  <br /></td></tr>
<tr class="memitem:a683fcf206121803f0f323f2b2977177d" id="r_a683fcf206121803f0f323f2b2977177d"><td class="memItemLeft"><a class="el" href="structjh_1_1avl_1_1tree__map_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight"><a class="el" href="#a683fcf206121803f0f323f2b2977177d">find</a> (const <a class="el" href="structjh_1_1avl_1_1avl__node.html#aa0264e8debb087c2f5f3a000960b32f9">node_type::key_type</a> &amp;key)</td></tr>
<tr class="memdesc:a683fcf206121803f0f323f2b2977177d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Locate the element with the specified key.  <br /></td></tr>
<tr class="memitem:abf95e5d0124567972d95892e93c9e7f4" id="r_abf95e5d0124567972d95892e93c9e7f4"><td class="memItemLeft"><a class="el" href="structjh_1_1avl_1_1tree__map_1_1const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight"><a class="el" href="#abf95e5d0124567972d95892e93c9e7f4">find</a> (const <a class="el" href="structjh_1_1avl_1_1avl__node.html#aa0264e8debb087c2f5f3a000960b32f9">node_type::key_type</a> &amp;key) const</td></tr>
<tr class="memdesc:abf95e5d0124567972d95892e93c9e7f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Locate the element with the specified key (const overload).  <br /></td></tr>
<tr class="memitem:a3f0580fb7892b7a82a26d453f7114961" id="r_a3f0580fb7892b7a82a26d453f7114961"><td class="memItemLeft">std::pair&lt; <a class="el" href="structjh_1_1avl_1_1tree__map_1_1iterator.html">iterator</a>, bool &gt;&#160;</td><td class="memItemRight"><a class="el" href="#a3f0580fb7892b7a82a26d453f7114961">insert</a> (const <a class="el" href="#a25de9175a7df73402418dfe22d7501ad">value_type</a> &amp;key)</td></tr>
<tr class="memdesc:a3f0580fb7892b7a82a26d453f7114961"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a key into the set.  <br /></td></tr>
<tr class="memitem:a0e3e75a4ccaed89bb7b3d28cb5ca4a1d" id="r_a0e3e75a4ccaed89bb7b3d28cb5ca4a1d"><td class="memItemLeft">std::pair&lt; <a class="el" href="structjh_1_1avl_1_1tree__map_1_1iterator.html">iterator</a>, bool &gt;&#160;</td><td class="memItemRight"><a class="el" href="#a0e3e75a4ccaed89bb7b3d28cb5ca4a1d">insert</a> (<a class="el" href="#a25de9175a7df73402418dfe22d7501ad">value_type</a> &amp;key)</td></tr>
<tr class="memdesc:a0e3e75a4ccaed89bb7b3d28cb5ca4a1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a key into the set (non-const reference overload).  <br /></td></tr>
<tr class="memitem:a510fec4222429f6631268dc167d144a4" id="r_a510fec4222429f6631268dc167d144a4"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; <br />
requires (<a class="el" href="conceptjh_1_1typed_1_1monostate__t.html">jh::typed::monostate_t</a>&lt;V&gt;)</td></tr>
<tr class="memitem:a510fec4222429f6631268dc167d144a4 template"><td class="memItemLeft">std::pair&lt; <a class="el" href="structjh_1_1avl_1_1tree__map_1_1iterator.html">iterator</a>, bool &gt;&#160;</td><td class="memItemRight"><a class="el" href="#a510fec4222429f6631268dc167d144a4">emplace</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a510fec4222429f6631268dc167d144a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a key and insert it into the set.  <br /></td></tr>
<tr class="memitem:ad7b226fc203640840d1e4b95162010a0" id="r_ad7b226fc203640840d1e4b95162010a0"><td class="memTemplParams" colspan="2">template&lt;typename P&gt; <br />
requires (!<a class="el" href="conceptjh_1_1typed_1_1monostate__t.html">jh::typed::monostate_t</a>&lt;V&gt;)</td></tr>
<tr class="memitem:ad7b226fc203640840d1e4b95162010a0 template"><td class="memItemLeft">std::pair&lt; <a class="el" href="structjh_1_1avl_1_1tree__map_1_1iterator.html">iterator</a>, bool &gt;&#160;</td><td class="memItemRight"><a class="el" href="#ad7b226fc203640840d1e4b95162010a0">insert</a> (P &amp;&amp;p)</td></tr>
<tr class="memdesc:ad7b226fc203640840d1e4b95162010a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a key-value pair into the map.  <br /></td></tr>
<tr class="memitem:ae45799924b993fbcb9741f65cc37006a" id="r_ae45799924b993fbcb9741f65cc37006a"><td class="memItemLeft">std::pair&lt; <a class="el" href="structjh_1_1avl_1_1tree__map_1_1iterator.html">iterator</a>, bool &gt;&#160;</td><td class="memItemRight"><a class="el" href="#ae45799924b993fbcb9741f65cc37006a">insert_or_assign</a> (<a class="el" href="structjh_1_1avl_1_1avl__node.html#aa0264e8debb087c2f5f3a000960b32f9">node_type::key_type</a> &amp;&amp;k, <a class="el" href="structjh_1_1avl_1_1avl__node.html#ae977856018d0c4cfd95b43350b63f183">node_type::value_type</a> &amp;&amp;v)</td></tr>
<tr class="memdesc:ae45799924b993fbcb9741f65cc37006a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a key-value pair or assign to the mapped value.  <br /></td></tr>
<tr class="memitem:a7d9364198b0c16c12cdf25317ddf88a9" id="r_a7d9364198b0c16c12cdf25317ddf88a9"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; <br />
requires (!<a class="el" href="conceptjh_1_1typed_1_1monostate__t.html">jh::typed::monostate_t</a>&lt;V&gt;)</td></tr>
<tr class="memitem:a7d9364198b0c16c12cdf25317ddf88a9 template"><td class="memItemLeft">std::pair&lt; <a class="el" href="structjh_1_1avl_1_1tree__map_1_1iterator.html">iterator</a>, bool &gt;&#160;</td><td class="memItemRight"><a class="el" href="#a7d9364198b0c16c12cdf25317ddf88a9">emplace</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a7d9364198b0c16c12cdf25317ddf88a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a key-value pair by constructing it from arbitrary arguments.  <br /></td></tr>
<tr class="memitem:a2e93f05fd88284a3806a44237de6efcd" id="r_a2e93f05fd88284a3806a44237de6efcd"><td class="memItemLeft"><a class="el" href="structjh_1_1avl_1_1avl__node.html#ae977856018d0c4cfd95b43350b63f183">node_type::value_type</a> &amp;&#160;</td><td class="memItemRight"><a class="el" href="#a2e93f05fd88284a3806a44237de6efcd">at</a> (const <a class="el" href="structjh_1_1avl_1_1avl__node.html#aa0264e8debb087c2f5f3a000960b32f9">node_type::key_type</a> &amp;key)</td></tr>
<tr class="memdesc:a2e93f05fd88284a3806a44237de6efcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the mapped value associated with a key.  <br /></td></tr>
<tr class="memitem:ae8343f9668b0505076f54ff8e095637a" id="r_ae8343f9668b0505076f54ff8e095637a"><td class="memItemLeft">const <a class="el" href="structjh_1_1avl_1_1avl__node.html#ae977856018d0c4cfd95b43350b63f183">node_type::value_type</a> &amp;&#160;</td><td class="memItemRight"><a class="el" href="#ae8343f9668b0505076f54ff8e095637a">at</a> (const <a class="el" href="structjh_1_1avl_1_1avl__node.html#aa0264e8debb087c2f5f3a000960b32f9">node_type::key_type</a> &amp;key) const</td></tr>
<tr class="memdesc:ae8343f9668b0505076f54ff8e095637a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the mapped value associated with a key (const overload).  <br /></td></tr>
<tr class="memitem:a6b27059a7b9b8193a31dc51972f3adec" id="r_a6b27059a7b9b8193a31dc51972f3adec"><td class="memItemLeft"><a class="el" href="structjh_1_1avl_1_1avl__node.html#ae977856018d0c4cfd95b43350b63f183">node_type::value_type</a> &amp;&#160;</td><td class="memItemRight"><a class="el" href="#a6b27059a7b9b8193a31dc51972f3adec">operator[]</a> (const <a class="el" href="structjh_1_1avl_1_1avl__node.html#aa0264e8debb087c2f5f3a000960b32f9">node_type::key_type</a> &amp;key)</td></tr>
<tr class="memdesc:a6b27059a7b9b8193a31dc51972f3adec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access or insert the mapped value associated with a key.  <br /></td></tr>
<tr class="memitem:aee51f98147bdfdff4b54b887ec9f3c70" id="r_aee51f98147bdfdff4b54b887ec9f3c70"><td class="memItemLeft">std::size_t&#160;</td><td class="memItemRight"><a class="el" href="#aee51f98147bdfdff4b54b887ec9f3c70">count</a> (const <a class="el" href="structjh_1_1avl_1_1avl__node.html#aa0264e8debb087c2f5f3a000960b32f9">node_type::key_type</a> &amp;key) const</td></tr>
<tr class="memdesc:aee51f98147bdfdff4b54b887ec9f3c70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the number of elements with the specified key.  <br /></td></tr>
<tr class="memitem:a847de47716ae40afdd7ddbdd67d194f5" id="r_a847de47716ae40afdd7ddbdd67d194f5"><td class="memItemLeft"><a class="el" href="structjh_1_1avl_1_1tree__map_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight"><a class="el" href="#a847de47716ae40afdd7ddbdd67d194f5">erase</a> (<a class="el" href="structjh_1_1avl_1_1tree__map_1_1iterator.html">iterator</a> pos)</td></tr>
<tr class="memdesc:a847de47716ae40afdd7ddbdd67d194f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase the element referenced by the given iterator.  <br /></td></tr>
<tr class="memitem:a82eec5247f447c7db0369043e9ec16c2" id="r_a82eec5247f447c7db0369043e9ec16c2"><td class="memItemLeft"><a class="el" href="structjh_1_1avl_1_1tree__map_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight"><a class="el" href="#a82eec5247f447c7db0369043e9ec16c2">erase</a> (<a class="el" href="structjh_1_1avl_1_1tree__map_1_1const__iterator.html">const_iterator</a> pos)</td></tr>
<tr class="memdesc:a82eec5247f447c7db0369043e9ec16c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase the element referenced by the given const iterator.  <br /></td></tr>
<tr class="memitem:a42449562ef47faf0eaa052900eeb5f01" id="r_a42449562ef47faf0eaa052900eeb5f01"><td class="memItemLeft">std::size_t&#160;</td><td class="memItemRight"><a class="el" href="#a42449562ef47faf0eaa052900eeb5f01">erase</a> (const <a class="el" href="structjh_1_1avl_1_1avl__node.html#aa0264e8debb087c2f5f3a000960b32f9">node_type::key_type</a> &amp;key)</td></tr>
<tr class="memdesc:a42449562ef47faf0eaa052900eeb5f01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase the element whose key compares equal to the given key.  <br /></td></tr>
<tr class="memitem:ab04adc15bb8160401992768672be0055" id="r_ab04adc15bb8160401992768672be0055"><td class="memItemLeft"><a class="el" href="structjh_1_1avl_1_1tree__map_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight"><a class="el" href="#ab04adc15bb8160401992768672be0055">lower_bound</a> (const <a class="el" href="structjh_1_1avl_1_1avl__node.html#aa0264e8debb087c2f5f3a000960b32f9">node_type::key_type</a> &amp;key)</td></tr>
<tr class="memdesc:ab04adc15bb8160401992768672be0055"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an iterator to the first element whose key is not less than the given key.  <br /></td></tr>
<tr class="memitem:a75fa1fce1367b92e892b1035f7d25b4d" id="r_a75fa1fce1367b92e892b1035f7d25b4d"><td class="memItemLeft"><a class="el" href="structjh_1_1avl_1_1tree__map_1_1const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight"><a class="el" href="#a75fa1fce1367b92e892b1035f7d25b4d">lower_bound</a> (const <a class="el" href="structjh_1_1avl_1_1avl__node.html#aa0264e8debb087c2f5f3a000960b32f9">node_type::key_type</a> &amp;key) const</td></tr>
<tr class="memdesc:a75fa1fce1367b92e892b1035f7d25b4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const overload of lower_bound.  <br /></td></tr>
<tr class="memitem:afcfab6605fdfea0b969f6ea07c45f276" id="r_afcfab6605fdfea0b969f6ea07c45f276"><td class="memItemLeft"><a class="el" href="structjh_1_1avl_1_1tree__map_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight"><a class="el" href="#afcfab6605fdfea0b969f6ea07c45f276">upper_bound</a> (const <a class="el" href="structjh_1_1avl_1_1avl__node.html#aa0264e8debb087c2f5f3a000960b32f9">node_type::key_type</a> &amp;key)</td></tr>
<tr class="memdesc:afcfab6605fdfea0b969f6ea07c45f276"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an iterator to the first element whose key is greater than the given key.  <br /></td></tr>
<tr class="memitem:a938538d5530056c9a81e543c7602bcad" id="r_a938538d5530056c9a81e543c7602bcad"><td class="memItemLeft"><a id="a938538d5530056c9a81e543c7602bcad" name="a938538d5530056c9a81e543c7602bcad"></a>
<a class="el" href="structjh_1_1avl_1_1tree__map_1_1const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight"><b>upper_bound</b> (const <a class="el" href="structjh_1_1avl_1_1avl__node.html#aa0264e8debb087c2f5f3a000960b32f9">node_type::key_type</a> &amp;key) const</td></tr>
<tr class="memdesc:a938538d5530056c9a81e543c7602bcad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const overload of upper_bound. <br /></td></tr>
<tr class="memitem:ade867e9fdbe62d25f7cc00ddc52b4977" id="r_ade867e9fdbe62d25f7cc00ddc52b4977"><td class="memItemLeft">std::pair&lt; <a class="el" href="structjh_1_1avl_1_1tree__map_1_1iterator.html">iterator</a>, <a class="el" href="structjh_1_1avl_1_1tree__map_1_1iterator.html">iterator</a> &gt;&#160;</td><td class="memItemRight"><a class="el" href="#ade867e9fdbe62d25f7cc00ddc52b4977">equal_range</a> (const <a class="el" href="structjh_1_1avl_1_1avl__node.html#aa0264e8debb087c2f5f3a000960b32f9">node_type::key_type</a> &amp;key)</td></tr>
<tr class="memdesc:ade867e9fdbe62d25f7cc00ddc52b4977"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the range of elements equivalent to the given key.  <br /></td></tr>
<tr class="memitem:aab055af61458cefc9ecb33a569a20920" id="r_aab055af61458cefc9ecb33a569a20920"><td class="memItemLeft">std::pair&lt; <a class="el" href="structjh_1_1avl_1_1tree__map_1_1const__iterator.html">const_iterator</a>, <a class="el" href="structjh_1_1avl_1_1tree__map_1_1const__iterator.html">const_iterator</a> &gt;&#160;</td><td class="memItemRight"><a class="el" href="#aab055af61458cefc9ecb33a569a20920">equal_range</a> (const <a class="el" href="structjh_1_1avl_1_1avl__node.html#aa0264e8debb087c2f5f3a000960b32f9">node_type::key_type</a> &amp;key) const</td></tr>
<tr class="memdesc:aab055af61458cefc9ecb33a569a20920"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the range of elements equivalent to the given key (const overload).  <br /></td></tr>
<tr class="memitem:ad9725c7056eb8d8e5775d9701f5c88ef" id="r_ad9725c7056eb8d8e5775d9701f5c88ef"><td class="memItemLeft"><a id="ad9725c7056eb8d8e5775d9701f5c88ef" name="ad9725c7056eb8d8e5775d9701f5c88ef"></a>
std::size_t&#160;</td><td class="memItemRight"><b>size</b> () const noexcept</td></tr>
<tr class="memdesc:ad9725c7056eb8d8e5775d9701f5c88ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const overload of equal_range. <br /></td></tr>
<tr class="memitem:a86f554db23ffbb11f2fe6149c583e75d" id="r_a86f554db23ffbb11f2fe6149c583e75d"><td class="memItemLeft">bool&#160;</td><td class="memItemRight"><a class="el" href="#a86f554db23ffbb11f2fe6149c583e75d">empty</a> () const noexcept</td></tr>
<tr class="memdesc:a86f554db23ffbb11f2fe6149c583e75d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the container contains no elements.  <br /></td></tr>
<tr class="memitem:ac4cf54b19a4b23d880e6f73098709d03" id="r_ac4cf54b19a4b23d880e6f73098709d03"><td class="memItemLeft">void&#160;</td><td class="memItemRight"><a class="el" href="#ac4cf54b19a4b23d880e6f73098709d03">clear</a> () noexcept</td></tr>
<tr class="memdesc:ac4cf54b19a4b23d880e6f73098709d03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all elements from the container.  <br /></td></tr>
<tr class="memitem:a02d55a785286c84ae7519f56d77cd1aa" id="r_a02d55a785286c84ae7519f56d77cd1aa"><td class="memItemLeft">void&#160;</td><td class="memItemRight"><a class="el" href="#a02d55a785286c84ae7519f56d77cd1aa">reserve</a> (std::size_t n) noexcept(noexcept(nodes_.reserve(n)))</td></tr>
<tr class="memdesc:a02d55a785286c84ae7519f56d77cd1aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserve space for at least n elements.  <br /></td></tr>
<tr class="memitem:acfc314540e7a87c3b08168258834e4d2" id="r_acfc314540e7a87c3b08168258834e4d2"><td class="memItemLeft">void&#160;</td><td class="memItemRight"><a class="el" href="#acfc314540e7a87c3b08168258834e4d2">shrink_to_fit</a> () noexcept(noexcept(nodes_.shrink_to_fit()))</td></tr>
<tr class="memdesc:acfc314540e7a87c3b08168258834e4d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request that the container reduce its capacity.  <br /></td></tr>
<tr class="memitem:a2d96d61e614f43e963c2db906c086d45" id="r_a2d96d61e614f43e963c2db906c086d45"><td class="memTemplParams" colspan="2">template&lt;std::input_iterator It&gt; </td></tr>
<tr class="memitem:a2d96d61e614f43e963c2db906c086d45 template"><td class="memItemLeft">&#160;</td><td class="memItemRight"><a class="el" href="#a2d96d61e614f43e963c2db906c086d45">tree_map</a> (It first, It last)</td></tr>
<tr class="memdesc:a2d96d61e614f43e963c2db906c086d45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a tree by inserting elements from an input iterator range.  <br /></td></tr>
<tr class="memitem:a17ef81ca064f4b1570cc8f9e3e22fcf6" id="r_a17ef81ca064f4b1570cc8f9e3e22fcf6"><td class="memTemplParams" colspan="2">template&lt;std::ranges::input_range R&gt; </td></tr>
<tr class="memitem:a17ef81ca064f4b1570cc8f9e3e22fcf6 template"><td class="memItemLeft">&#160;</td><td class="memItemRight"><a class="el" href="#a17ef81ca064f4b1570cc8f9e3e22fcf6">tree_map</a> (R &amp;&amp;r)</td></tr>
<tr class="memdesc:a17ef81ca064f4b1570cc8f9e3e22fcf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a tree by inserting elements from an input range.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-static-methods" class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:afadb2b518bed652c669489b4d6b1ef55" id="r_afadb2b518bed652c669489b4d6b1ef55"><td class="memTemplParams" colspan="2">template&lt;std::ranges::sized_range R&gt; </td></tr>
<tr class="memitem:afadb2b518bed652c669489b4d6b1ef55 template"><td class="memItemLeft">static <a class="el" href="#a6c85f80ca9075223b0812883d6032f24">tree_map</a>&#160;</td><td class="memItemRight"><a class="el" href="#afadb2b518bed652c669489b4d6b1ef55">from_sorted</a> (R &amp;&amp;r)</td></tr>
<tr class="memdesc:afadb2b518bed652c669489b4d6b1ef55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an AVL tree from an already sorted and unique range.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-friends" class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a6c85f80ca9075223b0812883d6032f24" id="r_a6c85f80ca9075223b0812883d6032f24"><td class="memTemplParams" colspan="2"><a id="a6c85f80ca9075223b0812883d6032f24" name="a6c85f80ca9075223b0812883d6032f24"></a>
template&lt;typename, typename, typename&gt; </td></tr>
<tr class="memitem:a6c85f80ca9075223b0812883d6032f24 template"><td class="memItemLeft">class&#160;</td><td class="memItemRight"><b>tree_map</b></td></tr>
<tr class="memdesc:a6c85f80ca9075223b0812883d6032f24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow cross-instantiation friendship for different K,V,Alloc parameterizations. <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename K, typename V, typename Alloc = std::allocator&lt;detail::value_t&lt;K, V&gt;&gt;&gt;<br />
class jh::avl::tree_map&lt; K, V, Alloc &gt;</div><p>Contiguous-array AVL tree used by <code><a class="el" href="namespacejh.html#adc97eb86056b9268c8b5c7378587c2be" title="Ordered associative map based on a contiguous-array AVL tree.">jh::ordered_map</a></code> and <code><a class="el" href="namespacejh.html#a7d49c250af115c5a63acb88c1b38c3ec" title="Ordered associative set based on a contiguous-array AVL tree.">jh::ordered_set</a></code>. </p>
<h3>Overview</h3>
<p><code><a class="el" href="classjh_1_1avl_1_1tree__map.html">jh::avl::tree_map&lt;K, V, Alloc&gt;</a></code> is the underlying container powering <code><a class="el" href="namespacejh.html#adc97eb86056b9268c8b5c7378587c2be" title="Ordered associative map based on a contiguous-array AVL tree.">jh::ordered_map</a></code> and <code><a class="el" href="namespacejh.html#a7d49c250af115c5a63acb88c1b38c3ec" title="Ordered associative set based on a contiguous-array AVL tree.">jh::ordered_set</a></code>. It implements a <b>contiguous-array AVL tree</b> in which all nodes are stored inside a single dynamic buffer (typically <code>std::vector</code> or a PMR-aware equivalent). Node linkage uses <b>indices</b> instead of pointers, enabling relocatable, fragmentation-free storage with excellent cache locality. </p>
<h3>Purpose &amp; Design Philosophy</h3>
<p>This structure aims to provide an STL-like ordered associative container with performance and predictability guarantees that are difficult to achieve using the traditional node-based red-black tree employed by <code>std::map</code> and <code>std::set</code>. It is not intended as a drop-in replacement, but rather a complementary tool focused on: </p>
<ul>
<li>
<b>Engineering stability</b> in long-running systems </li>
<li>
<b>Zero fragmentation</b> through contiguous storage </li>
<li>
<b>Predictable latency</b> with no per-node allocations </li>
<li>
<b>High traversal speed</b> due to cache-friendly layout </li>
<li>
<b><span class="tt">O(1)</span> <code><a class="el" href="#ac4cf54b19a4b23d880e6f73098709d03" title="Remove all elements from the container.">clear()</a></code></b> behavior, especially with PMR resources </li>
<li>
<b>Optional <span class="tt">O(N)</span> construction</b> from strictly sorted, unique input </li>
</ul>
<p>Unlike the standard library's node-based trees, <code><a class="el" href="classjh_1_1avl_1_1tree__map.html" title="Contiguous-array AVL tree used by jh::ordered_map and jh::ordered_set.">tree_map</a></code> behaves partially like a <code>std::vector</code>: it exposes <code><a class="el" href="#a02d55a785286c84ae7519f56d77cd1aa" title="Reserve space for at least n elements.">reserve()</a></code>, <code><a class="el" href="#acfc314540e7a87c3b08168258834e4d2" title="Request that the container reduce its capacity.">shrink_to_fit()</a></code>, and provides a <code><a class="el" href="#ac4cf54b19a4b23d880e6f73098709d03" title="Remove all elements from the container.">clear()</a></code> operation that simply resets the vector and does not deallocate individual nodes. This makes large-scale clearing and repopulation extremely efficient and stable under PMR allocators. </p>
<h3>Performance Notes</h3>
<p>This contiguous-array AVL tree has distinct performance behavior depending on whether the workload is <b>insertion-heavy</b> or <b>access-heavy</b>. </p>
<h4>Insertion / Construction Cost</h4>
<p>When constructing the tree via repeated <code><a class="el" href="#a3f0580fb7892b7a82a26d453f7114961" title="Insert a key into the set.">insert()</a></code> (i.e. the equivalent of default-constructing and inserting N elements), AVL rebalancing introduces a measurable overhead at small scales. For data sets around 10 k, construction is typically <b>≈ 1.3-1.6×</b> the cost of <code>std::map</code>. As N grows, this overhead rapidly diminishes due to contiguous storage and negligible per-rotation cost; by 500 k elements the difference is only <b>~5-10%</b>, and by 1 million elements insertion cost becomes effectively comparable to <code>std::map</code>. </p>
<p>For strictly sorted and unique input, <code><a class="el" href="#afadb2b518bed652c669489b4d6b1ef55" title="Construct an AVL tree from an already sorted and unique range.">from_sorted()</a></code> bypasses all rotations and achieves <b>near O(N)</b> construction, outperforming any repeated-insert approach (including the standard library). </p>
<h4>Lookup / Traversal Cost</h4>
<p>Access-related operations—<code><a class="el" href="#a683fcf206121803f0f323f2b2977177d" title="Locate the element with the specified key.">find()</a></code>, in-order traversal, iteration—benefit strongly from contiguous memory layout and the smaller height of AVL trees. Beyond ~5 k elements, these operations are consistently faster than <code>std::map</code>, and remain faster at every larger scale tested. Across the 5 k-1 M range, typical speedups fall in the <b>≈ 15-30% faster</b> range due to improved cache locality and stable successor cost. </p>
<p>Thus, although insertion may introduce some AVL-specific overhead at small scales, access performance dominates for large workloads, making the contiguous AVL structure an advantageous choice for systems where traversal, lookup, or iteration cost is critical. </p>
<h3><span class="tt">O(N)</span> Construction</h3>
<p>For strictly sorted, strictly unique input ranges, <code><a class="el" href="#afadb2b518bed652c669489b4d6b1ef55" title="Construct an AVL tree from an already sorted and unique range.">tree_map::from_sorted()</a></code> constructs a <b>perfectly balanced AVL tree</b> in near-linear time with no rotations and no repeated comparisons. This offers a fast, predictable path for bulk construction workflows. </p>
<h3>Iteration Cost</h3>
<p>The tree produced by <code><a class="el" href="#afadb2b518bed652c669489b4d6b1ef55" title="Construct an AVL tree from an already sorted and unique range.">from_sorted()</a></code> is a <b>perfectly balanced AVL</b> laid out in a contiguous array. This structure has a remarkable property: the average cost of advancing an in-order iterator (<code>operator++</code>) is extremely close to a constant. </p>
<p>For a perfectly balanced binary search tree with <em>N</em> nodes, the expected number of pointer hops performed by <code>operator++</code> converges to: </p>
<pre><span class="tt">
    E[successor steps] → 2.0  as N → ∞
</span></pre><p>This comes from the fact that more than half of all nodes are leaves, and their successor is simply the parent. Only a vanishingly small fraction of nodes require walking down a right subtree and then following several left edges. Measured average successor cost <span class="tt">[by python3.11]</span> was: </p>
<table class="doxtable">
<tr>
<th>N</th><th>avg successor steps</th></tr>
<tr>
<td>10</td><td>1.70</td></tr>
<tr>
<td>100</td><td>1.93</td></tr>
<tr>
<td>1 000</td><td>1.99</td></tr>
<tr>
<td>10 000</td><td>1.9987</td></tr>
<tr>
<td>100 000</td><td>1.9998</td></tr>
<tr>
<td>1 000 000</td><td>2.0000</td></tr>
</table>
<p>Therefore, in-order traversal runs in <b>strictly linear</b> time, with a very small constant factor, and does not grow with the height of the tree. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K</td><td>Key type (must be strictly ordered via <code>operator&lt;</code>) </td></tr>
    <tr><td class="paramname">V</td><td>Value type (use <code><a class="el" href="structjh_1_1typed_1_1monostate.html" title="Trivial empty type representing &quot;no value&quot;.">jh::typed::monostate</a></code> for set semantics) </td></tr>
    <tr><td class="paramname">Alloc</td><td>Allocator for node storage; defaults to vector-compatible allocator </td></tr>
  </table>
  </dd>
</dl>
</div><a name="doc-typedef-members" id="doc-typedef-members"></a><h2 id="header-doc-typedef-members" class="groupheader">Member Typedef Documentation</h2>
<a id="a94927512ed290484105fa42e90d225d7" name="a94927512ed290484105fa42e90d225d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94927512ed290484105fa42e90d225d7">&#9670;&#160;</a></span>const_reverse_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename Alloc = std::allocator&lt;detail::value_t&lt;K, V&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classjh_1_1avl_1_1tree__map.html">jh::avl::tree_map</a>&lt; K, V, Alloc &gt;::const_reverse_iterator = std::reverse_iterator&lt;<a class="el" href="structjh_1_1avl_1_1tree__map_1_1const__iterator.html">const_iterator</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Const reverse iterator type. </p>
<p>Traverses elements in descending key order. All element access is read-only. </p>

</div>
</div>
<a id="ae9593f170539c50863517dfd18e8d28a" name="ae9593f170539c50863517dfd18e8d28a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9593f170539c50863517dfd18e8d28a">&#9670;&#160;</a></span>reverse_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename Alloc = std::allocator&lt;detail::value_t&lt;K, V&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classjh_1_1avl_1_1tree__map.html">jh::avl::tree_map</a>&lt; K, V, Alloc &gt;::reverse_iterator = std::reverse_iterator&lt;<a class="el" href="structjh_1_1avl_1_1tree__map_1_1iterator.html">iterator</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reverse iterator type. </p>
<p>Traverses elements in descending key order. Provides the same mutability as <code>iterator</code>. </p>

</div>
</div>
<a name="doc-constructors" id="doc-constructors"></a><h2 id="header-doc-constructors" class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a70d9f020249432da83330f77880d0562" name="a70d9f020249432da83330f77880d0562"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70d9f020249432da83330f77880d0562">&#9670;&#160;</a></span>tree_map() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename Alloc = std::allocator&lt;detail::value_t&lt;K, V&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classjh_1_1avl_1_1tree__map.html">jh::avl::tree_map</a>&lt; K, V, Alloc &gt;::tree_map </td>
          <td>(</td>
          <td class="paramtype">const Alloc &amp;</td>          <td class="paramname"><span class="paramname"><em>alloc</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel explicit">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an empty tree with a specified allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alloc</td><td>allocator used for node storage </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae9f22b3346b3b3d3bdadd67f0877bf60" name="ae9f22b3346b3b3d3bdadd67f0877bf60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9f22b3346b3b3d3bdadd67f0877bf60">&#9670;&#160;</a></span>tree_map() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename Alloc = std::allocator&lt;detail::value_t&lt;K, V&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename K_, typename V_, typename Alloc_&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classjh_1_1avl_1_1tree__map.html">jh::avl::tree_map</a>&lt; K, V, Alloc &gt;::tree_map </td>
          <td>(</td>
          <td class="paramtype">const tree_map&lt; K_, V_, Alloc_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel explicit">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy-construct from another tree whose canonical key/value types match this tree and whose allocator type is identical. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K_</td><td>Original (possibly cv/ref qualified) key type of the source tree. </td></tr>
    <tr><td class="paramname">V_</td><td>Original (possibly cv/ref qualified) value type of the source tree. </td></tr>
    <tr><td class="paramname">Alloc_</td><td>Allocator type of the source tree.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The source tree to copy from.</td></tr>
  </table>
  </dd>
</dl>
<p>Participates only when the canonical forms of &lt;K,V&gt; and &lt;K_,V_&gt; produce the same internal node type. Thus, trees with different template arguments may still be interoperable if their canonical types coincide. Because the allocator types also match, the internal storage is copied directly without rebinding. </p>

</div>
</div>
<a id="ae9f22b3346b3b3d3bdadd67f0877bf60" name="ae9f22b3346b3b3d3bdadd67f0877bf60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9f22b3346b3b3d3bdadd67f0877bf60">&#9670;&#160;</a></span>tree_map() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename Alloc = std::allocator&lt;detail::value_t&lt;K, V&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename K_, typename V_, typename Alloc_&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classjh_1_1avl_1_1tree__map.html">jh::avl::tree_map</a>&lt; K, V, Alloc &gt;::tree_map </td>
          <td>(</td>
          <td class="paramtype">const tree_map&lt; K_, V_, Alloc_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel explicit">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy-construct from another tree whose canonical key/value types match this tree, using a rebound default allocator. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K_</td><td>Original (possibly cv/ref qualified) key type of the source tree. </td></tr>
    <tr><td class="paramname">V_</td><td>Original (possibly cv/ref qualified) value type of the source tree. </td></tr>
    <tr><td class="paramname">Alloc_</td><td>Allocator type of the source tree.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The source tree to copy from.</td></tr>
  </table>
  </dd>
</dl>
<p>Enabled only when the canonical forms of &lt;K,V&gt; and &lt;K_,V_&gt; match. Because allocator types differ, the node buffer is copied into storage owned by a default-constructed allocator rebound to this tree's node type. </p>

</div>
</div>
<a id="ada3d1478e5816bf3891bed7ce16c40ba" name="ada3d1478e5816bf3891bed7ce16c40ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada3d1478e5816bf3891bed7ce16c40ba">&#9670;&#160;</a></span>tree_map() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename Alloc = std::allocator&lt;detail::value_t&lt;K, V&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename K_, typename V_, typename Alloc_&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classjh_1_1avl_1_1tree__map.html">jh::avl::tree_map</a>&lt; K, V, Alloc &gt;::tree_map </td>
          <td>(</td>
          <td class="paramtype">const tree_map&lt; K_, V_, Alloc_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Alloc &amp;</td>          <td class="paramname"><span class="paramname"><em>alloc</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy-construct from another tree whose canonical key/value types match this tree, using a user-supplied allocator. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K_</td><td>Original (possibly cv/ref qualified) key type of the source tree. </td></tr>
    <tr><td class="paramname">V_</td><td>Original (possibly cv/ref qualified) value type of the source tree. </td></tr>
    <tr><td class="paramname">Alloc_</td><td>Allocator type of the source tree.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The source tree to copy from. </td></tr>
    <tr><td class="paramname">alloc</td><td>Allocator to be used for the new tree.</td></tr>
  </table>
  </dd>
</dl>
<p>Enabled when canonical &lt;K,V&gt; and &lt;K_,V_&gt; denote the same node type. The provided allocator determines the new node buffer; node contents are copied from the source tree. </p>

</div>
</div>
<a id="a3bde3657471bc2ced530929ee8b12ad2" name="a3bde3657471bc2ced530929ee8b12ad2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bde3657471bc2ced530929ee8b12ad2">&#9670;&#160;</a></span>tree_map() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename Alloc = std::allocator&lt;detail::value_t&lt;K, V&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename K_, typename V_, typename Alloc_&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classjh_1_1avl_1_1tree__map.html">jh::avl::tree_map</a>&lt; K, V, Alloc &gt;::tree_map </td>
          <td>(</td>
          <td class="paramtype">tree_map&lt; K_, V_, Alloc_ &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel explicit">explicit</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move-construct from another tree whose canonical key/value types match this tree and whose allocator type is identical. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K_</td><td>Source key type (possibly cv/ref qualified). </td></tr>
    <tr><td class="paramname">V_</td><td>Source value type (possibly cv/ref qualified). </td></tr>
    <tr><td class="paramname">Alloc_</td><td>Allocator type of the source tree.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The source tree to move from.</td></tr>
  </table>
  </dd>
</dl>
<p>Enabled only when the canonical node types of &lt;K,V&gt; and &lt;K_,V_&gt; are identical and both trees use the same allocator type.</p>
<p>The underlying storage is transferred directly, producing a constant-time move. After the operation, <code class="param">other</code> remains in a valid but unspecified state, consistent with the standard library's container move semantics. </p>

</div>
</div>
<a id="a9b1bc7bd9cd172a620aa317d74a9aa34" name="a9b1bc7bd9cd172a620aa317d74a9aa34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b1bc7bd9cd172a620aa317d74a9aa34">&#9670;&#160;</a></span>tree_map() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename Alloc = std::allocator&lt;detail::value_t&lt;K, V&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename K_, typename V_, typename Alloc_&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classjh_1_1avl_1_1tree__map.html">jh::avl::tree_map</a>&lt; K, V, Alloc &gt;::tree_map </td>
          <td>(</td>
          <td class="paramtype">tree_map&lt; K_, V_, Alloc_ &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel explicit">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move-construct from another tree whose canonical key/value types match this tree, using a rebound default allocator. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K_</td><td>Source key type (possibly cv/ref qualified). </td></tr>
    <tr><td class="paramname">V_</td><td>Source value type (possibly cv/ref qualified). </td></tr>
    <tr><td class="paramname">Alloc_</td><td>Allocator type of the source tree.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The source tree to move from.</td></tr>
  </table>
  </dd>
</dl>
<p>Enabled when canonical forms of &lt;K,V&gt; and &lt;K_,V_&gt; match but the allocator types differ. Node contents are moved element-wise into storage owned by a default-constructed allocator rebound to this tree's node type.</p>
<p>After the operation, <code class="param">other</code> remains valid but unspecified. Its internal structure is not guaranteed (it may be partially moved-from), and callers should clear or reassign it before further use. </p>

</div>
</div>
<a id="a306197bf40fcf07fb9d599285406212b" name="a306197bf40fcf07fb9d599285406212b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a306197bf40fcf07fb9d599285406212b">&#9670;&#160;</a></span>tree_map() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename Alloc = std::allocator&lt;detail::value_t&lt;K, V&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename K_, typename V_, typename Alloc_&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classjh_1_1avl_1_1tree__map.html">jh::avl::tree_map</a>&lt; K, V, Alloc &gt;::tree_map </td>
          <td>(</td>
          <td class="paramtype">tree_map&lt; K_, V_, Alloc_ &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Alloc &amp;</td>          <td class="paramname"><span class="paramname"><em>alloc</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move-construct from another tree whose canonical key/value types match this tree, using a user-supplied allocator. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K_</td><td>Source key type (possibly cv/ref qualified). </td></tr>
    <tr><td class="paramname">V_</td><td>Source value type (possibly cv/ref qualified). </td></tr>
    <tr><td class="paramname">Alloc_</td><td>Allocator type of the source tree.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The source tree to move from. </td></tr>
    <tr><td class="paramname">alloc</td><td>Allocator to be used for this tree.</td></tr>
  </table>
  </dd>
</dl>
<p>Enabled when canonical node types match. Elements are moved into storage controlled by the supplied allocator. The source tree is left in a valid but unspecified state afterwards, consistent with standard container move semantics. Callers must clear or overwrite <code class="param">other</code> if reuse is desired. </p>

</div>
</div>
<a id="a2d96d61e614f43e963c2db906c086d45" name="a2d96d61e614f43e963c2db906c086d45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d96d61e614f43e963c2db906c086d45">&#9670;&#160;</a></span>tree_map() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename Alloc = std::allocator&lt;detail::value_t&lt;K, V&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;std::input_iterator It&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classjh_1_1avl_1_1tree__map.html">jh::avl::tree_map</a>&lt; K, V, Alloc &gt;::tree_map </td>
          <td>(</td>
          <td class="paramtype">It</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">It</td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a tree by inserting elements from an input iterator range. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">It</td><td>Input iterator type whose dereferenced value is accepted by <code><a class="el" href="#a3f0580fb7892b7a82a26d453f7114961" title="Insert a key into the set.">insert()</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Iterator to the first element in the input range. </td></tr>
    <tr><td class="paramname">last</td><td>Iterator past the last element in the input range.</td></tr>
  </table>
  </dd>
</dl>
<p>The tree is first initialized to an empty state via <code><a class="el" href="#ac4cf54b19a4b23d880e6f73098709d03" title="Remove all elements from the container.">clear()</a></code>, after which all elements in the range [first, last) are inserted using <code><a class="el" href="#a3f0580fb7892b7a82a26d453f7114961" title="Insert a key into the set.">insert()</a></code>.</p>
<p>If <code class="param">It</code> models <code>std::random_access_iterator</code>, the distance between <code class="param">first</code> and <code class="param">last</code> can be computed in constant time. This allows an implementation to pre-reserve exactly <code>(last - first)</code> nodes before insertion, reducing reallocation overhead.</p>
<dl class="section warning"><dt>Warning</dt><dd>Iterators must not falsely claim to be random-access. In particular, a type that is fundamentally bidirectional or forward must not provide random-access operations (e.g., <code>operator[]</code>, <code>operator+(int)</code>) by emulating them via repeated <code>operator++</code> or <code>operator--</code> steps. Such "pseudo-random-access" iterators degrade performance severely, because the implementation may assume <span class="tt">O(1)</span> distance and indexing while the actual cost is <span class="tt">O(n)</span>. Iterator category tags must accurately reflect the iterator's capabilities. </dd></dl>

</div>
</div>
<a id="a17ef81ca064f4b1570cc8f9e3e22fcf6" name="a17ef81ca064f4b1570cc8f9e3e22fcf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17ef81ca064f4b1570cc8f9e3e22fcf6">&#9670;&#160;</a></span>tree_map() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename Alloc = std::allocator&lt;detail::value_t&lt;K, V&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;std::ranges::input_range R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classjh_1_1avl_1_1tree__map.html">jh::avl::tree_map</a>&lt; K, V, Alloc &gt;::tree_map </td>
          <td>(</td>
          <td class="paramtype">R &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>r</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel explicit">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a tree by inserting elements from an input range. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>Input range type whose elements are accepted by <code><a class="el" href="#a3f0580fb7892b7a82a26d453f7114961" title="Insert a key into the set.">insert()</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>The input range to consume.</td></tr>
  </table>
  </dd>
</dl>
<p>The tree is cleared and each element of <code class="param">r</code> is inserted using <code><a class="el" href="#a3f0580fb7892b7a82a26d453f7114961" title="Insert a key into the set.">insert()</a></code>.</p>
<p>If <code class="param">R</code> models <code>std::ranges::sized_range</code>, the node buffer may reserve space for <code>std::size(r)</code> elements prior to insertion. For random-access ranges this is typically <span class="tt">O(1)</span>.</p>
<dl class="section warning"><dt>Warning</dt><dd>As with iterator-based construction, range types must not provide a misleading random-access iterator category. Emulating random-access semantics atop a non-random-access traversal (e.g., implementing <code>operator[]</code> by repeated increment operations) causes unnecessary <span class="tt">O(n)</span> behavior and defeats the intended performance guarantees. </dd></dl>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="a2e93f05fd88284a3806a44237de6efcd" name="a2e93f05fd88284a3806a44237de6efcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e93f05fd88284a3806a44237de6efcd">&#9670;&#160;</a></span>at() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename Alloc = std::allocator&lt;detail::value_t&lt;K, V&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structjh_1_1avl_1_1avl__node.html#ae977856018d0c4cfd95b43350b63f183">node_type::value_type</a> &amp; <a class="el" href="classjh_1_1avl_1_1tree__map.html">jh::avl::tree_map</a>&lt; K, V, Alloc &gt;::at </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structjh_1_1avl_1_1avl__node.html#aa0264e8debb087c2f5f3a000960b32f9">node_type::key_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access the mapped value associated with a key. </p>
<p>Returns a reference to the mapped value corresponding to the specified key. Unlike <code>operator[]</code>, this function does not insert a new element when the key is not found. Instead, it throws <code>std::out_of_range</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key whose associated value is to be accessed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the mapped value.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>Thrown if no element with the specified key exists. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae8343f9668b0505076f54ff8e095637a" name="ae8343f9668b0505076f54ff8e095637a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8343f9668b0505076f54ff8e095637a">&#9670;&#160;</a></span>at() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename Alloc = std::allocator&lt;detail::value_t&lt;K, V&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structjh_1_1avl_1_1avl__node.html#ae977856018d0c4cfd95b43350b63f183">node_type::value_type</a> &amp; <a class="el" href="classjh_1_1avl_1_1tree__map.html">jh::avl::tree_map</a>&lt; K, V, Alloc &gt;::at </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structjh_1_1avl_1_1avl__node.html#aa0264e8debb087c2f5f3a000960b32f9">node_type::key_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access the mapped value associated with a key (const overload). </p>
<p>Behaves identically to the non-const overload: if the key does not exist, this function throws <code>std::out_of_range</code>. No insertion ever occurs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key whose associated value is to be accessed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A const reference to the mapped value.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>Thrown if no element with the specified key exists. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5b8d6f0d9e6bd7c196e825cba002b646" name="a5b8d6f0d9e6bd7c196e825cba002b646"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b8d6f0d9e6bd7c196e825cba002b646">&#9670;&#160;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename Alloc = std::allocator&lt;detail::value_t&lt;K, V&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structjh_1_1avl_1_1tree__map_1_1iterator.html">iterator</a> <a class="el" href="classjh_1_1avl_1_1tree__map.html">jh::avl::tree_map</a>&lt; K, V, Alloc &gt;::begin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an iterator to the smallest element. </p>
<p>If the container is empty, returns <code><a class="el" href="#a8a853f97d468ebc517ae421526a31b42" title="Return the past-the-end iterator.">end()</a></code>. </p>

</div>
</div>
<a id="a69c943c681f9012516cf6902d6f01e8b" name="a69c943c681f9012516cf6902d6f01e8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69c943c681f9012516cf6902d6f01e8b">&#9670;&#160;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename Alloc = std::allocator&lt;detail::value_t&lt;K, V&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structjh_1_1avl_1_1tree__map_1_1const__iterator.html">const_iterator</a> <a class="el" href="classjh_1_1avl_1_1tree__map.html">jh::avl::tree_map</a>&lt; K, V, Alloc &gt;::begin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const iterator to the smallest element. </p>
<p>Identical to the non-const overload but produces a <code><a class="el" href="structjh_1_1avl_1_1tree__map_1_1const__iterator.html" title="Const bidirectional iterator for in-order traversal.">const_iterator</a></code>. Returns <code><a class="el" href="#a8a853f97d468ebc517ae421526a31b42" title="Return the past-the-end iterator.">end()</a></code> if the container is empty. </p>

</div>
</div>
<a id="a8a212ea5c888a1b76c466d423d48da42" name="a8a212ea5c888a1b76c466d423d48da42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a212ea5c888a1b76c466d423d48da42">&#9670;&#160;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename Alloc = std::allocator&lt;detail::value_t&lt;K, V&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structjh_1_1avl_1_1tree__map_1_1const__iterator.html">const_iterator</a> <a class="el" href="classjh_1_1avl_1_1tree__map.html">jh::avl::tree_map</a>&lt; K, V, Alloc &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const iterator to the first element. </p>
<p>Equivalent to <code><a class="el" href="#a69c943c681f9012516cf6902d6f01e8b" title="Return a const iterator to the smallest element.">begin() const</a></code>. </p>

</div>
</div>
<a id="afe120fb480aa2c50a4f532b77223f4b1" name="afe120fb480aa2c50a4f532b77223f4b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe120fb480aa2c50a4f532b77223f4b1">&#9670;&#160;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename Alloc = std::allocator&lt;detail::value_t&lt;K, V&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structjh_1_1avl_1_1tree__map_1_1const__iterator.html">const_iterator</a> <a class="el" href="classjh_1_1avl_1_1tree__map.html">jh::avl::tree_map</a>&lt; K, V, Alloc &gt;::cend </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the const past-the-end iterator. </p>
<p>Equivalent to <code><a class="el" href="#a97f3688ceca198b84f9ab96230b9059b" title="Return the const past-the-end iterator.">end() const</a></code>. </p>

</div>
</div>
<a id="ac4cf54b19a4b23d880e6f73098709d03" name="ac4cf54b19a4b23d880e6f73098709d03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4cf54b19a4b23d880e6f73098709d03">&#9670;&#160;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename Alloc = std::allocator&lt;detail::value_t&lt;K, V&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classjh_1_1avl_1_1tree__map.html">jh::avl::tree_map</a>&lt; K, V, Alloc &gt;::clear </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove all elements from the container. </p>
<p>Resets the container to an empty state by clearing the underlying contiguous storage and resetting the root index. The operation is equivalent to clearing a vector: </p>
<ul>
<li>
The size becomes zero, but the capacity is preserved. </li>
<li>
No reallocation occurs. </li>
<li>
Under polymorphic allocators (PMR), no element-by-element destruction or resource release takes place; the buffer is simply marked empty.  </li>
</ul>
<p>This gives clear an effectively constant-time cost. Unlike pointer-based tree structures such as those used by the standard ordered containers, there is no need to traverse and destroy individual nodes; the entire tree is discarded in one step. </p>
<dl class="section note"><dt>Note</dt><dd>All iterators are invalidated. </dd></dl>

</div>
</div>
<a id="aee51f98147bdfdff4b54b887ec9f3c70" name="aee51f98147bdfdff4b54b887ec9f3c70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee51f98147bdfdff4b54b887ec9f3c70">&#9670;&#160;</a></span>count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename Alloc = std::allocator&lt;detail::value_t&lt;K, V&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classjh_1_1avl_1_1tree__map.html">jh::avl::tree_map</a>&lt; K, V, Alloc &gt;::count </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structjh_1_1avl_1_1avl__node.html#aa0264e8debb087c2f5f3a000960b32f9">node_type::key_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Count the number of elements with the specified key. </p>
<p>Because this container stores unique keys, the result is either <code>0</code> (key not present) or <code>1</code> (key present).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>1</code> if the key exists, <code>0</code> otherwise. </dd></dl>

</div>
</div>
<a id="a177ba6c84038c069382cfa8340db1e73" name="a177ba6c84038c069382cfa8340db1e73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a177ba6c84038c069382cfa8340db1e73">&#9670;&#160;</a></span>crbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename Alloc = std::allocator&lt;detail::value_t&lt;K, V&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a94927512ed290484105fa42e90d225d7">const_reverse_iterator</a> <a class="el" href="classjh_1_1avl_1_1tree__map.html">jh::avl::tree_map</a>&lt; K, V, Alloc &gt;::crbegin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const reverse iterator to the last element. </p>
<p>Convenience wrapper identical to <code><a class="el" href="#a89e0a86254e8c10257f5db6001a68b54" title="Return a const reverse iterator to the last element.">rbegin() const</a></code>. </p>

</div>
</div>
<a id="a67f9a8d531276aa9c92afd3b16a5562d" name="a67f9a8d531276aa9c92afd3b16a5562d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67f9a8d531276aa9c92afd3b16a5562d">&#9670;&#160;</a></span>crend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename Alloc = std::allocator&lt;detail::value_t&lt;K, V&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a94927512ed290484105fa42e90d225d7">const_reverse_iterator</a> <a class="el" href="classjh_1_1avl_1_1tree__map.html">jh::avl::tree_map</a>&lt; K, V, Alloc &gt;::crend </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the const reverse past-the-end iterator. </p>
<p>Convenience wrapper identical to <code><a class="el" href="#a989f84dfac9c4962148ce2029188e8d3" title="Return the const reverse past-the-end iterator.">rend() const</a></code>. Represents the reverse-iterator view of <code>&ndash;<a class="el" href="#a5b8d6f0d9e6bd7c196e825cba002b646" title="Return an iterator to the smallest element.">begin()</a></code>, which equals the normal forward <code><a class="el" href="#a8a853f97d468ebc517ae421526a31b42" title="Return the past-the-end iterator.">end()</a></code>. </p>

</div>
</div>
<a id="a7d9364198b0c16c12cdf25317ddf88a9" name="a7d9364198b0c16c12cdf25317ddf88a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d9364198b0c16c12cdf25317ddf88a9">&#9670;&#160;</a></span>emplace() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename Alloc = std::allocator&lt;detail::value_t&lt;K, V&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; <br />
requires (!<a class="el" href="conceptjh_1_1typed_1_1monostate__t.html">jh::typed::monostate_t</a>&lt;V&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="structjh_1_1avl_1_1tree__map_1_1iterator.html">iterator</a>, bool &gt; <a class="el" href="classjh_1_1avl_1_1tree__map.html">jh::avl::tree_map</a>&lt; K, V, Alloc &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a key-value pair by constructing it from arbitrary arguments. </p>
<p>This function preserves the usual <code>emplace</code> semantics: the arguments are forwarded into a temporary <code>std::pair&lt;K, V&gt;</code> (note: <code>K</code> is used, not <code>const K</code>). The key and mapped value constructed in this temporary object are then forwarded into the internal insertion logic.</p>
<p>This matches the behavior of standard associative containers, where <code><a class="el" href="#a25de9175a7df73402418dfe22d7501ad" title="Public value type (K for set, std::pair&lt;const K, V&gt; for map).">value_type</a></code> is not directly constructed for emplacement because <code>std::pair&lt;const K, V&gt;</code> cannot be formed from arbitrary arguments. Only the key and mapped value are used.</p>
<p>If the key already exists in the map, construction still occurs but no insertion is performed; the returned boolean is <code>false</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>Arguments used to construct a temporary <code>std::pair&lt;K, V&gt;</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair consisting of: <ol>
<li>
An iterator to the existing or newly inserted element. </li>
<li>
<code>true</code> if a new element was inserted, <code>false</code> otherwise. </li>
</ol>
</dd></dl>

</div>
</div>
<a id="a510fec4222429f6631268dc167d144a4" name="a510fec4222429f6631268dc167d144a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a510fec4222429f6631268dc167d144a4">&#9670;&#160;</a></span>emplace() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename Alloc = std::allocator&lt;detail::value_t&lt;K, V&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; <br />
requires (<a class="el" href="conceptjh_1_1typed_1_1monostate__t.html">jh::typed::monostate_t</a>&lt;V&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="structjh_1_1avl_1_1tree__map_1_1iterator.html">iterator</a>, bool &gt; <a class="el" href="classjh_1_1avl_1_1tree__map.html">jh::avl::tree_map</a>&lt; K, V, Alloc &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a key and insert it into the set. </p>
<p>The key is constructed from the forwarded arguments and then inserted following standard set semantics. If the key already exists, no modification occurs. This overload exists even though the underlying node type uses only the key; construction is still routed through the key's constructor invoked with <code>Args...</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>Constructor arguments for the key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair as with <code>insert</code>, indicating the inserted or existing position. </dd></dl>

</div>
</div>
<a id="a86f554db23ffbb11f2fe6149c583e75d" name="a86f554db23ffbb11f2fe6149c583e75d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86f554db23ffbb11f2fe6149c583e75d">&#9670;&#160;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename Alloc = std::allocator&lt;detail::value_t&lt;K, V&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classjh_1_1avl_1_1tree__map.html">jh::avl::tree_map</a>&lt; K, V, Alloc &gt;::empty </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether the container contains no elements. </p>
<p>Equivalent to testing whether the underlying contiguous storage is empty. Does not modify the container and runs in constant time.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the container has no elements, otherwise false. </dd></dl>

</div>
</div>
<a id="a8a853f97d468ebc517ae421526a31b42" name="a8a853f97d468ebc517ae421526a31b42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a853f97d468ebc517ae421526a31b42">&#9670;&#160;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename Alloc = std::allocator&lt;detail::value_t&lt;K, V&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structjh_1_1avl_1_1tree__map_1_1iterator.html">iterator</a> <a class="el" href="classjh_1_1avl_1_1tree__map.html">jh::avl::tree_map</a>&lt; K, V, Alloc &gt;::end </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the past-the-end iterator. </p>
<p>The returned iterator compares equal to all other past-the-end iterators for the same container. </p>

</div>
</div>
<a id="ade867e9fdbe62d25f7cc00ddc52b4977" name="ade867e9fdbe62d25f7cc00ddc52b4977"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade867e9fdbe62d25f7cc00ddc52b4977">&#9670;&#160;</a></span>equal_range() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename Alloc = std::allocator&lt;detail::value_t&lt;K, V&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="structjh_1_1avl_1_1tree__map_1_1iterator.html">iterator</a>, <a class="el" href="structjh_1_1avl_1_1tree__map_1_1iterator.html">iterator</a> &gt; <a class="el" href="classjh_1_1avl_1_1tree__map.html">jh::avl::tree_map</a>&lt; K, V, Alloc &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structjh_1_1avl_1_1avl__node.html#aa0264e8debb087c2f5f3a000960b32f9">node_type::key_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the range of elements equivalent to the given key. </p>
<p>Provides the canonical <code>equal_range</code> semantics for associative containers with unique keys: </p><ul>
<li>
If an element with the given key exists, returns a pair <code>{lower_bound(key), upper_bound(key)}</code>.  </li>
<li>
If no such element exists, both iterators in the returned pair equal <code>lower_bound(key)</code>.  </li>
<li>
The returned range is half-open: the first iterator refers to the element with the key (if present), and the second refers to the element that follows it.  </li>
<li>
Does not modify the container. </li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to search for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair of iterators defining the range of matching elements. </dd></dl>

</div>
</div>
<a id="aab055af61458cefc9ecb33a569a20920" name="aab055af61458cefc9ecb33a569a20920"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab055af61458cefc9ecb33a569a20920">&#9670;&#160;</a></span>equal_range() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename Alloc = std::allocator&lt;detail::value_t&lt;K, V&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="structjh_1_1avl_1_1tree__map_1_1const__iterator.html">const_iterator</a>, <a class="el" href="structjh_1_1avl_1_1tree__map_1_1const__iterator.html">const_iterator</a> &gt; <a class="el" href="classjh_1_1avl_1_1tree__map.html">jh::avl::tree_map</a>&lt; K, V, Alloc &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structjh_1_1avl_1_1avl__node.html#aa0264e8debb087c2f5f3a000960b32f9">node_type::key_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the range of elements equivalent to the given key (const overload). </p>
<p>Behaves identically to the non-const version but returns a pair of <code><a class="el" href="structjh_1_1avl_1_1tree__map_1_1const__iterator.html" title="Const bidirectional iterator for in-order traversal.">const_iterator</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to search for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair of const iterators defining the range of matching elements. </dd></dl>

</div>
</div>
<a id="a42449562ef47faf0eaa052900eeb5f01" name="a42449562ef47faf0eaa052900eeb5f01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42449562ef47faf0eaa052900eeb5f01">&#9670;&#160;</a></span>erase() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename Alloc = std::allocator&lt;detail::value_t&lt;K, V&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classjh_1_1avl_1_1tree__map.html">jh::avl::tree_map</a>&lt; K, V, Alloc &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structjh_1_1avl_1_1avl__node.html#aa0264e8debb087c2f5f3a000960b32f9">node_type::key_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erase the element whose key compares equal to the given key. </p>
<p>Searches for an element with the specified key and removes it if found. Iterator validity follows the rules of single-element erase: </p><ul>
<li>
If an element is erased, all iterators obtained prior to this call become invalid, as element removal and subsequent compaction may relocate nodes.  </li>
<li>
If no matching key exists, the container is left unmodified and no iterators are invalidated.  </li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key of the element to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>1</code> if an element was erased, <code>0</code> otherwise. </dd></dl>

</div>
</div>
<a id="a82eec5247f447c7db0369043e9ec16c2" name="a82eec5247f447c7db0369043e9ec16c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82eec5247f447c7db0369043e9ec16c2">&#9670;&#160;</a></span>erase() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename Alloc = std::allocator&lt;detail::value_t&lt;K, V&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structjh_1_1avl_1_1tree__map_1_1iterator.html">iterator</a> <a class="el" href="classjh_1_1avl_1_1tree__map.html">jh::avl::tree_map</a>&lt; K, V, Alloc &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structjh_1_1avl_1_1tree__map_1_1const__iterator.html">const_iterator</a></td>          <td class="paramname"><span class="paramname"><em>pos</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erase the element referenced by the given const iterator. </p>
<p>Removes the element pointed to by <code>pos</code> by delegating to the non-const overload <code><a class="el" href="#a847de47716ae40afdd7ddbdd67d194f5" title="Erase the element referenced by the given iterator.">erase(iterator)</a></code>. The behavior, iterator invalidation rules, and returned iterator semantics exactly match those of <code><a class="el" href="#a847de47716ae40afdd7ddbdd67d194f5" title="Erase the element referenced by the given iterator.">erase(iterator)</a></code>.</p>
<p>If <code>pos</code> equals <code><a class="el" href="#a8a853f97d468ebc517ae421526a31b42" title="Return the past-the-end iterator.">end()</a></code>, no removal occurs and <code>pos</code> is returned unchanged.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>Const iterator referring to the element to erase. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the in-order successor of the erased element, or <code><a class="el" href="#a8a853f97d468ebc517ae421526a31b42" title="Return the past-the-end iterator.">end()</a></code> if no successor exists. </dd></dl>

</div>
</div>
<a id="a847de47716ae40afdd7ddbdd67d194f5" name="a847de47716ae40afdd7ddbdd67d194f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a847de47716ae40afdd7ddbdd67d194f5">&#9670;&#160;</a></span>erase() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename Alloc = std::allocator&lt;detail::value_t&lt;K, V&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structjh_1_1avl_1_1tree__map_1_1iterator.html">iterator</a> <a class="el" href="classjh_1_1avl_1_1tree__map.html">jh::avl::tree_map</a>&lt; K, V, Alloc &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structjh_1_1avl_1_1tree__map_1_1iterator.html">iterator</a></td>          <td class="paramname"><span class="paramname"><em>pos</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erase the element referenced by the given iterator. </p>
<p>Removes the element pointed to by <code>pos</code> and returns an iterator to its logical in-order successor. If <code>pos</code> refers to <code><a class="el" href="#a8a853f97d468ebc517ae421526a31b42" title="Return the past-the-end iterator.">end()</a></code>, no action is performed and <code>pos</code> is returned unchanged.</p>
<p>Contiguous-array binary trees cannot preserve iterator validity after structural changes: erasing any element may relocate other nodes in the underlying storage. Therefore:</p>
<ul>
<li>
Every iterator obtained prior to this call, except the one returned by the function itself, becomes invalid and must not be used.  </li>
<li>
The returned iterator refers to the next element in sorted key order. If the erased element was the last in order, the returned iterator equals <code><a class="el" href="#a8a853f97d468ebc517ae421526a31b42" title="Return the past-the-end iterator.">end()</a></code>.  </li>
</ul>
<p>The operation preserves AVL invariants and performs any required rebalancing after removal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>Iterator referring to the element to erase. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the in-order successor of the erased element, or <code><a class="el" href="#a8a853f97d468ebc517ae421526a31b42" title="Return the past-the-end iterator.">end()</a></code> if no successor exists. </dd></dl>

</div>
</div>
<a id="a683fcf206121803f0f323f2b2977177d" name="a683fcf206121803f0f323f2b2977177d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a683fcf206121803f0f323f2b2977177d">&#9670;&#160;</a></span>find() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename Alloc = std::allocator&lt;detail::value_t&lt;K, V&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structjh_1_1avl_1_1tree__map_1_1iterator.html">iterator</a> <a class="el" href="classjh_1_1avl_1_1tree__map.html">jh::avl::tree_map</a>&lt; K, V, Alloc &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structjh_1_1avl_1_1avl__node.html#aa0264e8debb087c2f5f3a000960b32f9">node_type::key_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Locate the element with the specified key. </p>
<p>Performs a standard binary-search-tree lookup. If an element with the given key exists, returns an iterator referring to it. Otherwise returns <code><a class="el" href="#a8a853f97d468ebc517ae421526a31b42" title="Return the past-the-end iterator.">end()</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the matching element, or <code><a class="el" href="#a8a853f97d468ebc517ae421526a31b42" title="Return the past-the-end iterator.">end()</a></code> if not found. </dd></dl>

</div>
</div>
<a id="abf95e5d0124567972d95892e93c9e7f4" name="abf95e5d0124567972d95892e93c9e7f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf95e5d0124567972d95892e93c9e7f4">&#9670;&#160;</a></span>find() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename Alloc = std::allocator&lt;detail::value_t&lt;K, V&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structjh_1_1avl_1_1tree__map_1_1const__iterator.html">const_iterator</a> <a class="el" href="classjh_1_1avl_1_1tree__map.html">jh::avl::tree_map</a>&lt; K, V, Alloc &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structjh_1_1avl_1_1avl__node.html#aa0264e8debb087c2f5f3a000960b32f9">node_type::key_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Locate the element with the specified key (const overload). </p>
<p>Behaves identically to the non-const version but returns a <code><a class="el" href="structjh_1_1avl_1_1tree__map_1_1const__iterator.html" title="Const bidirectional iterator for in-order traversal.">const_iterator</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Const iterator to the matching element, or <code><a class="el" href="#a8a853f97d468ebc517ae421526a31b42" title="Return the past-the-end iterator.">end()</a></code> if not found. </dd></dl>

</div>
</div>
<a id="afadb2b518bed652c669489b4d6b1ef55" name="afadb2b518bed652c669489b4d6b1ef55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afadb2b518bed652c669489b4d6b1ef55">&#9670;&#160;</a></span>from_sorted()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename Alloc = std::allocator&lt;detail::value_t&lt;K, V&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;std::ranges::sized_range R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a6c85f80ca9075223b0812883d6032f24">tree_map</a> <a class="el" href="classjh_1_1avl_1_1tree__map.html">jh::avl::tree_map</a>&lt; K, V, Alloc &gt;::from_sorted </td>
          <td>(</td>
          <td class="paramtype">R &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>r</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an AVL tree from an already sorted and unique range. </p>
<h3>Purpose</h3>
<p><code><a class="el" href="#afadb2b518bed652c669489b4d6b1ef55" title="Construct an AVL tree from an already sorted and unique range.">from_sorted()</a></code> builds a perfectly balanced contiguous AVL tree directly from a sorted, strictly-unique input range. Unlike repeated <code><a class="el" href="#a3f0580fb7892b7a82a26d453f7114961" title="Insert a key into the set.">insert()</a></code>, which performs <span class="tt">O(log N)</span> insertions with rebalancing, this routine constructs the entire tree in <b>near-perfect <span class="tt">O(N)</span></b> time. </p>
<p>The input must satisfy: </p>
<ul>
<li>
strictly increasing keys (already sorted), </li>
<li>
no duplicates, </li>
<li>
size known (<code>std::ranges::sized_range</code>), </li>
<li>
<a class="el" href="#a25de9175a7df73402418dfe22d7501ad" title="Public value type (K for set, std::pair&lt;const K, V&gt; for map).">value_type</a> convertible to <code>std::pair&lt;const K, V&gt;</code> for <code><a class="el" href="namespacejh.html#adc97eb86056b9268c8b5c7378587c2be" title="Ordered associative map based on a contiguous-array AVL tree.">jh::ordered_map</a></code> or <code>K</code> for <code><a class="el" href="namespacejh.html#a7d49c250af115c5a63acb88c1b38c3ec" title="Ordered associative set based on a contiguous-array AVL tree.">jh::ordered_set</a></code>. </li>
</ul>
<h3>Why This Matters</h3>
<p>Many workloads naturally produce ordered batches: log-structured indexing, preprocessing pipelines, analytics results, time-sorted packets, or any domain where data is accumulated in vectors. Constructing the <code><a class="el" href="namespacejh.html#a7d49c250af115c5a63acb88c1b38c3ec" title="Ordered associative set based on a contiguous-array AVL tree.">jh::ordered_set</a>/map</code> directly from this monotonic sequence avoids the <b>costly per-node insertion</b> and removes the need for AVL rotations. </p>
<h3>Complexity</h3>
<ul>
<li>
<b>Construction:</b> <span class="tt">O(N)</span> (tree shape derived directly) </li>
<li>
<b>Iterator validity:</b> all iterators valid post-construction </li>
<li>
<b>Recursion:</b> none (iterative layout) </li>
</ul>
<h3>Performance Characteristics</h3>
<p>Benchmarked on an Apple M3 (Clang++20) with 10 000 random or sorted <code>std::string</code> keys: </p>
<table class="doxtable">
<tr>
<th>Operation</th><th>Runtime (ns)</th><th>Notes</th></tr>
<tr>
<td><code><a class="el" href="#a3f0580fb7892b7a82a26d453f7114961">ordered_set.insert</a> (random)</code></td><td>1.4 e7 (~14 ms)</td><td>AVL rotations + random memory access</td></tr>
<tr>
<td><code><a class="el" href="#a3f0580fb7892b7a82a26d453f7114961">ordered_set.insert</a> (sorted)</code></td><td>significantly faster</td><td>input order strongly affects performance</td></tr>
<tr>
<td><code>stable_sort(10k strings)</code></td><td>~9.6 e6 (~9.6 ms)</td><td>merge sort detects ordered runs</td></tr>
<tr>
<td><code>unique(10k strings)</code></td><td>~1 e5 (0.1 ms)</td><td>linear; negligible vs sorting</td></tr>
<tr>
<td><code>from_sorted (10k strings)</code></td><td>~8.6 e5 (0.86 ms)</td><td>builds perfect AVL directly</td></tr>
<tr>
<td><b>Synthesis:</b> <code>sort + unique + from_sorted</code></td><td>~1.06 e7 (~10.6 ms)</td><td>&lt; <code>insert</code> cost even when input is fully random</td></tr>
</table>
<h3>Interpretation</h3>
<ul>
<li>
Even with completely random input, a vector → sort → unique → <code>from_sorted</code> pipeline is faster than 10k random AVL insertions. </li>
<li>
For already-sorted or partially-sorted sequences, runtime becomes almost linear and outperforms both <code><a class="el" href="namespacejh.html#a7d49c250af115c5a63acb88c1b38c3ec" title="Ordered associative set based on a contiguous-array AVL tree.">ordered_set</a></code> and <code>std::set</code>. </li>
<li>
<code>stable_sort</code> is strongly order-aware; partially sorted sequences reduce its cost dramatically. </li>
<li>
<code>unique()</code> cost is negligible compared to sorting. </li>
<li>
Memory locality is maximized: all nodes fit in one contiguous vector. </li>
</ul>
<h3>When To Use</h3>
<ul>
<li>
Bulk construction from preprocessed or batched data. </li>
<li>
Loading on-disk sorted indices. </li>
<li>
Temporal/event logs with strictly increasing timestamps. </li>
<li>
Any context where <code>std::set/map</code> would require many insertions. </li>
<li>
When memory fragmentation must be tightly controlled. </li>
</ul>
<h3>Example</h3>
<div class="fragment"><div class="line">std::vector&lt;int&gt; v = {...};</div>
<div class="line">std::stable_sort(v.begin(), v.end());</div>
<div class="line">sorted.erase(std::unique(v.begin(), v.end()), v.end());</div>
<div class="line"><span class="keyword">auto</span> s = <a class="code hl_function" href="#afadb2b518bed652c669489b4d6b1ef55">jh::ordered_set&lt;int&gt;::from_sorted</a>(v);</div>
<div class="line"><span class="comment">// s is a perfectly balanced AVL using contiguous storage</span></div>
<div class="ttc" id="aclassjh_1_1avl_1_1tree__map_html_afadb2b518bed652c669489b4d6b1ef55"><div class="ttname"><a href="#afadb2b518bed652c669489b4d6b1ef55">jh::avl::tree_map&lt; K, jh::typed::monostate, Alloc &gt;::from_sorted</a></div><div class="ttdeci">static tree_map from_sorted(R &amp;&amp;r)</div><div class="ttdef"><b>Definition</b> ordered_map.h:2930</div></div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>a sized, sorted, strictly unique input range </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>range whose values will be copied/moved into the resulting tree </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a fully constructed, perfectly balanced <code><a class="el" href="classjh_1_1avl_1_1tree__map.html" title="Contiguous-array AVL tree used by jh::ordered_map and jh::ordered_set.">tree_map</a></code></dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Input must be sorted and unique. No validation is performed. </dd></dl>

</div>
</div>
<a id="a3f0580fb7892b7a82a26d453f7114961" name="a3f0580fb7892b7a82a26d453f7114961"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f0580fb7892b7a82a26d453f7114961">&#9670;&#160;</a></span>insert() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename Alloc = std::allocator&lt;detail::value_t&lt;K, V&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="structjh_1_1avl_1_1tree__map_1_1iterator.html">iterator</a>, bool &gt; <a class="el" href="classjh_1_1avl_1_1tree__map.html">jh::avl::tree_map</a>&lt; K, V, Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a25de9175a7df73402418dfe22d7501ad">value_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a key into the set. </p>
<p>For set semantics, <code><a class="el" href="#a25de9175a7df73402418dfe22d7501ad" title="Public value type (K for set, std::pair&lt;const K, V&gt; for map).">value_type</a></code> is simply the key type <code>K</code>. If the key does not already exist, it is inserted and the returned boolean is <code>true</code>. Otherwise the existing element is returned and no modification occurs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair consisting of: <ol>
<li>
An iterator to the existing or newly inserted key. </li>
<li>
<code>true</code> if insertion occurred, <code>false</code> otherwise. </li>
</ol>
</dd></dl>

</div>
</div>
<a id="ad7b226fc203640840d1e4b95162010a0" name="ad7b226fc203640840d1e4b95162010a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7b226fc203640840d1e4b95162010a0">&#9670;&#160;</a></span>insert() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename Alloc = std::allocator&lt;detail::value_t&lt;K, V&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename P&gt; <br />
requires (!<a class="el" href="conceptjh_1_1typed_1_1monostate__t.html">jh::typed::monostate_t</a>&lt;V&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="structjh_1_1avl_1_1tree__map_1_1iterator.html">iterator</a>, bool &gt; <a class="el" href="classjh_1_1avl_1_1tree__map.html">jh::avl::tree_map</a>&lt; K, V, Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">P &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a key-value pair into the map. </p>
<p>This overload generalizes the traditional <code>std::pair&lt;const K, V&gt;</code>-based insertion interface. Instead of requiring a <code><a class="el" href="#a25de9175a7df73402418dfe22d7501ad" title="Public value type (K for set, std::pair&lt;const K, V&gt; for map).">value_type</a></code> object, any 2-element tuple-like value is accepted as long as: </p><ul>
<li>
<code>get&lt;0&gt;(p)</code> has type <code>K</code> (after remove_cvref) </li>
<li>
<code>get&lt;1&gt;(p)</code> has type <code>V</code> (after remove_cvref) </li>
</ul>
<p>This reflects the actual insertion semantics: the container consumes the key and mapped value directly rather than constructing a <code>std::pair&lt;const K, V&gt;</code> object, which is generally not constructible from user input. Any tuple-like pair (including <code>std::pair</code>, <code>std::tuple</code>, proxy references, and structured-binding-compatible types) is therefore permitted if its element types match exactly. <br  />
 If the key already exists, no insertion occurs and the boolean return value is <code>false</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">P</td><td>The tuple-like type providing key and mapped value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>A tuple-like value providing key and mapped value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair containing: <ol>
<li>
An iterator to the existing or newly inserted element. </li>
<li>
<code>true</code> if a new element was inserted, <code>false</code> otherwise. </li>
</ol>
</dd></dl>

</div>
</div>
<a id="a0e3e75a4ccaed89bb7b3d28cb5ca4a1d" name="a0e3e75a4ccaed89bb7b3d28cb5ca4a1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e3e75a4ccaed89bb7b3d28cb5ca4a1d">&#9670;&#160;</a></span>insert() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename Alloc = std::allocator&lt;detail::value_t&lt;K, V&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="structjh_1_1avl_1_1tree__map_1_1iterator.html">iterator</a>, bool &gt; <a class="el" href="classjh_1_1avl_1_1tree__map.html">jh::avl::tree_map</a>&lt; K, V, Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a25de9175a7df73402418dfe22d7501ad">value_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a key into the set (non-const reference overload). </p>
<p>Behaves identically to the const-reference overload. Provided for completeness and consistency with associative-container interfaces. </p>

</div>
</div>
<a id="ae45799924b993fbcb9741f65cc37006a" name="ae45799924b993fbcb9741f65cc37006a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae45799924b993fbcb9741f65cc37006a">&#9670;&#160;</a></span>insert_or_assign()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename Alloc = std::allocator&lt;detail::value_t&lt;K, V&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="structjh_1_1avl_1_1tree__map_1_1iterator.html">iterator</a>, bool &gt; <a class="el" href="classjh_1_1avl_1_1tree__map.html">jh::avl::tree_map</a>&lt; K, V, Alloc &gt;::insert_or_assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structjh_1_1avl_1_1avl__node.html#aa0264e8debb087c2f5f3a000960b32f9">node_type::key_type</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>k</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structjh_1_1avl_1_1avl__node.html#ae977856018d0c4cfd95b43350b63f183">node_type::value_type</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a key-value pair or assign to the mapped value. </p>
<p>This function provides the combined "insert or assign" behavior used by ordered associative maps. The key and mapped value are accepted as forwarding references, allowing both lvalues and rvalues to be supplied. When rvalues are provided, their contents may be moved into the container.</p>
<p>The behavior is: </p><ol>
<li>
If no element with the same key exists, a new element is inserted using the forwarded key and value. </li>
<li>
If an element with the same key already exists, its mapped value is replaced by the forwarded value. </li>
</ol>
<p>This mirrors the semantics of <code>std::map::insert_or_assign</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>The key of the element to insert or update (forwarded). </td></tr>
    <tr><td class="paramname">v</td><td>The mapped value to assign or insert (forwarded).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair consisting of: <ol>
<li>
An iterator to the inserted or updated element. </li>
<li>
<code>true</code> if a new element was inserted, <code>false</code> if an existing element was updated. </li>
</ol>
</dd></dl>

</div>
</div>
<a id="ab04adc15bb8160401992768672be0055" name="ab04adc15bb8160401992768672be0055"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab04adc15bb8160401992768672be0055">&#9670;&#160;</a></span>lower_bound() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename Alloc = std::allocator&lt;detail::value_t&lt;K, V&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structjh_1_1avl_1_1tree__map_1_1iterator.html">iterator</a> <a class="el" href="classjh_1_1avl_1_1tree__map.html">jh::avl::tree_map</a>&lt; K, V, Alloc &gt;::lower_bound </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structjh_1_1avl_1_1avl__node.html#aa0264e8debb087c2f5f3a000960b32f9">node_type::key_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an iterator to the first element whose key is not less than the given key. </p>
<p>Provides the standard ordered-container lower-bound semantics: </p><ul>
<li>
Returns an iterator referring to the first element whose key is greater than or equal to <code>key</code>. </li>
<li>
If no such element exists, returns <code><a class="el" href="#a8a853f97d468ebc517ae421526a31b42" title="Return the past-the-end iterator.">end()</a></code>. </li>
<li>
Does not modify the container. </li>
</ul>

</div>
</div>
<a id="a75fa1fce1367b92e892b1035f7d25b4d" name="a75fa1fce1367b92e892b1035f7d25b4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75fa1fce1367b92e892b1035f7d25b4d">&#9670;&#160;</a></span>lower_bound() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename Alloc = std::allocator&lt;detail::value_t&lt;K, V&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structjh_1_1avl_1_1tree__map_1_1const__iterator.html">const_iterator</a> <a class="el" href="classjh_1_1avl_1_1tree__map.html">jh::avl::tree_map</a>&lt; K, V, Alloc &gt;::lower_bound </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structjh_1_1avl_1_1avl__node.html#aa0264e8debb087c2f5f3a000960b32f9">node_type::key_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Const overload of lower_bound. </p>
<p>Behaves identically to the non-const version but returns a const iterator. </p>

</div>
</div>
<a id="a6b27059a7b9b8193a31dc51972f3adec" name="a6b27059a7b9b8193a31dc51972f3adec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b27059a7b9b8193a31dc51972f3adec">&#9670;&#160;</a></span>operator[]()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename Alloc = std::allocator&lt;detail::value_t&lt;K, V&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structjh_1_1avl_1_1avl__node.html#ae977856018d0c4cfd95b43350b63f183">node_type::value_type</a> &amp; <a class="el" href="classjh_1_1avl_1_1tree__map.html">jh::avl::tree_map</a>&lt; K, V, Alloc &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structjh_1_1avl_1_1avl__node.html#aa0264e8debb087c2f5f3a000960b32f9">node_type::key_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access or insert the mapped value associated with a key. </p>
<p>This operator provides the standard map-style subscript semantics. If an element with the given key already exists, a reference to its mapped value is returned. Otherwise, a new element is created with the specified key and a value-initialized mapped value (<code>V{}</code>), and a reference to that mapped value is returned.</p>
<p>Unlike <code><a class="el" href="#a2e93f05fd88284a3806a44237de6efcd" title="Access the mapped value associated with a key.">at()</a></code>, this function never throws: missing keys always cause insertion. For this reason, it is only available when the mapped type <code>V</code> is default-initializable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key whose associated value is to be accessed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the existing or newly inserted mapped value. </dd></dl>

</div>
</div>
<a id="aa8bcd9da7375893c15d982b7f93f7de4" name="aa8bcd9da7375893c15d982b7f93f7de4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8bcd9da7375893c15d982b7f93f7de4">&#9670;&#160;</a></span>rbegin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename Alloc = std::allocator&lt;detail::value_t&lt;K, V&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ae9593f170539c50863517dfd18e8d28a">reverse_iterator</a> <a class="el" href="classjh_1_1avl_1_1tree__map.html">jh::avl::tree_map</a>&lt; K, V, Alloc &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a reverse iterator to the last element. </p>
<p>Implemented as <code><a class="el" href="#ae9593f170539c50863517dfd18e8d28a" title="Reverse iterator type.">reverse_iterator(end())</a></code>. A reverse iterator constructed from <code><a class="el" href="#a8a853f97d468ebc517ae421526a31b42" title="Return the past-the-end iterator.">end()</a></code> yields the position obtained conceptually by <code>&ndash;<a class="el" href="#a8a853f97d468ebc517ae421526a31b42" title="Return the past-the-end iterator.">end()</a></code>, which is the element with the greatest key. </p>

</div>
</div>
<a id="a89e0a86254e8c10257f5db6001a68b54" name="a89e0a86254e8c10257f5db6001a68b54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89e0a86254e8c10257f5db6001a68b54">&#9670;&#160;</a></span>rbegin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename Alloc = std::allocator&lt;detail::value_t&lt;K, V&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a94927512ed290484105fa42e90d225d7">const_reverse_iterator</a> <a class="el" href="classjh_1_1avl_1_1tree__map.html">jh::avl::tree_map</a>&lt; K, V, Alloc &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const reverse iterator to the last element. </p>
<p>Same semantics as the non-const overload: constructed from <code><a class="el" href="#a8a853f97d468ebc517ae421526a31b42" title="Return the past-the-end iterator.">end()</a></code>, representing the position produced by the conceptual operation <code>&ndash;<a class="el" href="#a8a853f97d468ebc517ae421526a31b42" title="Return the past-the-end iterator.">end()</a></code>. </p>

</div>
</div>
<a id="abab95b31b2267ec3ebb4d6ad6d07063d" name="abab95b31b2267ec3ebb4d6ad6d07063d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abab95b31b2267ec3ebb4d6ad6d07063d">&#9670;&#160;</a></span>rend() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename Alloc = std::allocator&lt;detail::value_t&lt;K, V&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ae9593f170539c50863517dfd18e8d28a">reverse_iterator</a> <a class="el" href="classjh_1_1avl_1_1tree__map.html">jh::avl::tree_map</a>&lt; K, V, Alloc &gt;::rend </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the reverse past-the-end iterator. </p>
<p>Implemented as <code><a class="el" href="#ae9593f170539c50863517dfd18e8d28a" title="Reverse iterator type.">reverse_iterator(begin())</a></code>. Because <code><a class="el" href="#ae9593f170539c50863517dfd18e8d28a" title="Reverse iterator type.">reverse_iterator</a></code> stores the base iterator and defines its past-the-end position as the value conceptually equal to <code>&ndash;<a class="el" href="#a5b8d6f0d9e6bd7c196e825cba002b646" title="Return an iterator to the smallest element.">begin()</a></code>, this corresponds to the reverse end.</p>
<p>Notably, <code>&ndash;<a class="el" href="#a5b8d6f0d9e6bd7c196e825cba002b646" title="Return an iterator to the smallest element.">begin()</a></code> is the normal forward <code><a class="el" href="#a8a853f97d468ebc517ae421526a31b42" title="Return the past-the-end iterator.">end()</a></code>; therefore this reverse iterator represents the position one step before <code><a class="el" href="#a5b8d6f0d9e6bd7c196e825cba002b646" title="Return an iterator to the smallest element.">begin()</a></code> in reverse traversal. </p>

</div>
</div>
<a id="a989f84dfac9c4962148ce2029188e8d3" name="a989f84dfac9c4962148ce2029188e8d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a989f84dfac9c4962148ce2029188e8d3">&#9670;&#160;</a></span>rend() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename Alloc = std::allocator&lt;detail::value_t&lt;K, V&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a94927512ed290484105fa42e90d225d7">const_reverse_iterator</a> <a class="el" href="classjh_1_1avl_1_1tree__map.html">jh::avl::tree_map</a>&lt; K, V, Alloc &gt;::rend </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the const reverse past-the-end iterator. </p>
<p>Same semantics as the non-const overload: constructed from <code><a class="el" href="#a5b8d6f0d9e6bd7c196e825cba002b646" title="Return an iterator to the smallest element.">begin()</a></code>, representing the reverse past-the-end position associated with the conceptual <code>&ndash;<a class="el" href="#a5b8d6f0d9e6bd7c196e825cba002b646" title="Return an iterator to the smallest element.">begin()</a></code>, which equals the normal forward <code><a class="el" href="#a8a853f97d468ebc517ae421526a31b42" title="Return the past-the-end iterator.">end()</a></code>. </p>

</div>
</div>
<a id="a02d55a785286c84ae7519f56d77cd1aa" name="a02d55a785286c84ae7519f56d77cd1aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02d55a785286c84ae7519f56d77cd1aa">&#9670;&#160;</a></span>reserve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename Alloc = std::allocator&lt;detail::value_t&lt;K, V&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classjh_1_1avl_1_1tree__map.html">jh::avl::tree_map</a>&lt; K, V, Alloc &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reserve space for at least n elements. </p>
<p>Requests that the underlying contiguous storage grow its capacity to at least <code>n</code> elements. This operation does not change the size of the container or alter any existing node indices. </p>
<p>Since iterators refer to elements by stable indices rather than pointers, increasing capacity does not invalidate any iterators, even if the underlying buffer is reallocated. </p>
<p>Calling reserve with a value smaller than the current size is no-op, according to ISO C++11+ standards for standard containers. </p>
<p>With polymorphic allocators (PMR), reserve typically has minimal overhead, as the resource may enlarge the buffer without a full reallocation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Minimum capacity to reserve. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acfc314540e7a87c3b08168258834e4d2" name="acfc314540e7a87c3b08168258834e4d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfc314540e7a87c3b08168258834e4d2">&#9670;&#160;</a></span>shrink_to_fit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename Alloc = std::allocator&lt;detail::value_t&lt;K, V&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classjh_1_1avl_1_1tree__map.html">jh::avl::tree_map</a>&lt; K, V, Alloc &gt;::shrink_to_fit </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Request that the container reduce its capacity. </p>
<p>Issues a non-binding request to the underlying contiguous storage to reduce its capacity. The behavior matches that of <code>std::vector::shrink_to_fit</code>: </p>
<ul>
<li>
The operation may reduce capacity, but is not required to do so. </li>
<li>
There is no guarantee that the resulting capacity equals the size. </li>
<li>
Under polymorphic allocators (PMR), the resource may keep the existing buffer unchanged. </li>
<li>
Because iterators reference elements by index, not pointer, this operation never invalidates iterators. </li>
</ul>

</div>
</div>
<a id="afcfab6605fdfea0b969f6ea07c45f276" name="afcfab6605fdfea0b969f6ea07c45f276"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcfab6605fdfea0b969f6ea07c45f276">&#9670;&#160;</a></span>upper_bound()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename Alloc = std::allocator&lt;detail::value_t&lt;K, V&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structjh_1_1avl_1_1tree__map_1_1iterator.html">iterator</a> <a class="el" href="classjh_1_1avl_1_1tree__map.html">jh::avl::tree_map</a>&lt; K, V, Alloc &gt;::upper_bound </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structjh_1_1avl_1_1avl__node.html#aa0264e8debb087c2f5f3a000960b32f9">node_type::key_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an iterator to the first element whose key is greater than the given key. </p>
<p>Matches the usual ordered-container semantics: </p><ul>
<li>
Returns an iterator referring to the first element for which <code>element.key &gt; key</code>. </li>
<li>
If no such element exists, returns <code><a class="el" href="#a8a853f97d468ebc517ae421526a31b42" title="Return the past-the-end iterator.">end()</a></code>. </li>
<li>
Does not modify the container. </li>
</ul>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/jh/core/<a class="el" href="">ordered_map.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
</div> <!-- top -->
<hr class="footer"/>
<div class="footer">
    <img class="footer-logo" src="Ojing.svg" alt="Ojing"/>
    <div class="footer-text">
        JH-Toolkit v1.4.0 · Generated by Doxygen
    </div>
    <div class="footer-note">
        We primarily support embedded documentation views in IDEs (classic CLion).
        To ensure compatibility with embedded rendering, some example code in this
        documentation intentionally contains HTML entities.
        In certain cases, Doxygen does not unescape these entities correctly.
        This is a known limitation and currently has no workaround.
    </div>
</div>
</body>
</html>
