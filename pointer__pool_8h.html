<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.16.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>JH-Toolkit: include/jh/concurrent/pointer_pool.h File Reference</title>
<link rel="icon" href="Jindallae.svg" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="Oree.svg"/></td>
  <td id="projectalign">
   <div id="projectname">JH-Toolkit<span id="projectnumber">&#160;v1.4.0</span>
   </div>
   <div id="projectbrief">An engineering-oriented C++20 toolkit with duck-typed concepts, static design, async coroutines, and semantic containers — header-only, RTTI-free, and concurrency-friendly.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.16.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('pointer__pool_8h.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">pointer_pool.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Pointer-based interning for non-copyable, non-movable, structurally immutable objects.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;atomic&gt;</code><br />
<code>#include &lt;cstdint&gt;</code><br />
<code>#include &lt;algorithm&gt;</code><br />
<code>#include &lt;vector&gt;</code><br />
<code>#include &lt;unordered_set&gt;</code><br />
<code>#include &lt;mutex&gt;</code><br />
<code>#include &lt;memory&gt;</code><br />
<code>#include &lt;shared_mutex&gt;</code><br />
</div>
<p><a href="">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:jh_3A_3Aconc_3A_3Apointer_5Fpool_3C_20T_2C_20Hash_2C_20Eq_20_3E" id="r_jh_3A_3Aconc_3A_3Apointer_5Fpool_3C_20T_2C_20Hash_2C_20Eq_20_3E"><td class="memItemLeft">class &#160;</td><td class="memItemRight"><a class="el" href="classjh_1_1conc_1_1pointer__pool.html">jh::conc::pointer_pool&lt; T, Hash, Eq &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Weak pointer-observed pool for immutable or structurally immutable objects.  <a href="classjh_1_1conc_1_1pointer__pool.html#details">More...</a><br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Pointer-based interning for non-copyable, non-movable, structurally immutable objects. </p>
<dl class="section copyright"><dt>Copyright</dt><dd>Copyright 2025 JeongHan-Bae &lt;mastropseudo@gmail.com&gt; <br  />
 Licensed under the Apache License, Version 2.0 (the "License"); <br  />
 you may not use this file except in compliance with the License.<br  />
 You may obtain a copy of the License at<br  />
 <br  />
 <a href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a><br  />
 <br  />
 Unless required by applicable law or agreed to in writing, software<br  />
 distributed under the License is distributed on an "AS IS" BASIS,<br  />
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.<br  />
 See the License for the specific language governing permissions and<br  />
 limitations under the License.<br  />
 <br  />
 Full license: <a href="https://github.com/JeongHan-Bae/JH-Toolkit?tab=Apache-2.0-1-ov-file#readme">GitHub</a></dd></dl>
<dl class="section author"><dt>Author</dt><dd>JeongHan-Bae <a href="#" onclick="location.href='mai'+'lto:'+'mas'+'tr'+'ops'+'eu'+'do@'+'gm'+'ail'+'.c'+'om'; return false;">&lt;mastropseudo@gmail.com&gt;</a></dd></dl>
<h3>Overview</h3>
<p><code><a class="el" href="classjh_1_1conc_1_1pointer__pool.html" title="Weak pointer-observed pool for immutable or structurally immutable objects.">jh::conc::pointer_pool</a></code> is a weak-observed pointer interning container designed for objects whose identity is defined intrinsically by the object itself and which cannot be copied, moved, or represented by an external key. These objects are stored and deduplicated through <code>std::shared_ptr</code> instances, while the pool maintains only <code>std::weak_ptr</code> references for lookup and reuse. </p>
<p>The pool specializes in handling objects that must reside at a stable address for their entire lifetime, and therefore cannot be placed inside contiguous storage or trivial containers. It enables pointer-stable sharing without imposing ownership, allocator customization, or intrusive hooks. </p>
<h4>Design Philosophy</h4>
<p>The essential purpose of <code>pointer_pool</code> is to support types that are impossible to intern through traditional contiguous or key-indexed structures. These types may be non-copyable, non-movable, or may express equality only through their full object state rather than an external key. As a result, they cannot participate in compact storage models and must rely on pointer identity for stable lifetime management. </p>
<p>Because the pool only ever stores separate heap-allocated shared objects, fragmentation is unavoidable. For this reason, the pool deliberately avoids allocator customization. Regardless of allocator choice, large numbers of pointer-sized allocations inevitably produce fragmentation, and avoiding it is neither practical nor a design goal for this container. </p>
<h4>Lookup Model</h4>
<p>The pool does not provide a <code>find()</code> operation. This is a fundamental design decision. Equality and hashing depend on the object itself, so a candidate object must already exist before the pool can determine whether an equivalent instance is present. Therefore, every acquisition follows the sequence: </p>
<ol>
<li>
A candidate object is constructed (temporarily). </li>
<li>
The pool performs a hash-based lookup using this constructed object. </li>
<li>
If an equivalent object already exists, that instance is returned and the candidate is discarded. </li>
<li>
If no match exists, the candidate becomes the canonical instance stored inside the pool. </li>
</ol>
<p>This model ensures that objects can be deduplicated even when they offer no external key. However, it also means that construction must always occur before lookup. As such, the theoretical access cost is a combination of <code>O(1)</code> hash addressing and whatever cost is required to build a provisional object. </p>
<h4>Recommended Object Pattern</h4>
<p>Because provisional construction may occur frequently, objects used with <code>pointer_pool</code> should support low-cost identity construction. Heavy initialization should be deferred until after the object becomes the accepted canonical instance. A common pattern is: </p>
<ul>
<li>
Construct identity-defining fields first (used in hashing and equality). </li>
<li>
Perform heavy or mutable initialization lazily, often guarded by <code>std::once_flag</code>. </li>
</ul>
<p>This approach allows the pool to discard temporary instances cheaply while ensuring that full initialization happens only for the accepted canonical object. </p>
<h4>Lifetime and Ownership Model</h4>
<p>The pool never owns any object. All objects are owned exclusively by <code>std::shared_ptr</code> instances returned to the user. The pool only observes these objects via <code>std::weak_ptr</code>. </p>
<p>Because of this design: </p>
<ul>
<li>
The destruction order between the pool and the objects is irrelevant. </li>
<li>
Objects remain valid even if the pool is destroyed first. </li>
<li>
Expired entries are removed opportunistically during insertion or via explicit cleanup calls. </li>
</ul>
<h4>Cleanup and Resizing</h4>
<p>Cleanup is performed on a best-effort basis. The pool removes expired weak entries only during insertion, expansion, or explicit calls to <code>cleanup()</code> and <code>cleanup_shrink()</code>. </p>
<p>Resizing and shrinking are adaptive: </p>
<ul>
<li>
Before expanding, the pool attempts cleanup. </li>
<li>
If the set remains above a high-watermark threshold, capacity grows. </li>
<li>
If cleanup reveals vacancy below a low-watermark threshold, capacity may shrink. </li>
</ul>
<p>This design avoids rehash jitter and minimizes allocation disturbances during periods of high-frequency reuse. </p>
<h4>Intended Use Cases</h4>
<p>The pool is intended for objects that: </p>
<ul>
<li>
cannot be copied or moved, </li>
<li>
cannot be expressed through an external key, </li>
<li>
must rely on full-object equality for deduplication, </li>
<li>
require stable pointer identity throughout their lifetime. </li>
</ul>
<h4>Comparison with <code>flat_pool</code> (<code>resource_pool</code>)</h4>
<p><code>pointer_pool</code> differs fundamentally from <code>flat_pool</code> and its user-layer extension <code>resource_pool</code>. While <code>pointer_pool</code> is designed for immovable, non-copyable objects that cannot be represented by an external key, <code>flat_pool</code> supports contiguous memory layout, slot reuse, and key-driven lookup. It offers <code>find()</code> operations that return a null pointer on miss and can store either keys alone or key-value pairs. Lookup is based on full-hash binary search with <code>O(log N)</code> complexity. </p>
<p>Although <code>flat_pool</code> has asymptotically higher lookup complexity than the <code>O(1)</code> expectation of hash probing, this does not imply inferior performance. Binary search over contiguous memory is extremely cache-friendly, and modern CPUs can predict the comparison pattern effectively due to stable branching behavior. Even without branch prediction, the number of steps is small and bounded. By contrast, hash-table probing involves irregular memory access and higher constant-time factors despite its theoretical <code>O(1)</code> model. As a result, at small and medium scales, <code>flat_pool</code> lookup performance can match or exceed that of <code>pointer_pool</code>. In reality, excessive fragmentation and pointer addressing that may fall into L3 are unacceptable in practical applications, <code>pointer_pool</code> will <b>never</b> be used in large-scale storage, so it can be simply assumed that <code>flat_pool</code> is faster and can store larger amounts of data. </p>
<p><code>flat_pool</code> requires objects to be copyable or movable and can integrate allocator customization. <code>pointer_pool</code> remains the preferred structure for objects that cannot be relocated or keyed externally and must be deduplicated solely through their own equality semantics. </p>
<dl class="section version"><dt>Version</dt><dd><pre>1.4.x</pre> </dd></dl>
<dl class="section date"><dt>Date</dt><dd><pre>2025</pre> </dd></dl>
</div></div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
</div> <!-- top -->
<hr class="footer"/>
<div class="footer">
    <img class="footer-logo" src="Ojing.svg" alt="Ojing"/>
    <div class="footer-text">
        JH-Toolkit v1.4.0 · Generated by Doxygen
    </div>
    <div class="footer-note">
        We primarily support embedded documentation views in IDEs (classic CLion).
        To ensure compatibility with embedded rendering, some example code in this
        documentation intentionally contains HTML entities.
        In certain cases, Doxygen does not unescape these entities correctly.
        This is a known limitation and currently has no workaround.
    </div>
</div>
</body>
</html>
