<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.16.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>JH-Toolkit: include/jh/core/runtime_arr.h File Reference</title>
<link rel="icon" href="Jindallae.svg" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="Oree.svg"/></td>
  <td id="projectalign">
   <div id="projectname">JH-Toolkit<span id="projectnumber">&#160;v1.4.0</span>
   </div>
   <div id="projectbrief">An engineering-oriented C++20 toolkit with duck-typed concepts, static design, async coroutines, and semantic containers — header-only, RTTI-free, and concurrency-friendly.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.16.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('runtime__arr_8h.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">runtime_arr.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>RAII-managed, non-resizable runtime array — a safe modern replacement for C99 VLA.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;cstdint&gt;</code><br />
<code>#include &lt;vector&gt;</code><br />
<code>#include &lt;span&gt;</code><br />
<code>#include &lt;stdexcept&gt;</code><br />
<code>#include &lt;cstring&gt;</code><br />
<code>#include &lt;functional&gt;</code><br />
<code>#include &lt;memory&gt;</code><br />
<code>#include &lt;type_traits&gt;</code><br />
<code>#include &quot;<a class="el" href="">jh/conceptual/iterator.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="">jh/pods/pod_like.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="">jh/typing/monostate.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="">jh/macros/header_begin.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="">jh/macros/header_end.h</a>&quot;</code><br />
</div>
<p><a href="">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:jh_3A_3Aruntime_5Farr_3C_20T_2C_20Alloc_20_3E" id="r_jh_3A_3Aruntime_5Farr_3C_20T_2C_20Alloc_20_3E"><td class="memItemLeft">class &#160;</td><td class="memItemRight"><a class="el" href="classjh_1_1runtime__arr.html">jh::runtime_arr&lt; T, Alloc &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A move-only, fixed-capacity array with runtime-determined length and RAII-based ownership.  <a href="classjh_1_1runtime__arr.html#details">More...</a><br /></td></tr>
<tr class="memitem:jh_3A_3Aruntime_5Farr_3C_20T_2C_20Alloc_20_3E_3A_3Auninitialized_5Ft" id="r_jh_3A_3Aruntime_5Farr_3C_20T_2C_20Alloc_20_3E_3A_3Auninitialized_5Ft"><td class="memItemLeft">struct &#160;</td><td class="memItemRight"><a class="el" href="structjh_1_1runtime__arr_1_1uninitialized__t.html">jh::runtime_arr&lt; T, Alloc &gt;::uninitialized_t</a></td></tr>
<tr class="memitem:jh_3A_3Aruntime_5Farr_5Fhelper_3A_3Abool_5Fflat_5Falloc" id="r_jh_3A_3Aruntime_5Farr_5Fhelper_3A_3Abool_5Fflat_5Falloc"><td class="memItemLeft">struct &#160;</td><td class="memItemRight"><a class="el" href="structjh_1_1runtime__arr__helper_1_1bool__flat__alloc.html">jh::runtime_arr_helper::bool_flat_alloc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flat allocator for <code>bool</code> — disables bit-packing in <code><a class="el" href="classjh_1_1runtime__arr_3_01bool_01_4.html" title="Specialized implementation of jh::runtime_arr&lt;bool&gt; — a compact, bit-packed boolean array.">jh::runtime_arr&lt;bool&gt;</a></code>.  <a href="structjh_1_1runtime__arr__helper_1_1bool__flat__alloc.html#details">More...</a><br /></td></tr>
<tr class="memitem:jh_3A_3Aruntime_5Farr_3C_20bool_20_3E" id="r_jh_3A_3Aruntime_5Farr_3C_20bool_20_3E"><td class="memItemLeft">class &#160;</td><td class="memItemRight"><a class="el" href="classjh_1_1runtime__arr_3_01bool_01_4.html">jh::runtime_arr&lt; bool &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialized implementation of <code><a class="el" href="classjh_1_1runtime__arr_3_01bool_01_4.html" title="Specialized implementation of jh::runtime_arr&lt;bool&gt; — a compact, bit-packed boolean array.">jh::runtime_arr&lt;bool&gt;</a></code> — a compact, bit-packed boolean array.  <a href="classjh_1_1runtime__arr_3_01bool_01_4.html#details">More...</a><br /></td></tr>
<tr class="memitem:jh_3A_3Aruntime_5Farr_3C_20bool_20_3E_3A_3Abit_5Fref" id="r_jh_3A_3Aruntime_5Farr_3C_20bool_20_3E_3A_3Abit_5Fref"><td class="memItemLeft">struct &#160;</td><td class="memItemRight"><a class="el" href="structjh_1_1runtime__arr_3_01bool_01_4_1_1bit__ref.html">jh::runtime_arr&lt; bool &gt;::bit_ref</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal reference proxy for single bit access.  <a href="structjh_1_1runtime__arr_3_01bool_01_4_1_1bit__ref.html#details">More...</a><br /></td></tr>
<tr class="memitem:jh_3A_3Aruntime_5Farr_3C_20bool_20_3E_3A_3Abit_5Fiterator" id="r_jh_3A_3Aruntime_5Farr_3C_20bool_20_3E_3A_3Abit_5Fiterator"><td class="memItemLeft">struct &#160;</td><td class="memItemRight"><a class="el" href="structjh_1_1runtime__arr_3_01bool_01_4_1_1bit__iterator.html">jh::runtime_arr&lt; bool &gt;::bit_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator over individual bits in the bit-packed array.  <a href="structjh_1_1runtime__arr_3_01bool_01_4_1_1bit__iterator.html#details">More...</a><br /></td></tr>
<tr class="memitem:jh_3A_3Aruntime_5Farr_3C_20bool_20_3E_3A_3Abit_5Fconst_5Fiterator" id="r_jh_3A_3Aruntime_5Farr_3C_20bool_20_3E_3A_3Abit_5Fconst_5Fiterator"><td class="memItemLeft">struct &#160;</td><td class="memItemRight"><a class="el" href="structjh_1_1runtime__arr_3_01bool_01_4_1_1bit__const__iterator.html">jh::runtime_arr&lt; bool &gt;::bit_const_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const iterator over individual bits in the bit-packed array.  <a href="structjh_1_1runtime__arr_3_01bool_01_4_1_1bit__const__iterator.html#details">More...</a><br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><p>RAII-managed, non-resizable runtime array — a safe modern replacement for C99 VLA. </p>
<dl class="section copyright"><dt>Copyright</dt><dd>Copyright 2025 JeongHan-Bae &lt;mastropseudo@gmail.com&gt; <br  />
 Licensed under the Apache License, Version 2.0 (the "License"); <br  />
 you may not use this file except in compliance with the License.<br  />
 You may obtain a copy of the License at<br  />
 <br  />
 <a href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a><br  />
 <br  />
 Unless required by applicable law or agreed to in writing, software<br  />
 distributed under the License is distributed on an "AS IS" BASIS,<br  />
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.<br  />
 See the License for the specific language governing permissions and<br  />
 limitations under the License.<br  />
 <br  />
 Full license: <a href="https://github.com/JeongHan-Bae/JH-Toolkit?tab=Apache-2.0-1-ov-file#readme">GitHub</a></dd></dl>
<dl class="section author"><dt>Author</dt><dd>JeongHan-Bae <a href="#" onclick="location.href='mai'+'lto:'+'mas'+'tr'+'ops'+'eu'+'do@'+'gm'+'ail'+'.c'+'om'; return false;">&lt;mastropseudo@gmail.com&gt;</a></dd></dl>
<h3>Overview</h3>
<p><code><a class="el" href="classjh_1_1runtime__arr.html" title="A move-only, fixed-capacity array with runtime-determined length and RAII-based ownership.">jh::runtime_arr&lt;T, Alloc&gt;</a></code> provides a <b>safe, RAII-managed</b> version of the C99 Variable Length Array (VLA) concept, which was removed from C++ due to undefined behavior and stack safety concerns. </p>
<p>It represents a <b>runtime-sized but fixed-capacity</b> array with deterministic lifetime management — effectively combining the semantics of <code>std::array</code> (fixed capacity) with the flexibility of <code>std::vector</code> (runtime sizing), but without dynamic resizing. </p>
<h3>Design Goals</h3>
<ul>
<li>
Provide a safe, heap-based alternative to C99 VLAs with deterministic lifetime (RAII). </li>
<li>
Offer predictable memory ownership and <b>no implicit growth or reallocation</b>. </li>
<li>
Maintain contiguous memory layout and full STL interoperability (<code>std::span</code>, ranges). </li>
<li>
Support POD-aware zeroing (<code>reset_all()</code>) and uninitialized construction paths. </li>
<li>
Expose allocator parameterization for custom memory management, but default to safe local semantics. </li>
</ul>
<h3>Core Characteristics</h3>
<table class="doxtable">
<tr>
<th>Aspect</th><th>Behavior</th></tr>
<tr>
<td>Ownership</td><td>Unique / move-only (RAII semantics)</td></tr>
<tr>
<td>Resizability</td><td>❌ — fixed-size only</td></tr>
<tr>
<td>Allocator</td><td>Optional (default: <code>typed::monostate</code>)</td></tr>
<tr>
<td>Initialization</td><td>Zero, uninitialized, or iterator-based</td></tr>
<tr>
<td>POD optimization</td><td>Automatic <code>memset</code> zeroing for POD-like types</td></tr>
<tr>
<td>Interop</td><td>STL-compatible iterators, <code>std::span</code>, <code>view_interface</code></td></tr>
</table>
<h3>Comparison vs Related Containers</h3>
<table class="doxtable">
<tr>
<th>Feature</th><th><code>std::vector&lt;T&gt;</code></th><th><code><a class="el" href="classjh_1_1runtime__arr.html" title="A move-only, fixed-capacity array with runtime-determined length and RAII-based ownership.">jh::runtime_arr&lt;T&gt;</a></code></th><th><code>std::array&lt;T, N&gt;</code></th><th><code>VLA (C99)</code></th></tr>
<tr>
<td>Compile-time size</td><td>❌</td><td>❌</td><td>✅</td><td>❌</td></tr>
<tr>
<td>Runtime size (fixed after init)</td><td>✅</td><td>✅ (non-resizable)</td><td>❌</td><td>✅</td></tr>
<tr>
<td>Resizing / growth</td><td>✅</td><td>❌</td><td>❌</td><td>❌</td></tr>
<tr>
<td>Allocator control</td><td>✅ (optional)</td><td>✅ (optional)</td><td>❌</td><td>❌</td></tr>
<tr>
<td>Storage location</td><td>Heap</td><td>Heap<br  />
(RAII-managed)</td><td>Stack / static</td><td>Stack (unsafe)</td></tr>
<tr>
<td>Exception safety</td><td>Strong</td><td>Strong<br  />
(RAII + noexcept moves)</td><td>Strong</td><td>Undefined</td></tr>
<tr>
<td>POD zero-reset</td><td>❌</td><td>✅ (<code>reset_all()</code>)</td><td>❌</td><td>❌</td></tr>
<tr>
<td>Lifetime management</td><td>Automatic (allocator)</td><td>RAII-owned unique_ptr</td><td>Automatic</td><td>Automatic (non-deterministic destruction)</td></tr>
</table>
<h3>Design Motivation</h3>
<p>While C99 introduced Variable Length Arrays (VLAs) to allow runtime-sized stack arrays, they were banned in C++ due to undefined lifetime behavior, missing exception handling, and non-portable ABI implications. </p>
<p><code><a class="el" href="classjh_1_1runtime__arr.html" title="A move-only, fixed-capacity array with runtime-determined length and RAII-based ownership.">jh::runtime_arr</a></code> safely revives the same expressiveness using heap-based allocation, strong RAII ownership, and predictable lifetime management — without giving up performance or direct pointer interoperability. </p>
<h3>Specializations</h3>
<ul>
<li>
<code>runtime_arr&lt;bool&gt;</code> — bit-packed specialization (64-bit words). </li>
<li>
Provides <code>set()</code>, <code>unset()</code>, <code>test()</code>, <code>reset_all()</code> for bit control. </li>
<li>
Explicitly disables <code>data()</code> and <code>as_span()</code> for safety. </li>
</ul>
<h3>Notes</h3>
<ul>
<li>
No reallocation or growth semantics; all operations are in-place. </li>
<li>
Prefer <code>reset_all()</code> to <code>clear()</code> for POD types. </li>
<li>
Move-only by design — copying is deleted. </li>
<li>
Ideal as a stable buffer for algorithms requiring strict capacity contracts. </li>
</ul>
<h3>Implementation Summary</h3>
<ul>
<li>
Implements <code>std::ranges::view_interface</code> for range integration. </li>
<li>
Backed by <code>unique_ptr&lt;T[], deleter&gt;</code> (RAII). </li>
<li>
Allocator-aware; default uses <code>typed::monostate</code>. </li>
<li>
Optimized <code>reset_all()</code> for POD/trivially destructible types. </li>
</ul>
<h3>Dual-Mode Header Integration</h3>
<p>This header participates in the <b>Dual-Mode Header</b> system. You do not need to modify the source code to switch build modes: </p>
<ul>
<li>
When linked via <code>jh-toolkit</code> → behaves as a <b>header-only</b> component. </li>
<li>
When linked via <code>jh-toolkit-static</code> → uses the <b>precompiled static</b> implementation. </li>
</ul>
<p>The mode is resolved automatically through <code>JH_INTERNAL_SHOULD_DEFINE</code>, consistent with <code><a class="el" href="classjh_1_1immutable__str.html" title="Immutable string with optional automatic trimming and thread-safe hash caching.">jh::immutable_str</a></code> and other dual-mode headers (<b>currently limited to</b> <code>immutable_str</code> and <code>runtime_arr</code> in v1.3.x, but <b>future releases may extend this system</b> to additional components). </p>
<h3>Performance Summary</h3>
<p>Microbenchmark results for <code><a class="el" href="classjh_1_1runtime__arr.html" title="A move-only, fixed-capacity array with runtime-determined length and RAII-based ownership.">jh::runtime_arr&lt;T&gt;</a></code> (1024 POD elements, Apple Silicon M3, LLVM clang++ 20, 2025): </p>
<table class="doxtable">
<tr>
<th>Optimization Level</th><th><code>std::vector&lt;T&gt;</code></th><th><code>runtime_arr&lt;T&gt;</code></th><th>Relative Speedup</th></tr>
<tr>
<td>-O0</td><td>≈ 7.6 µs</td><td>≈ 0.15 µs</td><td>≈ 50×</td></tr>
<tr>
<td>-O2</td><td>≈ 0.13 µs</td><td>≈ 0.017 µs</td><td>≈ 7×</td></tr>
<tr>
<td>-O3</td><td>≈ 0.15 µs</td><td>≈ 0.017 µs</td><td>≈ 8×</td></tr>
<tr>
<td>-Ofast</td><td>≈ 0.16 µs</td><td>≈ 0.017 µs</td><td>≈ 9×</td></tr>
</table>
<h4>Observations</h4>
<ul>
<li>
Benchmarks executed on <b>Apple Silicon M3</b> using <b>LLVM clang++ 20</b> (Darwin target). </li>
<li>
For trivially constructible POD types, <code>runtime_arr</code> exhibits allocation cost virtually identical to raw <code>operator new[]</code>. </li>
<li>
From <code>-O2</code> upward, both <code>std::vector</code> and <code>runtime_arr</code> reach optimization saturation; higher levels (<code>-O3</code>, <code>-Ofast</code>) bring negligible gains. </li>
<li>
The consistent 6-9× advantage stems from <code>runtime_arr</code>'s simplified layout, absence of <code>allocator_traits</code> indirection, and elimination of dynamic capacity management. </li>
<li>
Measured variance &lt; 1 % across runs, confirming deterministic RAII allocation and compiler inlining behavior. </li>
</ul>
<p>These results indicate that <code><a class="el" href="classjh_1_1runtime__arr.html" title="A move-only, fixed-capacity array with runtime-determined length and RAII-based ownership.">jh::runtime_arr</a></code> offers <b>stable, compiler-optimized, and allocation-efficient</b> performance for fixed-size runtime buffers — matching the predictability of raw arrays while preserving RAII semantics and full STL interoperability. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="conceptjh_1_1pod_1_1pod__like.html" title="Concept for types that are safe to treat as plain old data (POD).">jh::pod::pod_like</a> </dd>
<dd>
<a class="el" href="structjh_1_1typed_1_1monostate.html" title="Trivial empty type representing &quot;no value&quot;.">jh::typed::monostate</a></dd></dl>
<dl class="section version"><dt>Version</dt><dd><pre>1.3.x</pre> </dd></dl>
<dl class="section date"><dt>Date</dt><dd><pre>2025</pre> </dd></dl>
</div></div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
</div> <!-- top -->
<hr class="footer"/>
<div class="footer">
    <img class="footer-logo" src="Ojing.svg" alt="Ojing"/>
    <div class="footer-text">
        JH-Toolkit v1.4.0 · Generated by Doxygen
    </div>
    <div class="footer-note">
        We primarily support embedded documentation views in IDEs (classic CLion).
        To ensure compatibility with embedded rendering, some example code in this
        documentation intentionally contains HTML entities.
        In certain cases, Doxygen does not unescape these entities correctly.
        This is a known limitation and currently has no workaround.
    </div>
</div>
</body>
</html>
