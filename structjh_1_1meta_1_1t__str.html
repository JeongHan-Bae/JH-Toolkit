<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.16.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>JH-Toolkit: jh::meta::t_str&lt; N &gt; Struct Template Reference</title>
<link rel="icon" href="Jindallae.svg" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="Oree.svg"/></td>
  <td id="projectalign">
   <div id="projectname">JH-Toolkit<span id="projectnumber">&#160;v1.4.0</span>
   </div>
   <div id="projectbrief">An engineering-oriented C++20 toolkit with duck-typed concepts, static design, async coroutines, and semantic containers — header-only, RTTI-free, and concurrency-friendly.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.16.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('structjh_1_1meta_1_1t__str.html','','structjh_1_1meta_1_1t__str-members'); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">jh::meta::t_str&lt; N &gt; Struct Template Reference<span class="mlabels"><span class="mlabel final">final</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>Compile-time string wrapper for use as a non-type template parameter (NTTP).  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="">jh/metax/t_str.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-types" class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a0bd4b4dc9d0debdf1935a99ae3133b21" id="r_a0bd4b4dc9d0debdf1935a99ae3133b21"><td class="memItemLeft"><a id="a0bd4b4dc9d0debdf1935a99ae3133b21" name="a0bd4b4dc9d0debdf1935a99ae3133b21"></a>
using&#160;</td><td class="memItemRight"><b>c_hash</b> = <a class="el" href="namespacejh_1_1meta.html#a7ea475ab0421edb9edb93189740da707">jh::meta::c_hash</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9229afa4116b5824fde8899f9c3c65ec" id="r_a9229afa4116b5824fde8899f9c3c65ec"><td class="memItemLeft"><a id="a9229afa4116b5824fde8899f9c3c65ec" name="a9229afa4116b5824fde8899f9c3c65ec"></a>
constexpr&#160;</td><td class="memItemRight"><b>t_str</b> (const <a class="el" href="structjh_1_1pod_1_1array.html">jh::pod::array</a>&lt; char, N &gt; &amp;arr) noexcept</td></tr>
<tr class="memdesc:a9229afa4116b5824fde8899f9c3c65ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">build from underlying buffer <br /></td></tr>
<tr class="memitem:a5325ee97e20308e0f05f68b19a33f6ac" id="r_a5325ee97e20308e0f05f68b19a33f6ac"><td class="memItemLeft">constexpr&#160;</td><td class="memItemRight"><a class="el" href="#a5325ee97e20308e0f05f68b19a33f6ac">t_str</a> (const char(&amp;lit)[N]) noexcept</td></tr>
<tr class="memdesc:a5325ee97e20308e0f05f68b19a33f6ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from a regular string literal.  <br /></td></tr>
<tr class="memitem:abaa5c1df287af9f9bc87c2bf25fa2fcd" id="r_abaa5c1df287af9f9bc87c2bf25fa2fcd"><td class="memItemLeft">constexpr&#160;</td><td class="memItemRight"><a class="el" href="#abaa5c1df287af9f9bc87c2bf25fa2fcd">t_str</a> (const char8_t(&amp;lit)[N]) noexcept</td></tr>
<tr class="memdesc:abaa5c1df287af9f9bc87c2bf25fa2fcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from a <code>char8_t</code>-based string literal (<code>u8""</code>).  <br /></td></tr>
<tr class="memitem:a15a4e2a298654ff46d591ba7efc30ebc" id="r_a15a4e2a298654ff46d591ba7efc30ebc"><td class="memItemLeft">constexpr const char *&#160;</td><td class="memItemRight"><a class="el" href="#a15a4e2a298654ff46d591ba7efc30ebc">val</a> () const noexcept</td></tr>
<tr class="memdesc:a15a4e2a298654ff46d591ba7efc30ebc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the stored string.  <br /></td></tr>
<tr class="memitem:ab7ed596b01a8eb8f2badbe12b4e12b1a" id="r_ab7ed596b01a8eb8f2badbe12b4e12b1a"><td class="memItemLeft">constexpr std::uint64_t&#160;</td><td class="memItemRight"><a class="el" href="#ab7ed596b01a8eb8f2badbe12b4e12b1a">size</a> () const noexcept</td></tr>
<tr class="memdesc:ab7ed596b01a8eb8f2badbe12b4e12b1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the length of the string (excluding null terminator).  <br /></td></tr>
<tr class="memitem:a7d360b5bac935fae54dbdacd1c605a99" id="r_a7d360b5bac935fae54dbdacd1c605a99"><td class="memItemLeft">constexpr std::string_view&#160;</td><td class="memItemRight"><a class="el" href="#a7d360b5bac935fae54dbdacd1c605a99">view</a> () const noexcept</td></tr>
<tr class="memdesc:a7d360b5bac935fae54dbdacd1c605a99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a <code>std::string_view</code> over the stored string.  <br /></td></tr>
<tr class="memitem:a8137432fdf53a6410f409b2134ac2549" id="r_a8137432fdf53a6410f409b2134ac2549"><td class="memItemLeft">constexpr std::uint64_t&#160;</td><td class="memItemRight"><a class="el" href="#a8137432fdf53a6410f409b2134ac2549">hash</a> (<a class="el" href="namespacejh_1_1meta.html#a7ea475ab0421edb9edb93189740da707">c_hash</a> hash_method=<a class="el" href="namespacejh_1_1meta.html#a7ea475ab0421edb9edb93189740da707aca0466d3124e039f7442eccafc2fd891">c_hash::fnv1a64</a>, bool include_null=false) const noexcept</td></tr>
<tr class="memdesc:a8137432fdf53a6410f409b2134ac2549"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a constexpr hash of the stored string.  <br /></td></tr>
<tr class="memitem:a713a59ea00d4385003a7fb60edbdec51" id="r_a713a59ea00d4385003a7fb60edbdec51"><td class="memTemplParams" colspan="2">template&lt;std::uint16_t M&gt; </td></tr>
<tr class="memitem:a713a59ea00d4385003a7fb60edbdec51 template"><td class="memItemLeft">constexpr auto&#160;</td><td class="memItemRight"><a class="el" href="#a713a59ea00d4385003a7fb60edbdec51">operator+</a> (const <a class="el" href="#a63e512d70c443b269a4ff4e9536822b2">t_str</a>&lt; M &gt; &amp;other) const noexcept</td></tr>
<tr class="memdesc:a713a59ea00d4385003a7fb60edbdec51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate two <code><a class="el" href="structjh_1_1meta_1_1t__str.html" title="Compile-time string wrapper for use as a non-type template parameter (NTTP).">t_str</a></code> strings at compile time.  <br /></td></tr>
<tr class="memitem:a5c56cd970c7e48b53984a26846ec5487" id="r_a5c56cd970c7e48b53984a26846ec5487"><td class="memItemLeft">constexpr bool&#160;</td><td class="memItemRight"><a class="el" href="#a5c56cd970c7e48b53984a26846ec5487">is_digit</a> () const noexcept</td></tr>
<tr class="memdesc:a5c56cd970c7e48b53984a26846ec5487"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if all characters are decimal digits (0-9).  <br /></td></tr>
<tr class="memitem:a6e8193c56f496198e5d0ed94f5f55d8c" id="r_a6e8193c56f496198e5d0ed94f5f55d8c"><td class="memItemLeft">constexpr bool&#160;</td><td class="memItemRight"><a class="el" href="#a6e8193c56f496198e5d0ed94f5f55d8c">is_number</a> () const noexcept</td></tr>
<tr class="memdesc:a6e8193c56f496198e5d0ed94f5f55d8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the string represents a valid decimal number.  <br /></td></tr>
<tr class="memitem:ac6c98f4e4b3561e95f515919e7605140" id="r_ac6c98f4e4b3561e95f515919e7605140"><td class="memItemLeft">constexpr bool&#160;</td><td class="memItemRight"><a class="el" href="#ac6c98f4e4b3561e95f515919e7605140">is_alpha</a> () const noexcept</td></tr>
<tr class="memdesc:ac6c98f4e4b3561e95f515919e7605140"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if all characters are alphabetic (A-Z, a-z).  <br /></td></tr>
<tr class="memitem:a62eb990a485d1f1cb155e917c66248cb" id="r_a62eb990a485d1f1cb155e917c66248cb"><td class="memItemLeft">constexpr bool&#160;</td><td class="memItemRight"><a class="el" href="#a62eb990a485d1f1cb155e917c66248cb">is_alnum</a> () const noexcept</td></tr>
<tr class="memdesc:a62eb990a485d1f1cb155e917c66248cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if all characters are alphanumeric (letters or digits).  <br /></td></tr>
<tr class="memitem:aea4bce7946409dfddd227dab1f779889" id="r_aea4bce7946409dfddd227dab1f779889"><td class="memItemLeft">constexpr bool&#160;</td><td class="memItemRight"><a class="el" href="#aea4bce7946409dfddd227dab1f779889">is_ascii</a> () const noexcept</td></tr>
<tr class="memdesc:aea4bce7946409dfddd227dab1f779889"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if all characters are 7-bit ASCII.  <br /></td></tr>
<tr class="memitem:ada4cf866843a8156500acc9d6f494c6c" id="r_ada4cf866843a8156500acc9d6f494c6c"><td class="memItemLeft">constexpr bool&#160;</td><td class="memItemRight"><a class="el" href="#ada4cf866843a8156500acc9d6f494c6c">is_printable_ascii</a> () const noexcept</td></tr>
<tr class="memdesc:ada4cf866843a8156500acc9d6f494c6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if all characters are printable 7-bit ASCII.  <br /></td></tr>
<tr class="memitem:ada7970cb233f42dfc1a838047f438cdd" id="r_ada7970cb233f42dfc1a838047f438cdd"><td class="memItemLeft">constexpr bool&#160;</td><td class="memItemRight"><a class="el" href="#ada7970cb233f42dfc1a838047f438cdd">is_legal</a> () const noexcept</td></tr>
<tr class="memdesc:ada7970cb233f42dfc1a838047f438cdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if all characters are valid (printable ASCII or UTF-8).  <br /></td></tr>
<tr class="memitem:aeaf6275accb3a54d2735f615a9718a78" id="r_aeaf6275accb3a54d2735f615a9718a78"><td class="memItemLeft">constexpr bool&#160;</td><td class="memItemRight"><a class="el" href="#aeaf6275accb3a54d2735f615a9718a78">is_hex</a> () const noexcept</td></tr>
<tr class="memdesc:aeaf6275accb3a54d2735f615a9718a78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the string is a valid hexadecimal sequence.  <br /></td></tr>
<tr class="memitem:a23d88af21f4e795a81e62a12234b06b1" id="r_a23d88af21f4e795a81e62a12234b06b1"><td class="memItemLeft">constexpr bool&#160;</td><td class="memItemRight"><a class="el" href="#a23d88af21f4e795a81e62a12234b06b1">is_base64</a> () const noexcept</td></tr>
<tr class="memdesc:a23d88af21f4e795a81e62a12234b06b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the string is valid Base64.  <br /></td></tr>
<tr class="memitem:a0d3030e30a473173aee2a100be69bffb" id="r_a0d3030e30a473173aee2a100be69bffb"><td class="memItemLeft">constexpr bool&#160;</td><td class="memItemRight"><a class="el" href="#a0d3030e30a473173aee2a100be69bffb">is_base64url</a> () const noexcept</td></tr>
<tr class="memdesc:a0d3030e30a473173aee2a100be69bffb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the string is valid Base64URL.  <br /></td></tr>
<tr class="memitem:aef5091065c65ed91713755bfffa297c4" id="r_aef5091065c65ed91713755bfffa297c4"><td class="memItemLeft">constexpr auto&#160;</td><td class="memItemRight"><a class="el" href="#aef5091065c65ed91713755bfffa297c4">to_upper</a> () const noexcept</td></tr>
<tr class="memdesc:aef5091065c65ed91713755bfffa297c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert all alphabetic characters to uppercase (A-Z).  <br /></td></tr>
<tr class="memitem:aca22e464ab83b53d5313e020e12cefd7" id="r_aca22e464ab83b53d5313e020e12cefd7"><td class="memItemLeft">constexpr auto&#160;</td><td class="memItemRight"><a class="el" href="#aca22e464ab83b53d5313e020e12cefd7">to_lower</a> () const noexcept</td></tr>
<tr class="memdesc:aca22e464ab83b53d5313e020e12cefd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert all alphabetic characters to lowercase (a-z).  <br /></td></tr>
<tr class="memitem:a509090f0a24000a47a998e55c5e9f0fa" id="r_a509090f0a24000a47a998e55c5e9f0fa"><td class="memItemLeft">constexpr auto&#160;</td><td class="memItemRight"><a class="el" href="#a509090f0a24000a47a998e55c5e9f0fa">flip_case</a> () const noexcept</td></tr>
<tr class="memdesc:a509090f0a24000a47a998e55c5e9f0fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Toggle the case of all alphabetic characters.  <br /></td></tr>
<tr class="memitem:ac15b4227f5dac25b67aa998d07f5aac1" id="r_ac15b4227f5dac25b67aa998d07f5aac1"><td class="memTemplParams" colspan="2">template&lt;std::uint16_t M&gt; <br />
requires (M != N)</td></tr>
<tr class="memitem:ac15b4227f5dac25b67aa998d07f5aac1 template"><td class="memItemLeft">constexpr bool&#160;</td><td class="memItemRight"><a class="el" href="#ac15b4227f5dac25b67aa998d07f5aac1">operator==</a> (const <a class="el" href="#a63e512d70c443b269a4ff4e9536822b2">t_str</a>&lt; M &gt; &amp;) const noexcept</td></tr>
<tr class="memdesc:ac15b4227f5dac25b67aa998d07f5aac1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison with another <code><a class="el" href="structjh_1_1meta_1_1t__str.html" title="Compile-time string wrapper for use as a non-type template parameter (NTTP).">t_str</a></code> of different size.  <br /></td></tr>
<tr class="memitem:af7bdc28281625d57eae2b4fb3775f2d3" id="r_af7bdc28281625d57eae2b4fb3775f2d3"><td class="memItemLeft">constexpr bool&#160;</td><td class="memItemRight"><a class="el" href="#af7bdc28281625d57eae2b4fb3775f2d3">operator==</a> (const <a class="el" href="#a63e512d70c443b269a4ff4e9536822b2">t_str</a> &amp;) const noexcept=default</td></tr>
<tr class="memdesc:af7bdc28281625d57eae2b4fb3775f2d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison with another <code><a class="el" href="structjh_1_1meta_1_1t__str.html" title="Compile-time string wrapper for use as a non-type template parameter (NTTP).">t_str</a></code> of the same size.  <br /></td></tr>
<tr class="memitem:af86cf545bb83e243f1545aa6dd510cb5" id="r_af86cf545bb83e243f1545aa6dd510cb5"><td class="memItemLeft">constexpr&#160;</td><td class="memItemRight"><a class="el" href="#af86cf545bb83e243f1545aa6dd510cb5">operator jh::pod::array&lt; std::uint8_t, N - 1 &gt;</a> () const noexcept</td></tr>
<tr class="memdesc:af86cf545bb83e243f1545aa6dd510cb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the string (excluding the null terminator) to a byte array.  <br /></td></tr>
<tr class="memitem:ae7c01a34ea7107c232d412d58535fe65" id="r_ae7c01a34ea7107c232d412d58535fe65"><td class="memItemLeft">constexpr <a class="el" href="structjh_1_1pod_1_1array.html">jh::pod::array</a>&lt; std::uint8_t, N - 1 &gt;&#160;</td><td class="memItemRight"><a class="el" href="#ae7c01a34ea7107c232d412d58535fe65">to_bytes</a> () const noexcept</td></tr>
<tr class="memdesc:ae7c01a34ea7107c232d412d58535fe65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to an immutable byte buffer.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-static-methods" class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a8fc37bddbc6c8be8852cb93147ccc2c1" id="r_a8fc37bddbc6c8be8852cb93147ccc2c1"><td class="memItemLeft">static constexpr <a class="el" href="#a63e512d70c443b269a4ff4e9536822b2">t_str</a>&#160;</td><td class="memItemRight"><a class="el" href="#a8fc37bddbc6c8be8852cb93147ccc2c1">from_bytes</a> (const <a class="el" href="structjh_1_1pod_1_1array.html">jh::pod::array</a>&lt; std::uint8_t, N - 1 &gt; &amp;bytes) noexcept</td></tr>
<tr class="memdesc:a8fc37bddbc6c8be8852cb93147ccc2c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <code>t_str&lt;N&gt;</code> from a byte buffer.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-attribs" class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ad4fbb540ef9d27307ccd6a02c5c76f59" id="r_ad4fbb540ef9d27307ccd6a02c5c76f59"><td class="memItemLeft"><a id="ad4fbb540ef9d27307ccd6a02c5c76f59" name="ad4fbb540ef9d27307ccd6a02c5c76f59"></a>
const <a class="el" href="structjh_1_1pod_1_1array.html">jh::pod::array</a>&lt; char, N &gt;&#160;</td><td class="memItemRight"><b>storage</b></td></tr>
<tr class="memdesc:ad4fbb540ef9d27307ccd6a02c5c76f59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fixed-size storage for the compile-time string (null-terminated). <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-friends" class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a63e512d70c443b269a4ff4e9536822b2" id="r_a63e512d70c443b269a4ff4e9536822b2"><td class="memTemplParams" colspan="2">template&lt;std::uint16_t M&gt; </td></tr>
<tr class="memitem:a63e512d70c443b269a4ff4e9536822b2 template"><td class="memItemLeft">struct&#160;</td><td class="memItemRight"><a class="el" href="#a63e512d70c443b269a4ff4e9536822b2">t_str</a></td></tr>
<tr class="memdesc:a63e512d70c443b269a4ff4e9536822b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Friendship is required for implementing <code>operator+</code>.  <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;std::uint16_t N&gt;<br />
requires detail::t_str_size_legal&lt;N&gt;<br />
struct jh::meta::t_str&lt; N &gt;</div><p>Compile-time string wrapper for use as a non-type template parameter (NTTP). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>The size of the string literal including null terminator.</td></tr>
  </table>
  </dd>
</dl>
<p><code>t_str&lt;N&gt;</code> enables string literals to be bound directly as <b>non-type template parameters (NTTP)</b> in C++20. It provides constexpr construction, validation, transformation, concatenation, and hashing of string literals with <b>zero runtime overhead</b>. </p>
</div><a name="doc-constructors" id="doc-constructors"></a><h2 id="header-doc-constructors" class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a5325ee97e20308e0f05f68b19a33f6ac" name="a5325ee97e20308e0f05f68b19a33f6ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5325ee97e20308e0f05f68b19a33f6ac">&#9670;&#160;</a></span>t_str() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::uint16_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structjh_1_1meta_1_1t__str.html">jh::meta::t_str</a>&lt; N &gt;::t_str </td>
          <td>(</td>
          <td class="paramtype">const char(&amp;)</td>          <td class="paramname"><span class="paramname"><em>lit</em></span>[N]</td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct from a regular string literal. </p>
<p>This constructor is intentionally implicit. It enables string literals to be passed directly as non-type template parameters (NTTP) without requiring additional wrappers. </p>

</div>
</div>
<a id="abaa5c1df287af9f9bc87c2bf25fa2fcd" name="abaa5c1df287af9f9bc87c2bf25fa2fcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaa5c1df287af9f9bc87c2bf25fa2fcd">&#9670;&#160;</a></span>t_str() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::uint16_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structjh_1_1meta_1_1t__str.html">jh::meta::t_str</a>&lt; N &gt;::t_str </td>
          <td>(</td>
          <td class="paramtype">const char8_t(&amp;)</td>          <td class="paramname"><span class="paramname"><em>lit</em></span>[N]</td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct from a <code>char8_t</code>-based string literal (<code>u8""</code>). </p>
<p>This constructor provides compatibility for platforms or codebases where <code>u8""</code> string literals yield <code>const char8_t[]</code>. Each element is converted to <code>char</code> for uniform storage.</p>
<p>This is a non-standard compatibility feature — since in most modern platforms, <code>""</code> literals are already UTF-8 encoded. The intent is only to allow <code>u8""</code> literals to be used seamlessly as NTTP, consistent with regular string literals. </p>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="a509090f0a24000a47a998e55c5e9f0fa" name="a509090f0a24000a47a998e55c5e9f0fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a509090f0a24000a47a998e55c5e9f0fa">&#9670;&#160;</a></span>flip_case()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::uint16_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="structjh_1_1meta_1_1t__str.html">jh::meta::t_str</a>&lt; N &gt;::flip_case </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Toggle the case of all alphabetic characters. </p>
<dl class="section return"><dt>Returns</dt><dd>A new <code><a class="el" href="structjh_1_1meta_1_1t__str.html" title="Compile-time string wrapper for use as a non-type template parameter (NTTP).">t_str</a></code> with each character's case flipped. </dd></dl>

</div>
</div>
<a id="a8fc37bddbc6c8be8852cb93147ccc2c1" name="a8fc37bddbc6c8be8852cb93147ccc2c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fc37bddbc6c8be8852cb93147ccc2c1">&#9670;&#160;</a></span>from_bytes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::uint16_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="#a63e512d70c443b269a4ff4e9536822b2">t_str</a> <a class="el" href="structjh_1_1meta_1_1t__str.html">jh::meta::t_str</a>&lt; N &gt;::from_bytes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structjh_1_1pod_1_1array.html">jh::pod::array</a>&lt; std::uint8_t, N - 1 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>bytes</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a <code>t_str&lt;N&gt;</code> from a byte buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>A <code><a class="el" href="structjh_1_1pod_1_1array.html" title="POD-compatible fixed-size array, similar in shape to std::array, but simpler and fully POD.">jh::pod::array</a>&lt;std::uint8_t, N - 1&gt;</code> representing a binary buffer. <br  />
 The buffer does <b>not</b> contain a null terminator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new <code>t_str&lt;N&gt;</code> whose characters are taken directly from <code>bytes</code>, with a null terminator appended internally.</dd></dl>
<ul>
<li>
This function treats <code>bytes</code> as pure binary data. </li>
<li>
No validation is performed — any byte value (0-255) is accepted. </li>
<li>
The resulting <code><a class="el" href="structjh_1_1meta_1_1t__str.html" title="Compile-time string wrapper for use as a non-type template parameter (NTTP).">t_str</a></code> is always null-terminated internally, because <code><a class="el" href="structjh_1_1meta_1_1t__str.html" title="Compile-time string wrapper for use as a non-type template parameter (NTTP).">t_str</a></code> is semantically a C-string wrapper. </li>
<li>
This method enables a useful pattern: writing a binary buffer as if it were a string literal, then reconstructing <code><a class="el" href="structjh_1_1meta_1_1t__str.html" title="Compile-time string wrapper for use as a non-type template parameter (NTTP).">t_str</a></code> from it.  </li>
<li>
The null terminator added at the end is not part of the returned <em>bytes</em> if converted back using <code><a class="el" href="#ae7c01a34ea7107c232d412d58535fe65" title="Convert to an immutable byte buffer.">to_bytes()</a></code>.  </li>
</ul>

</div>
</div>
<a id="a8137432fdf53a6410f409b2134ac2549" name="a8137432fdf53a6410f409b2134ac2549"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8137432fdf53a6410f409b2134ac2549">&#9670;&#160;</a></span>hash()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::uint16_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::uint64_t <a class="el" href="structjh_1_1meta_1_1t__str.html">jh::meta::t_str</a>&lt; N &gt;::hash </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacejh_1_1meta.html#a7ea475ab0421edb9edb93189740da707">c_hash</a></td>          <td class="paramname"><span class="paramname"><em>hash_method</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespacejh_1_1meta.html#a7ea475ab0421edb9edb93189740da707aca0466d3124e039f7442eccafc2fd891">c_hash::fnv1a64</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>include_null</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute a constexpr hash of the stored string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hash_method</td><td>The hash algorithm to use (default: <code><a class="el" href="namespacejh_1_1meta.html#a7ea475ab0421edb9edb93189740da707aca0466d3124e039f7442eccafc2fd891" title="FNV-1a 64-bit hash.">c_hash::fnv1a64</a></code>). Supported algorithms: <ul>
<li>
<code><a class="el" href="namespacejh_1_1meta.html#a7ea475ab0421edb9edb93189740da707aca0466d3124e039f7442eccafc2fd891" title="FNV-1a 64-bit hash.">c_hash::fnv1a64</a></code> - FNV-1a 64-bit hash (default, fast and well-distributed). </li>
<li>
<code><a class="el" href="namespacejh_1_1meta.html#a7ea475ab0421edb9edb93189740da707a801754de2e3613d0a8384c2e15d8acd0" title="FNV-1 64-bit hash.">c_hash::fnv1_64</a></code> - FNV-1 64-bit hash (multiply before xor). </li>
<li>
<code><a class="el" href="namespacejh_1_1meta.html#a7ea475ab0421edb9edb93189740da707ad135fed35d7b519e59544d89c4710f86" title="DJB2 hash (classic string hash).">c_hash::djb2</a></code> - DJB2 hash (classic string hash). </li>
<li>
<code><a class="el" href="namespacejh_1_1meta.html#a7ea475ab0421edb9edb93189740da707af507ae7f703754f0db87d15de56a7987" title="SDBM hash (used in readdir, DBM).">c_hash::sdbm</a></code> - SDBM hash (used in readdir, DBM). </li>
<li>
<code><a class="el" href="namespacejh_1_1meta.html#a7ea475ab0421edb9edb93189740da707a9b8b9c08ae9b6e050210e9ff2a950116" title="constexpr-safe MurmurHash variant (seedless)">c_hash::murmur64</a></code> - constexpr-safe MurmurHash variant (seedless) </li>
<li>
<code><a class="el" href="namespacejh_1_1meta.html#a7ea475ab0421edb9edb93189740da707ab3fae8c169390abead5d02af0f63d102" title="constexpr xxHash64 variant (seedless)">c_hash::xxhash64</a></code> - constexpr xxHash64 variant (seedless) </li>
</ul>
</td></tr>
    <tr><td class="paramname">include_null</td><td>If true, the null terminator is included in the hash computation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>64-bit non-cryptographic hash value.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>All supported algorithms are constexpr-safe and suitable for compile-time use (e.g., as template arguments or static IDs). They are <b>not cryptographically secure</b>. </dd></dl>

</div>
</div>
<a id="a62eb990a485d1f1cb155e917c66248cb" name="a62eb990a485d1f1cb155e917c66248cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62eb990a485d1f1cb155e917c66248cb">&#9670;&#160;</a></span>is_alnum()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::uint16_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structjh_1_1meta_1_1t__str.html">jh::meta::t_str</a>&lt; N &gt;::is_alnum </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if all characters are alphanumeric (letters or digits). </p>
<dl class="section return"><dt>Returns</dt><dd>true if all characters are alphanumeric, false otherwise. </dd></dl>

</div>
</div>
<a id="ac6c98f4e4b3561e95f515919e7605140" name="ac6c98f4e4b3561e95f515919e7605140"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6c98f4e4b3561e95f515919e7605140">&#9670;&#160;</a></span>is_alpha()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::uint16_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structjh_1_1meta_1_1t__str.html">jh::meta::t_str</a>&lt; N &gt;::is_alpha </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if all characters are alphabetic (A-Z, a-z). </p>
<dl class="section return"><dt>Returns</dt><dd>true if all characters are alphabetic, false otherwise. </dd></dl>

</div>
</div>
<a id="aea4bce7946409dfddd227dab1f779889" name="aea4bce7946409dfddd227dab1f779889"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea4bce7946409dfddd227dab1f779889">&#9670;&#160;</a></span>is_ascii()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::uint16_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structjh_1_1meta_1_1t__str.html">jh::meta::t_str</a>&lt; N &gt;::is_ascii </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if all characters are 7-bit ASCII. </p>
<dl class="section return"><dt>Returns</dt><dd>true if all characters are in range 0-127, false otherwise. </dd></dl>

</div>
</div>
<a id="a23d88af21f4e795a81e62a12234b06b1" name="a23d88af21f4e795a81e62a12234b06b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23d88af21f4e795a81e62a12234b06b1">&#9670;&#160;</a></span>is_base64()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::uint16_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structjh_1_1meta_1_1t__str.html">jh::meta::t_str</a>&lt; N &gt;::is_base64 </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the string is valid Base64. </p>
<p>Length must be a multiple of 4, padding ('=') allowed at the end. </p><dl class="section return"><dt>Returns</dt><dd>true if valid Base64, false otherwise. </dd></dl>

</div>
</div>
<a id="a0d3030e30a473173aee2a100be69bffb" name="a0d3030e30a473173aee2a100be69bffb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d3030e30a473173aee2a100be69bffb">&#9670;&#160;</a></span>is_base64url()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::uint16_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structjh_1_1meta_1_1t__str.html">jh::meta::t_str</a>&lt; N &gt;::is_base64url </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the string is valid Base64URL. </p>
<p>'=' padding is optional. If present, length must be a multiple of 4. </p><dl class="section return"><dt>Returns</dt><dd>true if valid Base64URL, false otherwise. </dd></dl>

</div>
</div>
<a id="a5c56cd970c7e48b53984a26846ec5487" name="a5c56cd970c7e48b53984a26846ec5487"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c56cd970c7e48b53984a26846ec5487">&#9670;&#160;</a></span>is_digit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::uint16_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structjh_1_1meta_1_1t__str.html">jh::meta::t_str</a>&lt; N &gt;::is_digit </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if all characters are decimal digits (0-9). </p>
<dl class="section note"><dt>Note</dt><dd>This only checks that each character is a digit. To validate if the whole string represents a number (with optional sign, decimal point, or exponent), use <code><a class="el" href="#a6e8193c56f496198e5d0ed94f5f55d8c" title="Check if the string represents a valid decimal number.">is_number()</a></code> instead. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>true if all characters are digits, false otherwise. </dd></dl>

</div>
</div>
<a id="aeaf6275accb3a54d2735f615a9718a78" name="aeaf6275accb3a54d2735f615a9718a78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaf6275accb3a54d2735f615a9718a78">&#9670;&#160;</a></span>is_hex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::uint16_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structjh_1_1meta_1_1t__str.html">jh::meta::t_str</a>&lt; N &gt;::is_hex </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the string is a valid hexadecimal sequence. </p>
<p>Length must be even, and all characters must be hex digits. </p><dl class="section return"><dt>Returns</dt><dd>true if valid hex string, false otherwise. </dd></dl>

</div>
</div>
<a id="ada7970cb233f42dfc1a838047f438cdd" name="ada7970cb233f42dfc1a838047f438cdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada7970cb233f42dfc1a838047f438cdd">&#9670;&#160;</a></span>is_legal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::uint16_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structjh_1_1meta_1_1t__str.html">jh::meta::t_str</a>&lt; N &gt;::is_legal </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if all characters are valid (printable ASCII or UTF-8). </p>
<dl class="section return"><dt>Returns</dt><dd>true if all characters are valid, false otherwise. </dd></dl>
<p>&lt; constexpr, avoid using [[likely/unlikely]]</p>

</div>
</div>
<a id="a6e8193c56f496198e5d0ed94f5f55d8c" name="a6e8193c56f496198e5d0ed94f5f55d8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e8193c56f496198e5d0ed94f5f55d8c">&#9670;&#160;</a></span>is_number()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::uint16_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structjh_1_1meta_1_1t__str.html">jh::meta::t_str</a>&lt; N &gt;::is_number </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the string represents a valid decimal number. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the string is a valid number, otherwise <code>false</code>.</dd></dl>
<p>Grammar (simplified BNF): </p><pre>
  [ '+' | '-' ] DIGIT+ [ '.' DIGIT+ ] [ ( 'e' | 'E' ) [ '+' | '-' ] DIGIT+ ]
</pre><p>Equivalent regular expression: </p><pre>
  ^[+-]?[0-9]+(.[0-9]+)?([eE][+-]?[0-9]+)?$
</pre><p>Rules: </p><ul>
<li>
The first character may be <code>'+'</code> or <code>'-'</code>. </li>
<li>
At least one digit must appear before optional '.' or 'e/E'. </li>
<li>
If '.' appears, at least one digit must follow (either before or after '.'). </li>
<li>
If 'e' or 'E' appears, it must be followed by an optional sign and at least one digit. </li>
<li>
Only decimal notation is supported (no hex, octal, binary, or locale-specific formats). </li>
</ul>
<p>do NOT apply [[likely]] as this is constexpr</p>

</div>
</div>
<a id="ada4cf866843a8156500acc9d6f494c6c" name="ada4cf866843a8156500acc9d6f494c6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada4cf866843a8156500acc9d6f494c6c">&#9670;&#160;</a></span>is_printable_ascii()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::uint16_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structjh_1_1meta_1_1t__str.html">jh::meta::t_str</a>&lt; N &gt;::is_printable_ascii </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if all characters are printable 7-bit ASCII. </p>
<dl class="section return"><dt>Returns</dt><dd>true if all characters are in range 32-126, false otherwise. </dd></dl>

</div>
</div>
<a id="af86cf545bb83e243f1545aa6dd510cb5" name="af86cf545bb83e243f1545aa6dd510cb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af86cf545bb83e243f1545aa6dd510cb5">&#9670;&#160;</a></span>operator jh::pod::array&lt; std::uint8_t, N - 1 &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::uint16_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structjh_1_1meta_1_1t__str.html">jh::meta::t_str</a>&lt; N &gt;::operator <a class="el" href="structjh_1_1pod_1_1array.html">jh::pod::array</a>&lt; std::uint8_t, N - 1 &gt; </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel explicit">explicit</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert the string (excluding the null terminator) to a byte array. </p>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="structjh_1_1pod_1_1array.html" title="POD-compatible fixed-size array, similar in shape to std::array, but simpler and fully POD.">jh::pod::array</a>&lt;std::uint8_t, N - 1&gt;</code> containing the string's raw character bytes, excluding the null terminator.</dd></dl>
<ul>
<li>
The returned array contains exactly <code>N - 1</code> bytes — the effective string length. </li>
<li>
The array does <em>not</em> contain a null terminator, because it represents a binary buffer, not a C-string. </li>
<li>
This makes the result suitable for binary serialization, hashing, Base64 encoding, and other byte-wise operations. </li>
<li>
At compile time, values are assigned element-by-element. </li>
<li>
At runtime, <code>std::memcpy</code> is used for maximum efficiency. </li>
</ul>

</div>
</div>
<a id="a713a59ea00d4385003a7fb60edbdec51" name="a713a59ea00d4385003a7fb60edbdec51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a713a59ea00d4385003a7fb60edbdec51">&#9670;&#160;</a></span>operator+()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::uint16_t N&gt; </div>
<div class="memtemplate">
template&lt;std::uint16_t M&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="structjh_1_1meta_1_1t__str.html">jh::meta::t_str</a>&lt; N &gt;::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a63e512d70c443b269a4ff4e9536822b2">t_str</a>&lt; M &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenate two <code><a class="el" href="structjh_1_1meta_1_1t__str.html" title="Compile-time string wrapper for use as a non-type template parameter (NTTP).">t_str</a></code> strings at compile time. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">M</td><td>Size (including null terminator) of the right-hand operand. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Another <code>t_str&lt;M&gt;</code> to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new <code><a class="el" href="structjh_1_1meta_1_1t__str.html" title="Compile-time string wrapper for use as a non-type template parameter (NTTP).">t_str</a></code> whose size is <code>(N - 1) + (M - 1) + 1</code>, containing the concatenated characters and a null terminator.</dd></dl>
<ul>
<li>
Performs constexpr-safe concatenation without dynamic allocation. </li>
<li>
The total size must satisfy <code>t_str_concat_legal</code> (≤ 16 KB). </li>
<li>
The null terminator of the left string is ignored during concatenation, and a new null terminator is appended at the end. </li>
</ul>

</div>
</div>
<a id="af7bdc28281625d57eae2b4fb3775f2d3" name="af7bdc28281625d57eae2b4fb3775f2d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7bdc28281625d57eae2b4fb3775f2d3">&#9670;&#160;</a></span>operator==() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::uint16_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structjh_1_1meta_1_1t__str.html">jh::meta::t_str</a>&lt; N &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a63e512d70c443b269a4ff4e9536822b2">t_str</a>&lt; N &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span><span class="mlabel default">default</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison with another <code><a class="el" href="structjh_1_1meta_1_1t__str.html" title="Compile-time string wrapper for use as a non-type template parameter (NTTP).">t_str</a></code> of the same size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The other <code>t_str&lt;N&gt;</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if all characters match (including the null terminator).</dd></dl>
<p>This operator is <code>= default</code>, meaning comparison is delegated to the underlying member <code>const <a class="el" href="structjh_1_1pod_1_1array.html">jh::pod::array&lt;char, N&gt;</a> storage</code>.</p>
<p>Semantically: it is equivalent to comparing all characters in the string one by one. Implementation-wise: since <code>storage</code> is a POD type, the compiler can optimize this into a direct <code>memcmp</code>-style comparison at compile time or runtime. </p>

</div>
</div>
<a id="ac15b4227f5dac25b67aa998d07f5aac1" name="ac15b4227f5dac25b67aa998d07f5aac1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac15b4227f5dac25b67aa998d07f5aac1">&#9670;&#160;</a></span>operator==() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::uint16_t N&gt; </div>
<div class="memtemplate">
template&lt;std::uint16_t M&gt; <br />
requires (M != N)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structjh_1_1meta_1_1t__str.html">jh::meta::t_str</a>&lt; N &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a63e512d70c443b269a4ff4e9536822b2">t_str</a>&lt; M &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison with another <code><a class="el" href="structjh_1_1meta_1_1t__str.html" title="Compile-time string wrapper for use as a non-type template parameter (NTTP).">t_str</a></code> of different size. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">M</td><td>Size of the other <code><a class="el" href="structjh_1_1meta_1_1t__str.html" title="Compile-time string wrapper for use as a non-type template parameter (NTTP).">t_str</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Unused</td><td>The other string (ignored, since size mismatch short-circuits). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>false</code> always, because string sizes differ.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This overload exists to provide a compile-time fast-path: if <code>N != M</code>, the comparison does not even check characters. </dd></dl>

</div>
</div>
<a id="ab7ed596b01a8eb8f2badbe12b4e12b1a" name="ab7ed596b01a8eb8f2badbe12b4e12b1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7ed596b01a8eb8f2badbe12b4e12b1a">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::uint16_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::uint64_t <a class="el" href="structjh_1_1meta_1_1t__str.html">jh::meta::t_str</a>&lt; N &gt;::size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the length of the string (excluding null terminator). </p>
<dl class="section return"><dt>Returns</dt><dd>Number of characters before the null terminator. </dd></dl>

</div>
</div>
<a id="ae7c01a34ea7107c232d412d58535fe65" name="ae7c01a34ea7107c232d412d58535fe65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7c01a34ea7107c232d412d58535fe65">&#9670;&#160;</a></span>to_bytes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::uint16_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structjh_1_1pod_1_1array.html">jh::pod::array</a>&lt; std::uint8_t, N - 1 &gt; <a class="el" href="structjh_1_1meta_1_1t__str.html">jh::meta::t_str</a>&lt; N &gt;::to_bytes </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert to an immutable byte buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="structjh_1_1pod_1_1array.html" title="POD-compatible fixed-size array, similar in shape to std::array, but simpler and fully POD.">jh::pod::array</a>&lt;std::uint8_t, N - 1&gt;</code> containing the raw characters of the string (not null-terminated).</dd></dl>
<p>This is equivalent to the explicit byte-array conversion operator. </p>

</div>
</div>
<a id="aca22e464ab83b53d5313e020e12cefd7" name="aca22e464ab83b53d5313e020e12cefd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca22e464ab83b53d5313e020e12cefd7">&#9670;&#160;</a></span>to_lower()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::uint16_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="structjh_1_1meta_1_1t__str.html">jh::meta::t_str</a>&lt; N &gt;::to_lower </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert all alphabetic characters to lowercase (a-z). </p>
<dl class="section return"><dt>Returns</dt><dd>A new <code><a class="el" href="structjh_1_1meta_1_1t__str.html" title="Compile-time string wrapper for use as a non-type template parameter (NTTP).">t_str</a></code> with characters transformed to lowercase. </dd></dl>

</div>
</div>
<a id="aef5091065c65ed91713755bfffa297c4" name="aef5091065c65ed91713755bfffa297c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef5091065c65ed91713755bfffa297c4">&#9670;&#160;</a></span>to_upper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::uint16_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="structjh_1_1meta_1_1t__str.html">jh::meta::t_str</a>&lt; N &gt;::to_upper </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert all alphabetic characters to uppercase (A-Z). </p>
<dl class="section return"><dt>Returns</dt><dd>A new <code><a class="el" href="structjh_1_1meta_1_1t__str.html" title="Compile-time string wrapper for use as a non-type template parameter (NTTP).">t_str</a></code> with characters transformed to uppercase. </dd></dl>

</div>
</div>
<a id="a15a4e2a298654ff46d591ba7efc30ebc" name="a15a4e2a298654ff46d591ba7efc30ebc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15a4e2a298654ff46d591ba7efc30ebc">&#9670;&#160;</a></span>val()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::uint16_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * <a class="el" href="structjh_1_1meta_1_1t__str.html">jh::meta::t_str</a>&lt; N &gt;::val </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a pointer to the stored string. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the first character of the internal string (null-terminated).</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The returned pointer comes from <code>storage.data</code>, which is a <code>const char[N]</code>. It decays to <code>const char*</code> on return. </dd></dl>

</div>
</div>
<a id="a7d360b5bac935fae54dbdacd1c605a99" name="a7d360b5bac935fae54dbdacd1c605a99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d360b5bac935fae54dbdacd1c605a99">&#9670;&#160;</a></span>view()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::uint16_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string_view <a class="el" href="structjh_1_1meta_1_1t__str.html">jh::meta::t_str</a>&lt; N &gt;::view </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a <code>std::string_view</code> over the stored string. </p>
<dl class="section return"><dt>Returns</dt><dd>A <code>string_view</code> referencing the characters (excluding null terminator). </dd></dl>

</div>
</div>
<a name="doc-related-members" id="doc-related-members"></a><h2 id="header-doc-related-members" class="groupheader">Friends And Related Symbol Documentation</h2>
<a id="a63e512d70c443b269a4ff4e9536822b2" name="a63e512d70c443b269a4ff4e9536822b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63e512d70c443b269a4ff4e9536822b2">&#9670;&#160;</a></span>t_str</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::uint16_t N&gt; </div>
<div class="memtemplate">
template&lt;std::uint16_t M&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend struct t_str</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel friend">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Friendship is required for implementing <code>operator+</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">M</td><td>Size of the other string literal.</td></tr>
  </table>
  </dd>
</dl>
<p>Different <code>t_str&lt;M&gt;</code> instances must access each other's internal storage to perform constexpr concatenation. </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>include/jh/metax/<a class="el" href="">t_str.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
</div> <!-- top -->
<hr class="footer"/>
<div class="footer">
    <img class="footer-logo" src="Ojing.svg" alt="Ojing"/>
    <div class="footer-text">
        JH-Toolkit v1.4.0 · Generated by Doxygen
    </div>
    <div class="footer-note">
        We primarily support embedded documentation views in IDEs (classic CLion).
        To ensure compatibility with embedded rendering, some example code in this
        documentation intentionally contains HTML entities.
        In certain cases, Doxygen does not unescape these entities correctly.
        This is a known limitation and currently has no workaround.
    </div>
</div>
</body>
</html>
