<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.16.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>JH-Toolkit: include/jh/core/immutable_str.h File Reference</title>
<link rel="icon" href="Jindallae.svg" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="Oree.svg"/></td>
  <td id="projectalign">
   <div id="projectname">JH-Toolkit<span id="projectnumber">&#160;v1.4.0</span>
   </div>
   <div id="projectbrief">An engineering-oriented C++20 toolkit with duck-typed concepts, static design, async coroutines, and semantic containers — header-only, RTTI-free, and concurrency-friendly.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.16.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('immutable__str_8h.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">immutable_str.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Immutable, thread-safe string with optional auto-trimming and dual-mode build support.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;algorithm&gt;</code><br />
<code>#include &lt;memory&gt;</code><br />
<code>#include &lt;unordered_map&gt;</code><br />
<code>#include &lt;unordered_set&gt;</code><br />
<code>#include &lt;string&gt;</code><br />
<code>#include &lt;cstring&gt;</code><br />
<code>#include &lt;string_view&gt;</code><br />
<code>#include &lt;cstdint&gt;</code><br />
<code>#include &lt;optional&gt;</code><br />
<code>#include &lt;type_traits&gt;</code><br />
<code>#include &lt;stdexcept&gt;</code><br />
<code>#include &quot;<a class="el" href="">jh/synchronous/const_lock.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="">jh/concurrent/observe_pool.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="">jh/pods/string_view.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="">jh/macros/header_begin.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="">jh/macros/header_end.h</a>&quot;</code><br />
</div>
<p><a href="">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:jh_3A_3Aimmutable_5Fstr" id="r_jh_3A_3Aimmutable_5Fstr"><td class="memItemLeft">class &#160;</td><td class="memItemRight"><a class="el" href="classjh_1_1immutable__str.html">jh::immutable_str</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Immutable string with optional automatic trimming and thread-safe hash caching.  <a href="classjh_1_1immutable__str.html#details">More...</a><br /></td></tr>
<tr class="memitem:jh_3A_3Aatomic_5Fstr_5Fhash" id="r_jh_3A_3Aatomic_5Fstr_5Fhash"><td class="memItemLeft">struct &#160;</td><td class="memItemRight"><a class="el" href="structjh_1_1atomic__str__hash.html">jh::atomic_str_hash</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Custom hash functor for <code><a class="el" href="namespacejh.html#af7d00b32739582480e12e4abeec9cac1" title="Atomically replaceable handle to an immutable string.">atomic_str_ptr</a></code> and compatible types.  <a href="structjh_1_1atomic__str__hash.html#details">More...</a><br /></td></tr>
<tr class="memitem:jh_3A_3Aatomic_5Fstr_5Feq" id="r_jh_3A_3Aatomic_5Fstr_5Feq"><td class="memItemLeft">struct &#160;</td><td class="memItemRight"><a class="el" href="structjh_1_1atomic__str__eq.html">jh::atomic_str_eq</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Custom equality functor for <code><a class="el" href="namespacejh.html#af7d00b32739582480e12e4abeec9cac1" title="Atomically replaceable handle to an immutable string.">atomic_str_ptr</a></code> and compatible types.  <a href="structjh_1_1atomic__str__eq.html#details">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-concepts" class="groupheader"><a id="concepts" name="concepts"></a>
Concepts</h2></td></tr>
<tr class="memitem:jh_3A_3Aimmutable_5Fstr_5Fcompatible" id="r_jh_3A_3Aimmutable_5Fstr_5Fcompatible"><td class="memItemLeft">concept &#160;</td><td class="memItemRight"><a class="el" href="conceptjh_1_1immutable__str__compatible.html">jh::immutable_str_compatible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept for types compatible with <code><a class="el" href="classjh_1_1immutable__str.html" title="Immutable string with optional automatic trimming and thread-safe hash caching.">jh::immutable_str</a></code>. <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-define-members" class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ac60f7d8cd2f3397b502b804aa73f4f3c" id="r_ac60f7d8cd2f3397b502b804aa73f4f3c"><td class="memItemLeft"><a id="ac60f7d8cd2f3397b502b804aa73f4f3c" name="ac60f7d8cd2f3397b502b804aa73f4f3c"></a>
#define&#160;</td><td class="memItemRight"><b>JH_IMMUTABLE_STR_AUTO_TRIM</b>&#160;&#160;&#160;true</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-typedef-members" class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:af7d00b32739582480e12e4abeec9cac1" id="r_af7d00b32739582480e12e4abeec9cac1"><td class="memItemLeft">using&#160;</td><td class="memItemRight"><a class="el" href="namespacejh.html#af7d00b32739582480e12e4abeec9cac1">jh::atomic_str_ptr</a> = std::shared_ptr&lt;<a class="el" href="classjh_1_1immutable__str.html">immutable_str</a>&gt;</td></tr>
<tr class="memdesc:af7d00b32739582480e12e4abeec9cac1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically replaceable handle to an immutable string.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aa5496e72bc5c5463742f77f45882f042" id="r_aa5496e72bc5c5463742f77f45882f042"><td class="memTemplParams" colspan="2"><a id="aa5496e72bc5c5463742f77f45882f042" name="aa5496e72bc5c5463742f77f45882f042"></a>
template&lt;typename T&gt; </td></tr>
<tr class="memitem:aa5496e72bc5c5463742f77f45882f042 template"><td class="memItemLeft"><a class="el" href="namespacejh.html#af7d00b32739582480e12e4abeec9cac1">atomic_str_ptr</a>&#160;</td><td class="memItemRight"><b>jh::make_atomic</b> (T str)=delete</td></tr>
<tr class="memitem:a310dcaec492c2c916669c623cbdbd34a" id="r_a310dcaec492c2c916669c623cbdbd34a"><td class="memItemLeft"><a class="el" href="namespacejh.html#af7d00b32739582480e12e4abeec9cac1">atomic_str_ptr</a>&#160;</td><td class="memItemRight"><a class="el" href="namespacejh.html#a310dcaec492c2c916669c623cbdbd34a">jh::make_atomic</a> (const char *str)</td></tr>
<tr class="memdesc:a310dcaec492c2c916669c623cbdbd34a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a shared pointer to an <code><a class="el" href="classjh_1_1immutable__str.html" title="Immutable string with optional automatic trimming and thread-safe hash caching.">immutable_str</a></code>.  <br /></td></tr>
<tr class="memitem:a507177b377c063e2200fbf0518f9460e" id="r_a507177b377c063e2200fbf0518f9460e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptjh_1_1concepts_1_1mutex__like.html">jh::concepts::mutex_like</a> M&gt; </td></tr>
<tr class="memitem:a507177b377c063e2200fbf0518f9460e template"><td class="memItemLeft"><a class="el" href="namespacejh.html#af7d00b32739582480e12e4abeec9cac1">atomic_str_ptr</a>&#160;</td><td class="memItemRight"><a class="el" href="namespacejh.html#a507177b377c063e2200fbf0518f9460e">jh::safe_from</a> (std::string_view sv, M &amp;mtx)</td></tr>
<tr class="memdesc:a507177b377c063e2200fbf0518f9460e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a shared pointer to an <code><a class="el" href="classjh_1_1immutable__str.html" title="Immutable string with optional automatic trimming and thread-safe hash caching.">immutable_str</a></code> from a locked string view.  <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Immutable, thread-safe string with optional auto-trimming and dual-mode build support. </p>
<dl class="section copyright"><dt>Copyright</dt><dd>Copyright 2025 JeongHan-Bae &lt;mastropseudo@gmail.com&gt; <br  />
 Licensed under the Apache License, Version 2.0 (the "License"); <br  />
 you may not use this file except in compliance with the License.<br  />
 You may obtain a copy of the License at<br  />
 <br  />
 <a href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a><br  />
 <br  />
 Unless required by applicable law or agreed to in writing, software<br  />
 distributed under the License is distributed on an "AS IS" BASIS,<br  />
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.<br  />
 See the License for the specific language governing permissions and<br  />
 limitations under the License.<br  />
 <br  />
 Full license: <a href="https://github.com/JeongHan-Bae/JH-Toolkit?tab=Apache-2.0-1-ov-file#readme">GitHub</a></dd></dl>
<dl class="section author"><dt>Author</dt><dd>JeongHan-Bae <a href="#" onclick="location.href='mai'+'lto:'+'mas'+'tr'+'ops'+'eu'+'do@'+'gm'+'ail'+'.c'+'om'; return false;">&lt;mastropseudo@gmail.com&gt;</a></dd></dl>
<h3>Overview</h3>
<p><code><a class="el" href="classjh_1_1immutable__str.html" title="Immutable string with optional automatic trimming and thread-safe hash caching.">jh::immutable_str</a></code> provides a <b>true immutable</b> string type in modern C++. It guarantees <b>memory-level immutability</b> and <b>thread safety</b> — once created, the string data can never be modified. This makes it ideal for concurrent environments, global configuration caches, or static metadata storage. </p>
<h4>Key Characteristics</h4>
<ul>
<li>
Strict immutability at the memory level — no API allows modification. </li>
<li>
Thread-safe by design — multiple threads can safely share instances. </li>
<li>
Optional <b>automatic whitespace trimming</b> during construction. </li>
<li>
Compact, zero-reallocation model using <code>unique_ptr&lt;const char[]&gt;</code>. </li>
<li>
Transparent hashing and equality for unordered containers. </li>
<li>
Seamless integration with <code>std::shared_ptr&lt;immutable_str&gt;</code> for safe sharing. </li>
</ul>
<h3>Motivation</h3>
<p>In C++, <code>std::string</code> remains mutable even when declared <code>const</code>. This permits unintended modification via <code>const_cast</code> or aliasing, leading to race conditions and subtle data corruption. <code><a class="el" href="classjh_1_1immutable__str.html" title="Immutable string with optional automatic trimming and thread-safe hash caching.">jh::immutable_str</a></code> eliminates these risks by enforcing immutability both at the type level and memory level. </p>
<h3>Comparison with <code>const std::string</code></h3>
<table class="doxtable">
<tr>
<th>Feature</th><th><code><a class="el" href="classjh_1_1immutable__str.html" title="Immutable string with optional automatic trimming and thread-safe hash caching.">jh::immutable_str</a></code></th><th><code>const std::string</code></th></tr>
<tr>
<td>Memory-level immutability</td><td>✅ True</td><td>❌ False</td></tr>
<tr>
<td>Thread safety</td><td>✅ Safe by design</td><td>❌ Mutable buffer</td></tr>
<tr>
<td>Reallocation risk</td><td>❌ None</td><td>✅ Possible</td></tr>
<tr>
<td>Hashing</td><td>✅ Cached, thread-safe</td><td>❌ Recomputed each time</td></tr>
<tr>
<td>Storage model</td><td>Compact (unique_ptr)</td><td>Dynamic capacity-managed</td></tr>
</table>
<h3>Core Features</h3>
<ul>
<li>
<b>Immutable Data:</b> Stored via <code>unique_ptr&lt;const char[]&gt;</code>, preventing mutation. </li>
<li>
<b>Thread-Safe Hashing:</b> Lazy-evaluated via <code>std::once_flag</code> to ensure safe caching. </li>
<li>
<b>Auto Trimming:</b> Optional compile-time whitespace removal (controlled by <code>JH_IMMUTABLE_STR_AUTO_TRIM</code>). </li>
<li>
<b>Shared Ownership:</b> Distributed through <code><a class="el" href="namespacejh.html#af7d00b32739582480e12e4abeec9cac1" title="Atomically replaceable handle to an immutable string.">jh::atomic_str_ptr</a></code> (<code>shared_ptr</code> alias). </li>
<li>
<b>Interop:</b> Compatible with <code>std::string_view</code> and C-string APIs. </li>
<li>
<b>Custom Hash &amp; Eq:</b> Support for transparent <code>unordered_map</code> lookup via <code>const char*</code>. </li>
</ul>
<h3>Dual-Mode Header Integration</h3>
<p>From <b>v1.3.x</b>, <code><a class="el" href="classjh_1_1immutable__str.html" title="Immutable string with optional automatic trimming and thread-safe hash caching.">jh::immutable_str</a></code> supports the <b>Dual-Mode Header</b> system: </p>
<ul>
<li>
Linked through <code>jh::jh-toolkit</code> → acts as a <b>header-only</b> component. </li>
<li>
Linked through <code>jh::jh-toolkit-static</code> → compiled as a <b>static implementation</b> for performance and deterministic linking. </li>
<li>
Mode controlled internally via <code>JH_INTERNAL_SHOULD_DEFINE</code>. </li>
</ul>
<h4>Static Build Detection</h4>
<p>The method <code>bool <a class="el" href="classjh_1_1immutable__str.html#a86ca0299c8be1d3dccd6b619c366b85b" title="Reports whether this header was built in static mode.">jh::immutable_str::is_static_built()</a></code> allows runtime mode verification: </p>
<ul>
<li>
Returns <b>true</b> if built as part of <code>jh-toolkit-static</code>. </li>
<li>
Returns <b>false</b> when using header-only mode via <code>jh-toolkit</code>. </li>
</ul>
<h3>Usage Example</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="immutable__str.html">jh/immutable_str</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="keyword">auto</span> pool = <a class="code hl_typedef" href="namespacejh.html#abc89d1d2a2d84b2aba124fe8d9ee1d7b">jh::observe_pool&lt;jh::immutable_str&gt;</a>();</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> str = pool.acquire(<span class="stringliteral">&quot;Hello, JH Toolkit!&quot;</span>);</div>
<div class="line">    std::cout &lt;&lt; str-&gt;view() &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aimmutable__str_html"><div class="ttname"><a href="immutable__str.html">immutable_str</a></div><div class="ttdoc">Forwarding header for jh::immutable_str.</div></div>
<div class="ttc" id="anamespacejh_html_abc89d1d2a2d84b2aba124fe8d9ee1d7b"><div class="ttname"><a href="namespacejh.html#abc89d1d2a2d84b2aba124fe8d9ee1d7b">jh::observe_pool</a></div><div class="ttdeci">conc::pointer_pool&lt; T, weak_ptr_hash&lt; T &gt;, weak_ptr_eq&lt; T &gt; &gt; observe_pool</div><div class="ttdoc">Duck-typed alias of jh::conc::pointer_pool for content-based pooling of immutable objects.</div><div class="ttdef"><b>Definition</b> observe_pool.h:202</div></div>
</div><!-- fragment --><p>If the program prints the expected message, it confirms that the correct linkage (header-only or static) is configured properly in your build environment. </p>
<h4>Automatic Pool Integration</h4>
<p>This header automatically includes <code>jh/core/pool.h</code>, exposing the full pooling behavior of <code><a class="el" href="classjh_1_1immutable__str.html" title="Immutable string with optional automatic trimming and thread-safe hash caching.">jh::immutable_str</a></code> without requiring any additional include directives. Because <code><a class="el" href="namespacejh.html#abc89d1d2a2d84b2aba124fe8d9ee1d7b" title="Duck-typed alias of jh::conc::pointer_pool for content-based pooling of immutable objects.">jh::observe_pool</a></code> performs duck-typed deduction (detecting <code>hash()</code> and <code>operator==</code>), <code>immutable_str</code> instances are automatically compatible with <code><a class="el" href="namespacejh.html#abc89d1d2a2d84b2aba124fe8d9ee1d7b" title="Duck-typed alias of jh::conc::pointer_pool for content-based pooling of immutable objects.">jh::observe_pool</a></code>. </p>
<p>In addition to providing <code>hash()</code> and <code>operator==</code>, types used with <code><a class="el" href="namespacejh.html#abc89d1d2a2d84b2aba124fe8d9ee1d7b" title="Duck-typed alias of jh::conc::pointer_pool for content-based pooling of immutable objects.">jh::observe_pool</a></code> must guarantee <b>semantic immutability</b>: once an object is inserted into the pool, its <code>hash()</code> and equality semantics must remain constant for its entire lifetime. This ensures that pooled instances remain stable and deduplicated. </p>
<p><code><a class="el" href="classjh_1_1immutable__str.html" title="Immutable string with optional automatic trimming and thread-safe hash caching.">jh::immutable_str</a></code> naturally satisfies this requirement — its memory content and hash are fixed at construction time and can never change. Therefore, it represents the canonical example of a <b>pool-safe immutable type</b>. </p>
<p>This means you can directly acquire shared, deduplicated immutable strings: </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="immutable__str.html">jh/immutable_str</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cstdio&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <a class="code hl_typedef" href="namespacejh.html#abc89d1d2a2d84b2aba124fe8d9ee1d7b">jh::observe_pool&lt;jh::immutable_str&gt;</a> pool;  <span class="comment">// automatically available</span></div>
<div class="line">    <span class="keyword">auto</span> a = pool.<a class="code hl_function" href="classjh_1_1conc_1_1pointer__pool.html#adb9b3b4c28f20b8aee749bbf9357e09a">acquire</a>(<span class="stringliteral">&quot;JH Toolkit&quot;</span>);</div>
<div class="line">    <span class="keyword">auto</span> b = pool.<a class="code hl_function" href="classjh_1_1conc_1_1pointer__pool.html#adb9b3b4c28f20b8aee749bbf9357e09a">acquire</a>(<span class="stringliteral">&quot;JH Toolkit&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// both handles reference the same pooled immutable instance</span></div>
<div class="line">    <span class="keywordflow">if</span> (a.get() == b.get()) {</div>
<div class="line">        std::puts(<span class="stringliteral">&quot;deduplicated successfully&quot;</span>);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="aclassjh_1_1conc_1_1pointer__pool_html_adb9b3b4c28f20b8aee749bbf9357e09a"><div class="ttname"><a href="classjh_1_1conc_1_1pointer__pool.html#adb9b3b4c28f20b8aee749bbf9357e09a">jh::conc::pointer_pool::acquire</a></div><div class="ttdeci">std::shared_ptr&lt; T &gt; acquire(Args &amp;&amp;... args) const =delete</div><div class="ttdoc">Deleted acquire() for const pointer_pool.</div></div>
</div><!-- fragment --><p>The <code>pool.acquire()</code> call internally checks for an existing equivalent object (by <code>hash()</code> and <code>operator==</code>) and reuses it if found. This guarantees that semantically identical strings always share the same underlying immutable buffer. </p>
<ul>
<li>
<b>Automatic inclusion:</b> <code>jh/pool.h</code> is included by default. </li>
<li>
<b>Value-based pooling:</b> Identical strings resolve to the same shared instance. </li>
<li>
<b>Thread-safe:</b> Pool operations are safe since <code>immutable_str</code> itself is immutable. </li>
<li>
<b>Duck-typed deduction:</b> <code><a class="el" href="namespacejh.html#abc89d1d2a2d84b2aba124fe8d9ee1d7b" title="Duck-typed alias of jh::conc::pointer_pool for content-based pooling of immutable objects.">jh::observe_pool</a></code> automatically recognizes compatible types implementing <code>hash()</code> and <code>operator==</code>. </li>
</ul>
<h3>Performance Notes</h3>
<ul>
<li>
Immutable buffer — no internal reallocation or mutation. </li>
<li>
Constant-time string comparison and hash access after first computation. </li>
<li>
Optimized for concurrent, read-dominant workloads. </li>
<li>
Minimal memory footprint: pointer + cached hash + length field. </li>
<li>
<b>Benchmark:</b> In controlled micro-benchmarks (LLVM@20, Catch2, 1024× iterations), <br  />
 <code><a class="el" href="classjh_1_1immutable__str.html" title="Immutable string with optional automatic trimming and thread-safe hash caching.">jh::immutable_str</a></code> shows performance essentially identical to <code>std::string</code> — sometimes slower by about <b>1%</b>, sometimes faster by up to <b>2%</b>, typically fluctuating within <b>±2%</b>. This variation is within normal measurement noise. </li>
</ul>
<h3>See Also</h3>
<ul>
<li>
<code><a class="el" href="namespacejh.html#abc89d1d2a2d84b2aba124fe8d9ee1d7b" title="Duck-typed alias of jh::conc::pointer_pool for content-based pooling of immutable objects.">jh::observe_pool</a></code> — efficient pooling system compatible with immutable_str. </li>
<li>
<code><a class="el" href="namespacejh.html#af7d00b32739582480e12e4abeec9cac1" title="Atomically replaceable handle to an immutable string.">jh::atomic_str_ptr</a></code> — shared-pointer alias for efficient immutable string sharing. </li>
</ul>
<dl class="section version"><dt>Version</dt><dd><pre>1.3.x</pre> </dd></dl>
<dl class="section date"><dt>Date</dt><dd><pre>2025</pre> </dd></dl>
</div></div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
</div> <!-- top -->
<hr class="footer"/>
<div class="footer">
    <img class="footer-logo" src="Ojing.svg" alt="Ojing"/>
    <div class="footer-text">
        JH-Toolkit v1.4.0 · Generated by Doxygen
    </div>
    <div class="footer-note">
        We primarily support embedded documentation views in IDEs (classic CLion).
        To ensure compatibility with embedded rendering, some example code in this
        documentation intentionally contains HTML entities.
        In certain cases, Doxygen does not unescape these entities correctly.
        This is a known limitation and currently has no workaround.
    </div>
</div>
</body>
</html>
