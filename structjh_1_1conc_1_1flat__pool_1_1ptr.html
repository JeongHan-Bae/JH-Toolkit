<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.16.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>JH-Toolkit: jh::conc::flat_pool&lt; Key, Value, Hash, Alloc &gt;::ptr Struct Reference</title>
<link rel="icon" href="Jindallae.svg" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="Oree.svg"/></td>
  <td id="projectalign">
   <div id="projectname">JH-Toolkit<span id="projectnumber">&#160;v1.4.0</span>
   </div>
   <div id="projectbrief">An engineering-oriented C++20 toolkit with duck-typed concepts, static design, async coroutines, and semantic containers — header-only, RTTI-free, and concurrency-friendly.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.16.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('structjh_1_1conc_1_1flat__pool_1_1ptr.html','','structjh_1_1conc_1_1flat__pool_1_1ptr-members'); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">jh::conc::flat_pool&lt; Key, Value, Hash, Alloc &gt;::ptr Struct Reference<span class="mlabels"><span class="mlabel final">final</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>Reference-counted handle to a pooled object.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="">jh/concurrent/flat_pool.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a92909ec45f5796198ddd42d4b6db26ee" id="r_a92909ec45f5796198ddd42d4b6db26ee"><td class="memItemLeft"><a id="a92909ec45f5796198ddd42d4b6db26ee" name="a92909ec45f5796198ddd42d4b6db26ee"></a>
&#160;</td><td class="memItemRight"><b>ptr</b> ()=default</td></tr>
<tr class="memdesc:a92909ec45f5796198ddd42d4b6db26ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default-constructs a null handle. <br /></td></tr>
<tr class="memitem:aef7c80e072124854fdc6716cd92d7c2d" id="r_aef7c80e072124854fdc6716cd92d7c2d"><td class="memItemLeft">&#160;</td><td class="memItemRight"><a class="el" href="#aef7c80e072124854fdc6716cd92d7c2d">ptr</a> (<a class="el" href="classjh_1_1conc_1_1flat__pool.html#ac32d8a004ad7a4d8ee9081a0349999e2">flat_pool</a> *p, size_t i)</td></tr>
<tr class="memdesc:aef7c80e072124854fdc6716cd92d7c2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a handle referencing a pool slot.  <br /></td></tr>
<tr class="memitem:a05a8afb7534b608bf85d49614c2228d0" id="r_a05a8afb7534b608bf85d49614c2228d0"><td class="memItemLeft"><a id="a05a8afb7534b608bf85d49614c2228d0" name="a05a8afb7534b608bf85d49614c2228d0"></a>
&#160;</td><td class="memItemRight"><b>ptr</b> (std::nullptr_t)</td></tr>
<tr class="memdesc:a05a8afb7534b608bf85d49614c2228d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a null handle. <br /></td></tr>
<tr class="memitem:a4188fec1af18f1c3ca76f482752b6762" id="r_a4188fec1af18f1c3ca76f482752b6762"><td class="memItemLeft">&#160;</td><td class="memItemRight"><a class="el" href="#a4188fec1af18f1c3ca76f482752b6762">ptr</a> (const ptr &amp;o)</td></tr>
<tr class="memdesc:a4188fec1af18f1c3ca76f482752b6762"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy-constructs a handle.  <br /></td></tr>
<tr class="memitem:a97172b50186827dc8574ae1a4f16be17" id="r_a97172b50186827dc8574ae1a4f16be17"><td class="memItemLeft"><a class="el" href="#a92909ec45f5796198ddd42d4b6db26ee">ptr</a> &amp;&#160;</td><td class="memItemRight"><a class="el" href="#a97172b50186827dc8574ae1a4f16be17">operator=</a> (const <a class="el" href="#a92909ec45f5796198ddd42d4b6db26ee">ptr</a> &amp;o)</td></tr>
<tr class="memdesc:a97172b50186827dc8574ae1a4f16be17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy-assigns a handle.  <br /></td></tr>
<tr class="memitem:a2342a5e0451451c464fc99a2400b90e6" id="r_a2342a5e0451451c464fc99a2400b90e6"><td class="memItemLeft">&#160;</td><td class="memItemRight"><a class="el" href="#a2342a5e0451451c464fc99a2400b90e6">ptr</a> (ptr &amp;&amp;o) noexcept</td></tr>
<tr class="memdesc:a2342a5e0451451c464fc99a2400b90e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move-constructs a handle.  <br /></td></tr>
<tr class="memitem:a00d14c8f69534de6bac6c42ad33fc8f8" id="r_a00d14c8f69534de6bac6c42ad33fc8f8"><td class="memItemLeft"><a class="el" href="#a92909ec45f5796198ddd42d4b6db26ee">ptr</a> &amp;&#160;</td><td class="memItemRight"><a class="el" href="#a00d14c8f69534de6bac6c42ad33fc8f8">operator=</a> (<a class="el" href="#a92909ec45f5796198ddd42d4b6db26ee">ptr</a> &amp;&amp;o) noexcept</td></tr>
<tr class="memdesc:a00d14c8f69534de6bac6c42ad33fc8f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move-assigns a handle.  <br /></td></tr>
<tr class="memitem:a7c89287418dff4c9771e2ee975c8f32a" id="r_a7c89287418dff4c9771e2ee975c8f32a"><td class="memItemLeft">&#160;</td><td class="memItemRight"><a class="el" href="#a7c89287418dff4c9771e2ee975c8f32a">~ptr</a> ()</td></tr>
<tr class="memdesc:a7c89287418dff4c9771e2ee975c8f32a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases the reference held by this handle.  <br /></td></tr>
<tr class="memitem:acee985b97111bc1585573304fc97958b" id="r_acee985b97111bc1585573304fc97958b"><td class="memItemLeft">void&#160;</td><td class="memItemRight"><a class="el" href="#acee985b97111bc1585573304fc97958b">reset</a> ()</td></tr>
<tr class="memdesc:acee985b97111bc1585573304fc97958b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases the reference held by this handle and resets it to null.  <br /></td></tr>
<tr class="memitem:a5ab3f667b2801867f2d9d0fdbf7b0132" id="r_a5ab3f667b2801867f2d9d0fdbf7b0132"><td class="memItemLeft"><a class="el" href="classjh_1_1conc_1_1flat__pool.html#af79c6502a669200bc37add1249f187a0">value_type</a> &amp;&#160;</td><td class="memItemRight"><a class="el" href="#a5ab3f667b2801867f2d9d0fdbf7b0132">operator*</a> ()</td></tr>
<tr class="memdesc:a5ab3f667b2801867f2d9d0fdbf7b0132"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dereferences the handle to access the stored object.  <br /></td></tr>
<tr class="memitem:aeb49fb6f5cd658b89c529f2cca69c0c6" id="r_aeb49fb6f5cd658b89c529f2cca69c0c6"><td class="memItemLeft"><a class="el" href="classjh_1_1conc_1_1flat__pool.html#af79c6502a669200bc37add1249f187a0">value_type</a> *&#160;</td><td class="memItemRight"><a class="el" href="#aeb49fb6f5cd658b89c529f2cca69c0c6">operator-&gt;</a> ()</td></tr>
<tr class="memdesc:aeb49fb6f5cd658b89c529f2cca69c0c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Member access to the stored object.  <br /></td></tr>
<tr class="memitem:adaa1b3f47ee94a1e6d93a1758c33fe2f" id="r_adaa1b3f47ee94a1e6d93a1758c33fe2f"><td class="memItemLeft"><a id="adaa1b3f47ee94a1e6d93a1758c33fe2f" name="adaa1b3f47ee94a1e6d93a1758c33fe2f"></a>
bool&#160;</td><td class="memItemRight"><b>operator==</b> (const <a class="el" href="#a92909ec45f5796198ddd42d4b6db26ee">ptr</a> &amp;other) const =default</td></tr>
<tr class="memdesc:adaa1b3f47ee94a1e6d93a1758c33fe2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two handles for equality. <br /></td></tr>
<tr class="memitem:a806e3c620f69ad178d4b0661907971d4" id="r_a806e3c620f69ad178d4b0661907971d4"><td class="memItemLeft"><a id="a806e3c620f69ad178d4b0661907971d4" name="a806e3c620f69ad178d4b0661907971d4"></a>
bool&#160;</td><td class="memItemRight"><b>operator==</b> (std::nullptr_t)</td></tr>
<tr class="memdesc:a806e3c620f69ad178d4b0661907971d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the handle against <code>nullptr</code>. <br /></td></tr>
<tr class="memitem:ac2dd4ef752032ea4bdc5d77566a056d4" id="r_ac2dd4ef752032ea4bdc5d77566a056d4"><td class="memItemLeft">flat_pool::no_reallocate_guard&#160;</td><td class="memItemRight"><a class="el" href="#ac2dd4ef752032ea4bdc5d77566a056d4">guard</a> () const</td></tr>
<tr class="memdesc:ac2dd4ef752032ea4bdc5d77566a056d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquires a guard that prevents pool reallocation during dereference.  <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename Key, typename Value = jh::typed::monostate, typename Hash = jh::hash&lt;Key&gt;, typename Alloc = std::allocator&lt;detail::value_t&lt;Key, Value&gt;&gt;&gt;<br />
struct jh::conc::flat_pool&lt; Key, Value, Hash, Alloc &gt;::ptr</div><p>Reference-counted handle to a pooled object. </p>
<p><code><a class="el" href="structjh_1_1conc_1_1flat__pool_1_1ptr.html" title="Reference-counted handle to a pooled object.">flat_pool::ptr</a></code> is a lightweight RAII handle that represents a reference to a slot within a <code><a class="el" href="classjh_1_1conc_1_1flat__pool.html" title="Hash-ordered, contiguous resource interning pool.">flat_pool</a></code>. </p>
<p>Copying a <code>ptr</code> increments the underlying slot's reference count. Destruction or reset decrements it. When the count reaches zero, the slot becomes eligible for reuse. </p>
<h5>Dereferencing and Safety</h5>
<p>Dereferencing yields a reference or pointer to the underlying stored object. In multithreaded contexts where the pool may be resized concurrently, users must acquire a <code>no_reallocate_guard</code> before dereferencing to prevent vector reallocation. </p>
<h5>Null Semantics</h5>
<p>A default-constructed or explicitly reset <code>ptr</code> represents a null handle and compares equal to <code>nullptr</code>. </p>
<dl class="section note"><dt>Note</dt><dd>In fact, <code><a class="el" href="structjh_1_1conc_1_1flat__pool_1_1ptr.html" title="Reference-counted handle to a pooled object.">flat_pool::ptr</a></code> behaves exactly like <code>shared_ptr</code> (i.e., copy/move construction/assignment shares the handle, and the object is logically dead when the count is 0). <br  />
 Even if the slot is not reused, the object remains unreachable once it is dead. <br  />
 <code><a class="el" href="structjh_1_1conc_1_1flat__pool_1_1ptr.html" title="Reference-counted handle to a pooled object.">flat_pool::ptr</a></code>, as a pool pointer, simply provides an additional way to retrieve objects from the pool using <code>find</code> and <code>acquire</code>, as well as lazy (GC-like) object destruction. </dd></dl>
</div><a name="doc-constructors" id="doc-constructors"></a><h2 id="header-doc-constructors" class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aef7c80e072124854fdc6716cd92d7c2d" name="aef7c80e072124854fdc6716cd92d7c2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef7c80e072124854fdc6716cd92d7c2d">&#9670;&#160;</a></span>ptr() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key, typename Value = jh::typed::monostate, typename Hash = jh::hash&lt;Key&gt;, typename Alloc = std::allocator&lt;detail::value_t&lt;Key, Value&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classjh_1_1conc_1_1flat__pool.html">jh::conc::flat_pool</a>&lt; Key, Value, Hash, Alloc &gt;::ptr::ptr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classjh_1_1conc_1_1flat__pool.html#ac32d8a004ad7a4d8ee9081a0349999e2">flat_pool</a> *</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>i</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a handle referencing a pool slot. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Pointer to the owning pool. </td></tr>
    <tr><td class="paramname">i</td><td>Storage index within the pool. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4188fec1af18f1c3ca76f482752b6762" name="a4188fec1af18f1c3ca76f482752b6762"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4188fec1af18f1c3ca76f482752b6762">&#9670;&#160;</a></span>ptr() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key, typename Value = jh::typed::monostate, typename Hash = jh::hash&lt;Key&gt;, typename Alloc = std::allocator&lt;detail::value_t&lt;Key, Value&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classjh_1_1conc_1_1flat__pool.html">jh::conc::flat_pool</a>&lt; Key, Value, Hash, Alloc &gt;::ptr::ptr </td>
          <td>(</td>
          <td class="paramtype">const ptr &amp;</td>          <td class="paramname"><span class="paramname"><em>o</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy-constructs a handle. </p>
<p>The new handle references the same slot and increments the associated reference count.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">o</td><td>Source handle. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2342a5e0451451c464fc99a2400b90e6" name="a2342a5e0451451c464fc99a2400b90e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2342a5e0451451c464fc99a2400b90e6">&#9670;&#160;</a></span>ptr() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key, typename Value = jh::typed::monostate, typename Hash = jh::hash&lt;Key&gt;, typename Alloc = std::allocator&lt;detail::value_t&lt;Key, Value&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classjh_1_1conc_1_1flat__pool.html">jh::conc::flat_pool</a>&lt; Key, Value, Hash, Alloc &gt;::ptr::ptr </td>
          <td>(</td>
          <td class="paramtype">ptr &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>o</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move-constructs a handle. </p>
<p>Transfers the reference without modifying the reference count. The source handle is reset to null.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">o</td><td>Source handle. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7c89287418dff4c9771e2ee975c8f32a" name="a7c89287418dff4c9771e2ee975c8f32a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c89287418dff4c9771e2ee975c8f32a">&#9670;&#160;</a></span>~ptr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key, typename Value = jh::typed::monostate, typename Hash = jh::hash&lt;Key&gt;, typename Alloc = std::allocator&lt;detail::value_t&lt;Key, Value&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classjh_1_1conc_1_1flat__pool.html">jh::conc::flat_pool</a>&lt; Key, Value, Hash, Alloc &gt;::ptr::~ptr </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Releases the reference held by this handle. </p>
<p>If the reference count drops to zero, the slot is marked as unoccupied, but the stored object is <b>not</b> destroyed at this point.</p>
<p>This design avoids immediate destructor invocation, which may be expensive. In many cases, reassigning an existing object is cheaper than destroying and reconstructing it. </p>
<p>The underlying object is only destroyed when the slot is reused or forcibly reclaimed during <code><a class="el" href="classjh_1_1conc_1_1flat__pool.html#a97a29e766058f5171a1a3c09d5f30f1b" title="Shrinks internal storage to fit active entries.">resize_pool()</a></code>, following a GC-like deferred reclamation strategy. </p>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="ac2dd4ef752032ea4bdc5d77566a056d4" name="ac2dd4ef752032ea4bdc5d77566a056d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2dd4ef752032ea4bdc5d77566a056d4">&#9670;&#160;</a></span>guard()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key, typename Value = jh::typed::monostate, typename Hash = jh::hash&lt;Key&gt;, typename Alloc = std::allocator&lt;detail::value_t&lt;Key, Value&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">flat_pool::no_reallocate_guard <a class="el" href="classjh_1_1conc_1_1flat__pool.html">jh::conc::flat_pool</a>&lt; Key, Value, Hash, Alloc &gt;::ptr::guard </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Acquires a guard that prevents pool reallocation during dereference. </p>
<p>The pointer itself is stable, but the underlying contiguous storage may be reallocated by other threads, which would invalidate any obtained <code>T&amp;</code> or <code>T*</code>. This guard prevents such reallocation while it is held. </p>
<p>In multithreaded contexts, the guard must be held whenever dereferencing the pointer if other threads may trigger pool resizing. </p>
<dl class="section return"><dt>Returns</dt><dd>A guard witch is non-copyable, non-movable, and scope-bound, making escape or misuse impossible. </dd></dl>

</div>
</div>
<a id="a5ab3f667b2801867f2d9d0fdbf7b0132" name="a5ab3f667b2801867f2d9d0fdbf7b0132"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ab3f667b2801867f2d9d0fdbf7b0132">&#9670;&#160;</a></span>operator*()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key, typename Value = jh::typed::monostate, typename Hash = jh::hash&lt;Key&gt;, typename Alloc = std::allocator&lt;detail::value_t&lt;Key, Value&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classjh_1_1conc_1_1flat__pool.html#af79c6502a669200bc37add1249f187a0">value_type</a> &amp; <a class="el" href="classjh_1_1conc_1_1flat__pool.html">jh::conc::flat_pool</a>&lt; Key, Value, Hash, Alloc &gt;::ptr::operator* </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dereferences the handle to access the stored object. </p>
<p>In single-threaded usage, this operator may be used directly. </p>
<p>In multithreaded contexts, if more than one thread may operate on the pool and any operation could trigger reallocation (including insertion or <code><a class="el" href="classjh_1_1conc_1_1flat__pool.html#a97a29e766058f5171a1a3c09d5f30f1b" title="Shrinks internal storage to fit active entries.">resize_pool()</a></code>), the caller must hold a guard obtained via <code>auto g = p.guard();</code> for the duration of the access. </p>
<p>Failing to do so may result in a dangling reference even though the pointer itself remains logically valid. </p>

</div>
</div>
<a id="aeb49fb6f5cd658b89c529f2cca69c0c6" name="aeb49fb6f5cd658b89c529f2cca69c0c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb49fb6f5cd658b89c529f2cca69c0c6">&#9670;&#160;</a></span>operator-&gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key, typename Value = jh::typed::monostate, typename Hash = jh::hash&lt;Key&gt;, typename Alloc = std::allocator&lt;detail::value_t&lt;Key, Value&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classjh_1_1conc_1_1flat__pool.html#af79c6502a669200bc37add1249f187a0">value_type</a> * <a class="el" href="classjh_1_1conc_1_1flat__pool.html">jh::conc::flat_pool</a>&lt; Key, Value, Hash, Alloc &gt;::ptr::operator-&gt; </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Member access to the stored object. </p>
<p>In single-threaded usage, this operator may be used directly. </p>
<p>In multithreaded contexts where concurrent operations on the pool may cause reallocation (such as insertion or forced shrinking), callers must acquire a guard with <code>auto g = p.guard();</code> before using this operator. </p>
<p>The guard ensures the underlying storage remains stable for the duration of the access. </p>

</div>
</div>
<a id="a97172b50186827dc8574ae1a4f16be17" name="a97172b50186827dc8574ae1a4f16be17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97172b50186827dc8574ae1a4f16be17">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key, typename Value = jh::typed::monostate, typename Hash = jh::hash&lt;Key&gt;, typename Alloc = std::allocator&lt;detail::value_t&lt;Key, Value&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a92909ec45f5796198ddd42d4b6db26ee">ptr</a> &amp; <a class="el" href="classjh_1_1conc_1_1flat__pool.html">jh::conc::flat_pool</a>&lt; Key, Value, Hash, Alloc &gt;::ptr::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a92909ec45f5796198ddd42d4b6db26ee">ptr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>o</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy-assigns a handle. </p>
<p>Releases the currently held reference (if any), then acquires a reference to the slot held by the source handle.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">o</td><td>Source handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to this handle. </dd></dl>

</div>
</div>
<a id="a00d14c8f69534de6bac6c42ad33fc8f8" name="a00d14c8f69534de6bac6c42ad33fc8f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00d14c8f69534de6bac6c42ad33fc8f8">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key, typename Value = jh::typed::monostate, typename Hash = jh::hash&lt;Key&gt;, typename Alloc = std::allocator&lt;detail::value_t&lt;Key, Value&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a92909ec45f5796198ddd42d4b6db26ee">ptr</a> &amp; <a class="el" href="classjh_1_1conc_1_1flat__pool.html">jh::conc::flat_pool</a>&lt; Key, Value, Hash, Alloc &gt;::ptr::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a92909ec45f5796198ddd42d4b6db26ee">ptr</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>o</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move-assigns a handle. </p>
<p>Releases the currently held reference (if any) and takes ownership of the reference held by the source handle. The source handle is reset to null.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">o</td><td>Source handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to this handle. </dd></dl>

</div>
</div>
<a id="acee985b97111bc1585573304fc97958b" name="acee985b97111bc1585573304fc97958b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acee985b97111bc1585573304fc97958b">&#9670;&#160;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key, typename Value = jh::typed::monostate, typename Hash = jh::hash&lt;Key&gt;, typename Alloc = std::allocator&lt;detail::value_t&lt;Key, Value&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classjh_1_1conc_1_1flat__pool.html">jh::conc::flat_pool</a>&lt; Key, Value, Hash, Alloc &gt;::ptr::reset </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Releases the reference held by this handle and resets it to null. </p>
<p>This function follows STL smart pointer conventions: the handle is explicitly reset to a null state rather than being manually destroyed.</p>
<p>Decrements the reference count of the associated slot. If the count reaches zero, the slot is marked as unoccupied but the stored object is not immediately destroyed. </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>include/jh/concurrent/<a class="el" href="">flat_pool.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
</div> <!-- top -->
<hr class="footer"/>
<div class="footer">
    <img class="footer-logo" src="Ojing.svg" alt="Ojing"/>
    <div class="footer-text">
        JH-Toolkit v1.4.0 · Generated by Doxygen
    </div>
    <div class="footer-note">
        We primarily support embedded documentation views in IDEs (classic CLion).
        To ensure compatibility with embedded rendering, some example code in this
        documentation intentionally contains HTML entities.
        In certain cases, Doxygen does not unescape these entities correctly.
        This is a known limitation and currently has no workaround.
    </div>
</div>
</body>
</html>
