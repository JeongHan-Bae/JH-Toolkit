<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.16.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>JH-Toolkit: jh::avl::tree_map&lt; K, V, Alloc &gt;::const_iterator Struct Reference</title>
<link rel="icon" href="Jindallae.svg" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="Oree.svg"/></td>
  <td id="projectalign">
   <div id="projectname">JH-Toolkit<span id="projectnumber">&#160;v1.4.0</span>
   </div>
   <div id="projectbrief">An engineering-oriented C++20 toolkit with duck-typed concepts, static design, async coroutines, and semantic containers — header-only, RTTI-free, and concurrency-friendly.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.16.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('structjh_1_1avl_1_1tree__map_1_1const__iterator.html','','structjh_1_1avl_1_1tree__map_1_1const__iterator-members'); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">jh::avl::tree_map&lt; K, V, Alloc &gt;::const_iterator Struct Reference<span class="mlabels"><span class="mlabel final">final</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>Const bidirectional iterator for in-order traversal.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="">jh/core/ordered_map.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-types" class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:acd3c97ee5c7e6c7ab0d87ef6a82e74a6" id="r_acd3c97ee5c7e6c7ab0d87ef6a82e74a6"><td class="memItemLeft"><a id="acd3c97ee5c7e6c7ab0d87ef6a82e74a6" name="acd3c97ee5c7e6c7ab0d87ef6a82e74a6"></a>
using&#160;</td><td class="memItemRight"><b>base_type</b> = <a class="el" href="classjh_1_1avl_1_1tree__map.html#a6c85f80ca9075223b0812883d6032f24">tree_map</a></td></tr>
<tr class="memdesc:acd3c97ee5c7e6c7ab0d87ef6a82e74a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Owning tree type. <br /></td></tr>
<tr class="memitem:afe4126bfc4e897863fb08730aa1a794d" id="r_afe4126bfc4e897863fb08730aa1a794d"><td class="memItemLeft"><a id="afe4126bfc4e897863fb08730aa1a794d" name="afe4126bfc4e897863fb08730aa1a794d"></a>
using&#160;</td><td class="memItemRight"><b>node_type</b> = detail::node_t&lt;K, V&gt;</td></tr>
<tr class="memdesc:afe4126bfc4e897863fb08730aa1a794d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Canonical node type used internally. <br /></td></tr>
<tr class="memitem:a853d5407dd6f184b4916e462454222b2" id="r_a853d5407dd6f184b4916e462454222b2"><td class="memItemLeft"><a id="a853d5407dd6f184b4916e462454222b2" name="a853d5407dd6f184b4916e462454222b2"></a>
using&#160;</td><td class="memItemRight"><b>stored_type</b> = detail::base_t&lt;K, V&gt;</td></tr>
<tr class="memdesc:a853d5407dd6f184b4916e462454222b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stored value type (key for set, pair&lt;const K,V&gt; for map). <br /></td></tr>
<tr class="memitem:a8ef08366f04172e7e195ddf897628572" id="r_a8ef08366f04172e7e195ddf897628572"><td class="memItemLeft"><a id="a8ef08366f04172e7e195ddf897628572" name="a8ef08366f04172e7e195ddf897628572"></a>
using&#160;</td><td class="memItemRight"><b>iterator_concept</b> = std::bidirectional_iterator_tag</td></tr>
<tr class="memdesc:a8ef08366f04172e7e195ddf897628572"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator concept tag (bidirectional). <br /></td></tr>
<tr class="memitem:a972cf64003c1827ea4aaab43e534a644" id="r_a972cf64003c1827ea4aaab43e534a644"><td class="memItemLeft"><a id="a972cf64003c1827ea4aaab43e534a644" name="a972cf64003c1827ea4aaab43e534a644"></a>
using&#160;</td><td class="memItemRight"><b>value_type</b> = <a class="el" href="#a853d5407dd6f184b4916e462454222b2">stored_type</a></td></tr>
<tr class="memdesc:a972cf64003c1827ea4aaab43e534a644"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value type produced when dereferenced. <br /></td></tr>
<tr class="memitem:ab8d843c5d375f1f888a6e650864e2401" id="r_ab8d843c5d375f1f888a6e650864e2401"><td class="memItemLeft"><a id="ab8d843c5d375f1f888a6e650864e2401" name="ab8d843c5d375f1f888a6e650864e2401"></a>
using&#160;</td><td class="memItemRight"><b>reference</b> = const <a class="el" href="#a853d5407dd6f184b4916e462454222b2">stored_type</a> &amp;</td></tr>
<tr class="memdesc:ab8d843c5d375f1f888a6e650864e2401"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference type for dereferencing. <br /></td></tr>
<tr class="memitem:ada1446f9418ba8c87e153ab75fdd6b08" id="r_ada1446f9418ba8c87e153ab75fdd6b08"><td class="memItemLeft"><a id="ada1446f9418ba8c87e153ab75fdd6b08" name="ada1446f9418ba8c87e153ab75fdd6b08"></a>
using&#160;</td><td class="memItemRight"><b>pointer</b> = const <a class="el" href="#a853d5407dd6f184b4916e462454222b2">stored_type</a> *</td></tr>
<tr class="memdesc:ada1446f9418ba8c87e153ab75fdd6b08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer type for dereferencing. <br /></td></tr>
<tr class="memitem:a0a3612bf4d0faf74269ebe2dd8356a1a" id="r_a0a3612bf4d0faf74269ebe2dd8356a1a"><td class="memItemLeft"><a id="a0a3612bf4d0faf74269ebe2dd8356a1a" name="a0a3612bf4d0faf74269ebe2dd8356a1a"></a>
using&#160;</td><td class="memItemRight"><b>difference_type</b> = std::int64_t</td></tr>
<tr class="memdesc:a0a3612bf4d0faf74269ebe2dd8356a1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Difference type used for iterator arithmetic. <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9bcdba4028374be6205983460106f8bd" id="r_a9bcdba4028374be6205983460106f8bd"><td class="memItemLeft">&#160;</td><td class="memItemRight"><a class="el" href="#a9bcdba4028374be6205983460106f8bd">const_iterator</a> ()=default</td></tr>
<tr class="memdesc:a9bcdba4028374be6205983460106f8bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a singular iterator.  <br /></td></tr>
<tr class="memitem:a80333b95a44debb2e328ba1ed878f055" id="r_a80333b95a44debb2e328ba1ed878f055"><td class="memItemLeft">&#160;</td><td class="memItemRight"><a class="el" href="#a80333b95a44debb2e328ba1ed878f055">const_iterator</a> (const <a class="el" href="#acd3c97ee5c7e6c7ab0d87ef6a82e74a6">base_type</a> *t, std::size_t i)</td></tr>
<tr class="memdesc:a80333b95a44debb2e328ba1ed878f055"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an iterator referring to the given node index.  <br /></td></tr>
<tr class="memitem:ab28cde32e283600e2ff3ef6cef9c4181" id="r_ab28cde32e283600e2ff3ef6cef9c4181"><td class="memItemLeft">&#160;</td><td class="memItemRight"><a class="el" href="#ab28cde32e283600e2ff3ef6cef9c4181">const_iterator</a> (const <a class="el" href="structjh_1_1avl_1_1tree__map_1_1iterator.html">iterator</a> &amp;it)</td></tr>
<tr class="memdesc:ab28cde32e283600e2ff3ef6cef9c4181"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="structjh_1_1avl_1_1tree__map_1_1const__iterator.html" title="Const bidirectional iterator for in-order traversal.">const_iterator</a> from a non-const iterator.  <br /></td></tr>
<tr class="memitem:a751d795b312fb82a2cd79f13ffe97e03" id="r_a751d795b312fb82a2cd79f13ffe97e03"><td class="memItemLeft"><a class="el" href="#ab8d843c5d375f1f888a6e650864e2401">reference</a>&#160;</td><td class="memItemRight"><a class="el" href="#a751d795b312fb82a2cd79f13ffe97e03">operator*</a> () const</td></tr>
<tr class="memdesc:a751d795b312fb82a2cd79f13ffe97e03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dereference the iterator.  <br /></td></tr>
<tr class="memitem:a6e3ea012663ce7b1a90aafaa2fc16543" id="r_a6e3ea012663ce7b1a90aafaa2fc16543"><td class="memItemLeft"><a class="el" href="#ada1446f9418ba8c87e153ab75fdd6b08">pointer</a>&#160;</td><td class="memItemRight"><a class="el" href="#a6e3ea012663ce7b1a90aafaa2fc16543">operator-&gt;</a> () const</td></tr>
<tr class="memdesc:a6e3ea012663ce7b1a90aafaa2fc16543"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the referenced element via pointer.  <br /></td></tr>
<tr class="memitem:a74cdb82d948815f3da73322cbbeee827" id="r_a74cdb82d948815f3da73322cbbeee827"><td class="memItemLeft">const <a class="el" href="structjh_1_1avl_1_1avl__node.html#aa0264e8debb087c2f5f3a000960b32f9">node_type::key_type</a> &amp;&#160;</td><td class="memItemRight"><a class="el" href="#a74cdb82d948815f3da73322cbbeee827">key</a> () const</td></tr>
<tr class="memdesc:a74cdb82d948815f3da73322cbbeee827"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the key of the referenced element.  <br /></td></tr>
<tr class="memitem:a359601a2b6fab01e7a935473b36a1e38" id="r_a359601a2b6fab01e7a935473b36a1e38"><td class="memItemLeft"><a class="el" href="#a9bcdba4028374be6205983460106f8bd">const_iterator</a> &amp;&#160;</td><td class="memItemRight"><a class="el" href="#a359601a2b6fab01e7a935473b36a1e38">operator++</a> ()</td></tr>
<tr class="memdesc:a359601a2b6fab01e7a935473b36a1e38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advance to the in-order successor.  <br /></td></tr>
<tr class="memitem:a29bd638ea98761e83e6a2af63b9a67a8" id="r_a29bd638ea98761e83e6a2af63b9a67a8"><td class="memItemLeft"><a class="el" href="#a9bcdba4028374be6205983460106f8bd">const_iterator</a>&#160;</td><td class="memItemRight"><a class="el" href="#a29bd638ea98761e83e6a2af63b9a67a8">operator++</a> (int)</td></tr>
<tr class="memdesc:a29bd638ea98761e83e6a2af63b9a67a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Post-increment.  <br /></td></tr>
<tr class="memitem:aefb695cd8c964f90ea84b8a7dc51291f" id="r_aefb695cd8c964f90ea84b8a7dc51291f"><td class="memItemLeft"><a class="el" href="#a9bcdba4028374be6205983460106f8bd">const_iterator</a> &amp;&#160;</td><td class="memItemRight"><a class="el" href="#aefb695cd8c964f90ea84b8a7dc51291f">operator--</a> ()</td></tr>
<tr class="memdesc:aefb695cd8c964f90ea84b8a7dc51291f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move to the in-order predecessor.  <br /></td></tr>
<tr class="memitem:a5cc16650fe9d5058f90f6edc6c903397" id="r_a5cc16650fe9d5058f90f6edc6c903397"><td class="memItemLeft"><a class="el" href="#a9bcdba4028374be6205983460106f8bd">const_iterator</a>&#160;</td><td class="memItemRight"><a class="el" href="#a5cc16650fe9d5058f90f6edc6c903397">operator--</a> (int)</td></tr>
<tr class="memdesc:a5cc16650fe9d5058f90f6edc6c903397"><td class="mdescLeft">&#160;</td><td class="mdescRight">Post-decrement.  <br /></td></tr>
<tr class="memitem:a91e24b38e9717f9db4bd7f2983bd2e49" id="r_a91e24b38e9717f9db4bd7f2983bd2e49"><td class="memItemLeft">bool&#160;</td><td class="memItemRight"><a class="el" href="#a91e24b38e9717f9db4bd7f2983bd2e49">operator==</a> (const <a class="el" href="#a9bcdba4028374be6205983460106f8bd">const_iterator</a> &amp;other) const</td></tr>
<tr class="memdesc:a91e24b38e9717f9db4bd7f2983bd2e49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two const_iterators for equality.  <br /></td></tr>
<tr class="memitem:a3382bd3bfd77c4b4154204698899daaa" id="r_a3382bd3bfd77c4b4154204698899daaa"><td class="memItemLeft">bool&#160;</td><td class="memItemRight"><a class="el" href="#a3382bd3bfd77c4b4154204698899daaa">operator!=</a> (const <a class="el" href="#a9bcdba4028374be6205983460106f8bd">const_iterator</a> &amp;other) const</td></tr>
<tr class="memdesc:a3382bd3bfd77c4b4154204698899daaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two const_iterators for inequality.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-attribs" class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ab80f0157e66e028df155f3c8f418d20d" id="r_ab80f0157e66e028df155f3c8f418d20d"><td class="memItemLeft"><a id="ab80f0157e66e028df155f3c8f418d20d" name="ab80f0157e66e028df155f3c8f418d20d"></a>
const <a class="el" href="#acd3c97ee5c7e6c7ab0d87ef6a82e74a6">base_type</a> *&#160;</td><td class="memItemRight"><b>tree</b> = nullptr</td></tr>
<tr class="memdesc:ab80f0157e66e028df155f3c8f418d20d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Associated tree instance; <code>nullptr</code> indicates a singular iterator. <br /></td></tr>
<tr class="memitem:adf3a1d2fe539def5661eb77c9c6c7cc7" id="r_adf3a1d2fe539def5661eb77c9c6c7cc7"><td class="memItemLeft"><a id="adf3a1d2fe539def5661eb77c9c6c7cc7" name="adf3a1d2fe539def5661eb77c9c6c7cc7"></a>
std::size_t&#160;</td><td class="memItemRight"><b>idx</b> = static_cast&lt;std::size_t&gt;(-1)</td></tr>
<tr class="memdesc:adf3a1d2fe539def5661eb77c9c6c7cc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index of the referenced node, or <code>-1</code> for <code><a class="el" href="classjh_1_1avl_1_1tree__map.html#a8a853f97d468ebc517ae421526a31b42" title="Return the past-the-end iterator.">end()</a></code>. <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename K, typename V, typename Alloc = std::allocator&lt;detail::value_t&lt;K, V&gt;&gt;&gt;<br />
struct jh::avl::tree_map&lt; K, V, Alloc &gt;::const_iterator</div><p>Const bidirectional iterator for in-order traversal. </p>
<p>Unlike <code>iterator</code>, this type provides a strictly read-only view of the underlying elements. All dereference operations yield <code>const</code> access, and mutation through the iterator is not permitted. This mirrors the behavior of standard associative-container <code><a class="el" href="structjh_1_1avl_1_1tree__map_1_1const__iterator.html" title="Const bidirectional iterator for in-order traversal.">const_iterator</a></code>.</p>
<p>Conversion from <code>iterator</code> to <code><a class="el" href="structjh_1_1avl_1_1tree__map_1_1const__iterator.html" title="Const bidirectional iterator for in-order traversal.">const_iterator</a></code> is supported, but not the reverse. Aside from const-qualification, traversal semantics (increment, decrement, ordering) match those of <code>iterator</code>. </p>
</div><a name="doc-constructors" id="doc-constructors"></a><h2 id="header-doc-constructors" class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a9bcdba4028374be6205983460106f8bd" name="a9bcdba4028374be6205983460106f8bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bcdba4028374be6205983460106f8bd">&#9670;&#160;</a></span>const_iterator() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename Alloc = std::allocator&lt;detail::value_t&lt;K, V&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classjh_1_1avl_1_1tree__map.html">jh::avl::tree_map</a>&lt; K, V, Alloc &gt;::const_iterator::const_iterator </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel default">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a singular iterator. </p>
<p>A default-constructed <a class="el" href="structjh_1_1avl_1_1tree__map_1_1const__iterator.html" title="Const bidirectional iterator for in-order traversal.">const_iterator</a> does not refer to any tree and is therefore singular. It must not be incremented, decremented, or dereferenced. Only assignment or destruction is permitted.</p>
<p>This state is distinct from <code><a class="el" href="classjh_1_1avl_1_1tree__map.html#a8a853f97d468ebc517ae421526a31b42" title="Return the past-the-end iterator.">end()</a></code>: an end iterator is bound to a specific container and supports valid bidirectional traversal (e.g., <code>&ndash;<a class="el" href="classjh_1_1avl_1_1tree__map.html#a8a853f97d468ebc517ae421526a31b42" title="Return the past-the-end iterator.">end()</a></code>), while a singular iterator does not. </p>

</div>
</div>
<a id="a80333b95a44debb2e328ba1ed878f055" name="a80333b95a44debb2e328ba1ed878f055"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80333b95a44debb2e328ba1ed878f055">&#9670;&#160;</a></span>const_iterator() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename Alloc = std::allocator&lt;detail::value_t&lt;K, V&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classjh_1_1avl_1_1tree__map.html">jh::avl::tree_map</a>&lt; K, V, Alloc &gt;::const_iterator::const_iterator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#acd3c97ee5c7e6c7ab0d87ef6a82e74a6">base_type</a> *</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>i</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an iterator referring to the given node index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Pointer to the owning tree. </td></tr>
    <tr><td class="paramname">i</td><td>Node index, or <code>-1</code> to represent <code><a class="el" href="classjh_1_1avl_1_1tree__map.html#a8a853f97d468ebc517ae421526a31b42" title="Return the past-the-end iterator.">end()</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<p>This constructor is typically used internally to form begin/end iterators. Users generally obtain iterators through member functions. </p>

</div>
</div>
<a id="ab28cde32e283600e2ff3ef6cef9c4181" name="ab28cde32e283600e2ff3ef6cef9c4181"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab28cde32e283600e2ff3ef6cef9c4181">&#9670;&#160;</a></span>const_iterator() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename Alloc = std::allocator&lt;detail::value_t&lt;K, V&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classjh_1_1avl_1_1tree__map.html">jh::avl::tree_map</a>&lt; K, V, Alloc &gt;::const_iterator::const_iterator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structjh_1_1avl_1_1tree__map_1_1iterator.html">iterator</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>it</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel explicit">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a <a class="el" href="structjh_1_1avl_1_1tree__map_1_1const__iterator.html" title="Const bidirectional iterator for in-order traversal.">const_iterator</a> from a non-const iterator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>The iterator to convert.</td></tr>
  </table>
  </dd>
</dl>
<p>Enables implicit promotion from iterator to <a class="el" href="structjh_1_1avl_1_1tree__map_1_1const__iterator.html" title="Const bidirectional iterator for in-order traversal.">const_iterator</a>, matching standard iterator behavior for associative containers. </p>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="a74cdb82d948815f3da73322cbbeee827" name="a74cdb82d948815f3da73322cbbeee827"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74cdb82d948815f3da73322cbbeee827">&#9670;&#160;</a></span>key()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename Alloc = std::allocator&lt;detail::value_t&lt;K, V&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structjh_1_1avl_1_1avl__node.html#aa0264e8debb087c2f5f3a000960b32f9">node_type::key_type</a> &amp; <a class="el" href="classjh_1_1avl_1_1tree__map.html">jh::avl::tree_map</a>&lt; K, V, Alloc &gt;::const_iterator::key </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain the key of the referenced element. </p>
<dl class="section return"><dt>Returns</dt><dd>Constant reference to the key.</dd></dl>
<p>Undefined behavior if the iterator is singular or equals <code><a class="el" href="classjh_1_1avl_1_1tree__map.html#a8a853f97d468ebc517ae421526a31b42" title="Return the past-the-end iterator.">end()</a></code>. </p>

</div>
</div>
<a id="a3382bd3bfd77c4b4154204698899daaa" name="a3382bd3bfd77c4b4154204698899daaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3382bd3bfd77c4b4154204698899daaa">&#9670;&#160;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename Alloc = std::allocator&lt;detail::value_t&lt;K, V&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classjh_1_1avl_1_1tree__map.html">jh::avl::tree_map</a>&lt; K, V, Alloc &gt;::const_iterator::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a9bcdba4028374be6205983460106f8bd">const_iterator</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare two const_iterators for inequality. </p>
<p>Equivalent to <code>!(a == b)</code>.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the iterators are not equal. </dd></dl>

</div>
</div>
<a id="a751d795b312fb82a2cd79f13ffe97e03" name="a751d795b312fb82a2cd79f13ffe97e03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a751d795b312fb82a2cd79f13ffe97e03">&#9670;&#160;</a></span>operator*()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename Alloc = std::allocator&lt;detail::value_t&lt;K, V&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ab8d843c5d375f1f888a6e650864e2401">reference</a> <a class="el" href="classjh_1_1avl_1_1tree__map.html">jh::avl::tree_map</a>&lt; K, V, Alloc &gt;::const_iterator::operator* </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dereference the iterator. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the element.</dd></dl>
<p>Undefined behavior if the iterator is singular or equals <code><a class="el" href="classjh_1_1avl_1_1tree__map.html#a8a853f97d468ebc517ae421526a31b42" title="Return the past-the-end iterator.">end()</a></code>. </p>

</div>
</div>
<a id="a359601a2b6fab01e7a935473b36a1e38" name="a359601a2b6fab01e7a935473b36a1e38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a359601a2b6fab01e7a935473b36a1e38">&#9670;&#160;</a></span>operator++() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename Alloc = std::allocator&lt;detail::value_t&lt;K, V&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a9bcdba4028374be6205983460106f8bd">const_iterator</a> &amp; <a class="el" href="classjh_1_1avl_1_1tree__map.html">jh::avl::tree_map</a>&lt; K, V, Alloc &gt;::const_iterator::operator++ </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Advance to the in-order successor. </p>
<p>Bidirectional-iterator semantics apply:</p>
<ul>
<li>
If the iterator is <code><a class="el" href="classjh_1_1avl_1_1tree__map.html#a8a853f97d468ebc517ae421526a31b42" title="Return the past-the-end iterator.">end()</a></code>, incrementing leaves it unchanged.  </li>
<li>
Otherwise moves to the next element in sorted order.  </li>
<li>
Undefined behavior if the iterator is singular.  </li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>Reference to <code>*this</code>. </dd></dl>

</div>
</div>
<a id="a29bd638ea98761e83e6a2af63b9a67a8" name="a29bd638ea98761e83e6a2af63b9a67a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29bd638ea98761e83e6a2af63b9a67a8">&#9670;&#160;</a></span>operator++() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename Alloc = std::allocator&lt;detail::value_t&lt;K, V&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a9bcdba4028374be6205983460106f8bd">const_iterator</a> <a class="el" href="classjh_1_1avl_1_1tree__map.html">jh::avl::tree_map</a>&lt; K, V, Alloc &gt;::const_iterator::operator++ </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Post-increment. </p>
<p>Returns the prior iterator value, then advances using <code><a class="el" href="#a359601a2b6fab01e7a935473b36a1e38" title="Advance to the in-order successor.">operator++()</a></code>.</p>
<dl class="section return"><dt>Returns</dt><dd>Copy of the iterator before incrementing. </dd></dl>

</div>
</div>
<a id="aefb695cd8c964f90ea84b8a7dc51291f" name="aefb695cd8c964f90ea84b8a7dc51291f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefb695cd8c964f90ea84b8a7dc51291f">&#9670;&#160;</a></span>operator--() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename Alloc = std::allocator&lt;detail::value_t&lt;K, V&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a9bcdba4028374be6205983460106f8bd">const_iterator</a> &amp; <a class="el" href="classjh_1_1avl_1_1tree__map.html">jh::avl::tree_map</a>&lt; K, V, Alloc &gt;::const_iterator::operator-- </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move to the in-order predecessor. </p>
<p>Bidirectional-iterator semantics apply:</p>
<ul>
<li>
If the iterator is <code><a class="el" href="classjh_1_1avl_1_1tree__map.html#a8a853f97d468ebc517ae421526a31b42" title="Return the past-the-end iterator.">end()</a></code>, decrementing moves it to the last element, or leaves it unchanged if the container is empty.  </li>
<li>
If the iterator refers to <code><a class="el" href="classjh_1_1avl_1_1tree__map.html#a5b8d6f0d9e6bd7c196e825cba002b646" title="Return an iterator to the smallest element.">begin()</a></code>, decrementing moves it to <code><a class="el" href="classjh_1_1avl_1_1tree__map.html#a8a853f97d468ebc517ae421526a31b42" title="Return the past-the-end iterator.">end()</a></code>.  </li>
<li>
Otherwise moves to the previous element in sorted order.  </li>
<li>
Undefined behavior if the iterator is singular.  </li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>Reference to <code>*this</code>. </dd></dl>

</div>
</div>
<a id="a5cc16650fe9d5058f90f6edc6c903397" name="a5cc16650fe9d5058f90f6edc6c903397"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cc16650fe9d5058f90f6edc6c903397">&#9670;&#160;</a></span>operator--() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename Alloc = std::allocator&lt;detail::value_t&lt;K, V&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a9bcdba4028374be6205983460106f8bd">const_iterator</a> <a class="el" href="classjh_1_1avl_1_1tree__map.html">jh::avl::tree_map</a>&lt; K, V, Alloc &gt;::const_iterator::operator-- </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Post-decrement. </p>
<p>Returns the prior iterator value, then decrements using <code><a class="el" href="#aefb695cd8c964f90ea84b8a7dc51291f" title="Move to the in-order predecessor.">operator--()</a></code>.</p>
<dl class="section return"><dt>Returns</dt><dd>Copy of the iterator before decrementing. </dd></dl>

</div>
</div>
<a id="a6e3ea012663ce7b1a90aafaa2fc16543" name="a6e3ea012663ce7b1a90aafaa2fc16543"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e3ea012663ce7b1a90aafaa2fc16543">&#9670;&#160;</a></span>operator-&gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename Alloc = std::allocator&lt;detail::value_t&lt;K, V&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ada1446f9418ba8c87e153ab75fdd6b08">pointer</a> <a class="el" href="classjh_1_1avl_1_1tree__map.html">jh::avl::tree_map</a>&lt; K, V, Alloc &gt;::const_iterator::operator-&gt; </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access the referenced element via pointer. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the element.</dd></dl>
<p>Undefined behavior if the iterator is singular or equals <code><a class="el" href="classjh_1_1avl_1_1tree__map.html#a8a853f97d468ebc517ae421526a31b42" title="Return the past-the-end iterator.">end()</a></code>. </p>

</div>
</div>
<a id="a91e24b38e9717f9db4bd7f2983bd2e49" name="a91e24b38e9717f9db4bd7f2983bd2e49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91e24b38e9717f9db4bd7f2983bd2e49">&#9670;&#160;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename Alloc = std::allocator&lt;detail::value_t&lt;K, V&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classjh_1_1avl_1_1tree__map.html">jh::avl::tree_map</a>&lt; K, V, Alloc &gt;::const_iterator::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a9bcdba4028374be6205983460106f8bd">const_iterator</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare two const_iterators for equality. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The iterator to compare with.</td></tr>
  </table>
  </dd>
</dl>
<p>Two const_iterators are equal only if they refer to the same container and the same logical position. </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>include/jh/core/<a class="el" href="">ordered_map.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
</div> <!-- top -->
<hr class="footer"/>
<div class="footer">
    <img class="footer-logo" src="Ojing.svg" alt="Ojing"/>
    <div class="footer-text">
        JH-Toolkit v1.4.0 · Generated by Doxygen
    </div>
    <div class="footer-note">
        We primarily support embedded documentation views in IDEs (classic CLion).
        To ensure compatibility with embedded rendering, some example code in this
        documentation intentionally contains HTML entities.
        In certain cases, Doxygen does not unescape these entities correctly.
        This is a known limitation and currently has no workaround.
    </div>
</div>
</body>
</html>
