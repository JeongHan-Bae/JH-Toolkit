<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.16.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>JH-Toolkit: jh::sync::control_buf&lt; T, Alloc &gt; Class Template Reference</title>
<link rel="icon" href="Jindallae.svg" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="Oree.svg"/></td>
  <td id="projectalign">
   <div id="projectname">JH-Toolkit<span id="projectnumber">&#160;v1.4.0</span>
   </div>
   <div id="projectbrief">An engineering-oriented C++20 toolkit with duck-typed concepts, static design, async coroutines, and semantic containers — header-only, RTTI-free, and concurrency-friendly.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.16.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('classjh_1_1sync_1_1control__buf.html','','classjh_1_1sync_1_1control__buf-members'); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">jh::sync::control_buf&lt; T, Alloc &gt; Class Template Reference<span class="mlabels"><span class="mlabel final">final</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>Fixed-capacity, block-allocated container for control-only types (e.g., mutexes, atomics).  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="">jh/synchronous/control_buf.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-types" class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a4ce2c09feceb7b597b5f4407f7c9580a" id="r_a4ce2c09feceb7b597b5f4407f7c9580a"><td class="memItemLeft"><a id="a4ce2c09feceb7b597b5f4407f7c9580a" name="a4ce2c09feceb7b597b5f4407f7c9580a"></a>
using&#160;</td><td class="memItemRight"><b>allocator_type</b> = typename std::allocator_traits&lt;Alloc&gt;::template rebind_alloc&lt;T&gt;</td></tr>
<tr class="memdesc:a4ce2c09feceb7b597b5f4407f7c9580a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of allocator used for element construction. <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac70d230f810cea946b8bb49576b6ddf0" id="r_ac70d230f810cea946b8bb49576b6ddf0"><td class="memItemLeft">&#160;</td><td class="memItemRight"><a class="el" href="#ac70d230f810cea946b8bb49576b6ddf0">control_buf</a> ()=default</td></tr>
<tr class="memdesc:ac70d230f810cea946b8bb49576b6ddf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an empty control buffer.  <br /></td></tr>
<tr class="memitem:ad4ad12688e5a1404ea6ec5dcbb19e756" id="r_ad4ad12688e5a1404ea6ec5dcbb19e756"><td class="memItemLeft">&#160;</td><td class="memItemRight"><a class="el" href="#ad4ad12688e5a1404ea6ec5dcbb19e756">control_buf</a> (const Alloc &amp;alloc)</td></tr>
<tr class="memdesc:ad4ad12688e5a1404ea6ec5dcbb19e756"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an empty control buffer with a custom allocator.  <br /></td></tr>
<tr class="memitem:ad5be34dee304918c4edda5a7d19a910a" id="r_ad5be34dee304918c4edda5a7d19a910a"><td class="memItemLeft">&#160;</td><td class="memItemRight"><a class="el" href="#ad5be34dee304918c4edda5a7d19a910a">control_buf</a> (std::size_t n)</td></tr>
<tr class="memdesc:ad5be34dee304918c4edda5a7d19a910a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a control buffer with exactly <code>n</code> default-constructed elements.  <br /></td></tr>
<tr class="memitem:ad29ef51e24c450fbcd93ba2cf62d4ad6" id="r_ad29ef51e24c450fbcd93ba2cf62d4ad6"><td class="memItemLeft">&#160;</td><td class="memItemRight"><a class="el" href="#ad29ef51e24c450fbcd93ba2cf62d4ad6">control_buf</a> (std::size_t n, const Alloc &amp;alloc)</td></tr>
<tr class="memdesc:ad29ef51e24c450fbcd93ba2cf62d4ad6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a control buffer with <code>n</code> elements using a custom allocator.  <br /></td></tr>
<tr class="memitem:a8dd0b2d3f9ab0b830ec79e3db482d198" id="r_a8dd0b2d3f9ab0b830ec79e3db482d198"><td class="memItemLeft">&#160;</td><td class="memItemRight"><a class="el" href="#a8dd0b2d3f9ab0b830ec79e3db482d198">control_buf</a> (const control_buf &amp;other)</td></tr>
<tr class="memdesc:a8dd0b2d3f9ab0b830ec79e3db482d198"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy-constructs the buffer topology from another instance.  <br /></td></tr>
<tr class="memitem:a87b386c525c4e5b872d75d2eabdde91b" id="r_a87b386c525c4e5b872d75d2eabdde91b"><td class="memItemLeft"><a class="el" href="#ac70d230f810cea946b8bb49576b6ddf0">control_buf</a> &amp;&#160;</td><td class="memItemRight"><a class="el" href="#a87b386c525c4e5b872d75d2eabdde91b">operator=</a> (const <a class="el" href="#ac70d230f810cea946b8bb49576b6ddf0">control_buf</a> &amp;other)</td></tr>
<tr class="memdesc:a87b386c525c4e5b872d75d2eabdde91b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy-assigns the buffer topology from another instance.  <br /></td></tr>
<tr class="memitem:a7918ce1ed396fb9ea7bafc6a6dbcc7f2" id="r_a7918ce1ed396fb9ea7bafc6a6dbcc7f2"><td class="memItemLeft">&#160;</td><td class="memItemRight"><a class="el" href="#a7918ce1ed396fb9ea7bafc6a6dbcc7f2">control_buf</a> (control_buf &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:a7918ce1ed396fb9ea7bafc6a6dbcc7f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move-constructs a control buffer from another instance.  <br /></td></tr>
<tr class="memitem:ab8fe2ebf4843b558e4071bbbdeaae7bd" id="r_ab8fe2ebf4843b558e4071bbbdeaae7bd"><td class="memItemLeft"><a class="el" href="#ac70d230f810cea946b8bb49576b6ddf0">control_buf</a> &amp;&#160;</td><td class="memItemRight"><a class="el" href="#ab8fe2ebf4843b558e4071bbbdeaae7bd">operator=</a> (<a class="el" href="#ac70d230f810cea946b8bb49576b6ddf0">control_buf</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:ab8fe2ebf4843b558e4071bbbdeaae7bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move-assigns a control buffer from another buffer.  <br /></td></tr>
<tr class="memitem:a61b4964e2f2ad061b54002141c45bf35" id="r_a61b4964e2f2ad061b54002141c45bf35"><td class="memItemLeft">std::size_t&#160;</td><td class="memItemRight"><a class="el" href="#a61b4964e2f2ad061b54002141c45bf35">size</a> () const noexcept</td></tr>
<tr class="memdesc:a61b4964e2f2ad061b54002141c45bf35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current number of constructed elements.  <br /></td></tr>
<tr class="memitem:a6431a31d558c9e88bdc935b828d9448d" id="r_a6431a31d558c9e88bdc935b828d9448d"><td class="memItemLeft">std::size_t&#160;</td><td class="memItemRight"><a class="el" href="#a6431a31d558c9e88bdc935b828d9448d">capacity</a> () const noexcept</td></tr>
<tr class="memdesc:a6431a31d558c9e88bdc935b828d9448d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of elements that can be stored without further allocation.  <br /></td></tr>
<tr class="memitem:af7897780251e2ef6359464ef403e7efc" id="r_af7897780251e2ef6359464ef403e7efc"><td class="memItemLeft">T &amp;&#160;</td><td class="memItemRight"><a class="el" href="#af7897780251e2ef6359464ef403e7efc">emplace_back</a> ()</td></tr>
<tr class="memdesc:af7897780251e2ef6359464ef403e7efc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a default-constructed element to the end of the buffer.  <br /></td></tr>
<tr class="memitem:a7bb2510b515a08d71c1bbdbbd8112b72" id="r_a7bb2510b515a08d71c1bbdbbd8112b72"><td class="memItemLeft">T &amp;&#160;</td><td class="memItemRight"><a class="el" href="#a7bb2510b515a08d71c1bbdbbd8112b72">operator[]</a> (std::size_t i) noexcept</td></tr>
<tr class="memdesc:a7bb2510b515a08d71c1bbdbbd8112b72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides unchecked access to the element at index <code>i</code>.  <br /></td></tr>
<tr class="memitem:a0c6c4782a9dede3eaea638f053c19229" id="r_a0c6c4782a9dede3eaea638f053c19229"><td class="memItemLeft">const T &amp;&#160;</td><td class="memItemRight"><a class="el" href="#a0c6c4782a9dede3eaea638f053c19229">operator[]</a> (std::size_t i) const noexcept</td></tr>
<tr class="memdesc:a0c6c4782a9dede3eaea638f053c19229"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides unchecked, read-only access to the element at index <code>i</code>.  <br /></td></tr>
<tr class="memitem:aef505c10862604fe48a44b7384b6d004" id="r_aef505c10862604fe48a44b7384b6d004"><td class="memItemLeft">T &amp;&#160;</td><td class="memItemRight"><a class="el" href="#aef505c10862604fe48a44b7384b6d004">at</a> (std::size_t i)</td></tr>
<tr class="memdesc:aef505c10862604fe48a44b7384b6d004"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the element at index <code>i</code>, with bounds checking.  <br /></td></tr>
<tr class="memitem:a9559ed860e42ac0f74f6e438fc9727b0" id="r_a9559ed860e42ac0f74f6e438fc9727b0"><td class="memItemLeft">const T &amp;&#160;</td><td class="memItemRight"><a class="el" href="#a9559ed860e42ac0f74f6e438fc9727b0">at</a> (std::size_t i) const</td></tr>
<tr class="memdesc:a9559ed860e42ac0f74f6e438fc9727b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reference to the element at index <code>i</code>, with bounds checking.  <br /></td></tr>
<tr class="memitem:a5bb55a3d968b73c53ab02fdfc18afc19" id="r_a5bb55a3d968b73c53ab02fdfc18afc19"><td class="memItemLeft">void&#160;</td><td class="memItemRight"><a class="el" href="#a5bb55a3d968b73c53ab02fdfc18afc19">reserve</a> (std::size_t n) noexcept(noexcept(std::declval&lt; std::vector&lt; block_ptr &gt; &amp; &gt;().reserve(n)))</td></tr>
<tr class="memdesc:a5bb55a3d968b73c53ab02fdfc18afc19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserves space in the internal block index for at least <code>n</code> elements.  <br /></td></tr>
<tr class="memitem:a7bcb8f7de5413ce18ce960c5135f5841" id="r_a7bcb8f7de5413ce18ce960c5135f5841"><td class="memItemLeft">void&#160;</td><td class="memItemRight"><a class="el" href="#a7bcb8f7de5413ce18ce960c5135f5841">clear</a> () noexcept(noexcept(std::declval&lt; std::vector&lt; block_ptr &gt; &amp; &gt;().clear()))</td></tr>
<tr class="memdesc:a7bcb8f7de5413ce18ce960c5135f5841"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys all constructed elements and deallocates all blocks.  <br /></td></tr>
<tr class="memitem:a8114c6e3d1dc1f5d466530f2b3ebf0fc" id="r_a8114c6e3d1dc1f5d466530f2b3ebf0fc"><td class="memItemLeft">void&#160;</td><td class="memItemRight"><a class="el" href="#a8114c6e3d1dc1f5d466530f2b3ebf0fc">shrink_to_fit</a> () noexcept</td></tr>
<tr class="memdesc:a8114c6e3d1dc1f5d466530f2b3ebf0fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to reduce the capacity of the internal block index vector to fit its size.  <br /></td></tr>
<tr class="memitem:a6e9fbb4ea72c9c9b39d0315d82755e60" id="r_a6e9fbb4ea72c9c9b39d0315d82755e60"><td class="memItemLeft">void&#160;</td><td class="memItemRight"><a class="el" href="#a6e9fbb4ea72c9c9b39d0315d82755e60">resize</a> (std::size_t n)</td></tr>
<tr class="memdesc:a6e9fbb4ea72c9c9b39d0315d82755e60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes the container to contain exactly <code>n</code> elements.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-static-attribs" class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:ad7f3aab5d107d7748b7adb22f73fe353" id="r_ad7f3aab5d107d7748b7adb22f73fe353"><td class="memItemLeft"><a id="ad7f3aab5d107d7748b7adb22f73fe353" name="ad7f3aab5d107d7748b7adb22f73fe353"></a>
static constexpr std::size_t&#160;</td><td class="memItemRight"><b>BLOCK_SIZE</b> = JH_FIXED_VEC_BLOCK_SIZE</td></tr>
<tr class="memdesc:ad7f3aab5d107d7748b7adb22f73fe353"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of elements per allocation block. <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename T, typename Alloc = std::allocator&lt;T&gt;&gt;<br />
requires (std::is_default_constructible_v&lt;T&gt; &amp;&amp; !<a class="el" href="conceptjh_1_1concepts_1_1is__contiguous__reallocable.html">jh::concepts::is_contiguous_reallocable</a>&lt;T&gt;)<br />
class jh::sync::control_buf&lt; T, Alloc &gt;</div><p>Fixed-capacity, block-allocated container for control-only types (e.g., mutexes, atomics). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type to store (must be default-constructible and non-reallocable). </td></tr>
    <tr><td class="paramname">Alloc</td><td>Optional allocator type (defaults to <code>std::allocator&lt;T&gt;</code>).</td></tr>
  </table>
  </dd>
</dl>
<h4>Design Constraints</h4>
<ul>
<li>
<b>T must be default-constructible.</b> </li>
<li>
<b>T must NOT be copyable or movable.</b> </li>
<li>
<code><a class="el" href="classjh_1_1sync_1_1control__buf.html" title="Fixed-capacity, block-allocated container for control-only types (e.g., mutexes, atomics).">control_buf</a></code> is not intended for data storage or iteration. </li>
</ul>
</div><a name="doc-constructors" id="doc-constructors"></a><h2 id="header-doc-constructors" class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ac70d230f810cea946b8bb49576b6ddf0" name="ac70d230f810cea946b8bb49576b6ddf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac70d230f810cea946b8bb49576b6ddf0">&#9670;&#160;</a></span>control_buf() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classjh_1_1sync_1_1control__buf.html">jh::sync::control_buf</a>&lt; T, Alloc &gt;::control_buf </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel default">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an empty control buffer. </p>
<p>No memory is allocated and no elements are constructed. The container starts with zero size and zero blocks. </p>

</div>
</div>
<a id="ad4ad12688e5a1404ea6ec5dcbb19e756" name="ad4ad12688e5a1404ea6ec5dcbb19e756"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4ad12688e5a1404ea6ec5dcbb19e756">&#9670;&#160;</a></span>control_buf() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classjh_1_1sync_1_1control__buf.html">jh::sync::control_buf</a>&lt; T, Alloc &gt;::control_buf </td>
          <td>(</td>
          <td class="paramtype">const Alloc &amp;</td>          <td class="paramname"><span class="paramname"><em>alloc</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel explicit">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an empty control buffer with a custom allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alloc</td><td>Allocator instance used for all future block allocations.</td></tr>
  </table>
  </dd>
</dl>
<p>The allocator is stored internally and copied into each block deleter. No memory allocation occurs at construction time. </p>

</div>
</div>
<a id="ad5be34dee304918c4edda5a7d19a910a" name="ad5be34dee304918c4edda5a7d19a910a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5be34dee304918c4edda5a7d19a910a">&#9670;&#160;</a></span>control_buf() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classjh_1_1sync_1_1control__buf.html">jh::sync::control_buf</a>&lt; T, Alloc &gt;::control_buf </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel explicit">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a control buffer with exactly <code>n</code> default-constructed elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Number of elements to construct.</td></tr>
  </table>
  </dd>
</dl>
<p>Elements are constructed incrementally using the block-based growth strategy. Each element is default-constructed in-place and never relocated. </p>

</div>
</div>
<a id="ad29ef51e24c450fbcd93ba2cf62d4ad6" name="ad29ef51e24c450fbcd93ba2cf62d4ad6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad29ef51e24c450fbcd93ba2cf62d4ad6">&#9670;&#160;</a></span>control_buf() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classjh_1_1sync_1_1control__buf.html">jh::sync::control_buf</a>&lt; T, Alloc &gt;::control_buf </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Alloc &amp;</td>          <td class="paramname"><span class="paramname"><em>alloc</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a control buffer with <code>n</code> elements using a custom allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Number of elements to construct. </td></tr>
    <tr><td class="paramname">alloc</td><td>Allocator used for block allocation and element construction. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8dd0b2d3f9ab0b830ec79e3db482d198" name="a8dd0b2d3f9ab0b830ec79e3db482d198"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dd0b2d3f9ab0b830ec79e3db482d198">&#9670;&#160;</a></span>control_buf() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classjh_1_1sync_1_1control__buf.html">jh::sync::control_buf</a>&lt; T, Alloc &gt;::control_buf </td>
          <td>(</td>
          <td class="paramtype">const control_buf&lt; T, Alloc &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy-constructs the buffer topology from another instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Source buffer.</td></tr>
  </table>
  </dd>
</dl>
<p>This is a <b>topological copy</b>: </p><ul>
<li>
The resulting buffer has the same <code><a class="el" href="#a61b4964e2f2ad061b54002141c45bf35" title="Returns the current number of constructed elements.">size()</a></code> as <code class="param">other</code>. </li>
<li>
Elements are <b>default-constructed</b>, not copied. </li>
<li>
No element-wise copy or move is performed. </li>
</ul>
<p>This behavior is intentional and required for control-type objects whose state must not be duplicated. </p>

</div>
</div>
<a id="a7918ce1ed396fb9ea7bafc6a6dbcc7f2" name="a7918ce1ed396fb9ea7bafc6a6dbcc7f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7918ce1ed396fb9ea7bafc6a6dbcc7f2">&#9670;&#160;</a></span>control_buf() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classjh_1_1sync_1_1control__buf.html">jh::sync::control_buf</a>&lt; T, Alloc &gt;::control_buf </td>
          <td>(</td>
          <td class="paramtype">control_buf&lt; T, Alloc &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move-constructs a control buffer from another instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Source buffer to move from.</td></tr>
  </table>
  </dd>
</dl>
<p>Transfers ownership of all internal blocks and allocator state from <code class="param">other</code> to the newly constructed buffer. </p><ul>
<li>
No elements are copied, moved, or relocated. </li>
<li>
Only block ownership and allocator state are transferred. </li>
<li>
Block-level address stability is preserved. </li>
</ul>
<dl class="section note"><dt>Note</dt><dd>After the move, <code class="param">other</code> is left in a <b>valid but unspecified state</b>, consistent with standard C++ container move semantics. The moved-from object is safe to destroy. If reuse is required, the caller must explicitly call <code><a class="el" href="#a7bcb8f7de5413ce18ce960c5135f5841" title="Destroys all constructed elements and deallocates all blocks.">clear()</a></code>. </dd></dl>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="aef505c10862604fe48a44b7384b6d004" name="aef505c10862604fe48a44b7384b6d004"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef505c10862604fe48a44b7384b6d004">&#9670;&#160;</a></span>at() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="classjh_1_1sync_1_1control__buf.html">jh::sync::control_buf</a>&lt; T, Alloc &gt;::at </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the element at index <code>i</code>, with bounds checking. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Zero-based index of the element to access. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the element at index <code>i</code>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>If <code>i</code> is greater than or equal to <code><a class="el" href="#a61b4964e2f2ad061b54002141c45bf35" title="Returns the current number of constructed elements.">size()</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<p>This function performs runtime bounds checking before accessing the element. If the index is invalid, an exception is thrown. </p><ul>
<li>
Semantically equivalent to <code>std::vector::at()</code>. </li>
<li>
Access is internally delegated to <code>operator[]</code> after validation. </li>
<li>
Provides a safer alternative to unchecked access via <code>operator[]</code>. </li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Prefer this method over <code>operator[]</code> when index validity is uncertain. </dd></dl>

</div>
</div>
<a id="a9559ed860e42ac0f74f6e438fc9727b0" name="a9559ed860e42ac0f74f6e438fc9727b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9559ed860e42ac0f74f6e438fc9727b0">&#9670;&#160;</a></span>at() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T &amp; <a class="el" href="classjh_1_1sync_1_1control__buf.html">jh::sync::control_buf</a>&lt; T, Alloc &gt;::at </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const reference to the element at index <code>i</code>, with bounds checking. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Zero-based index of the element to access. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Const reference to the element at index <code>i</code>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>If <code>i</code> is greater than or equal to <code><a class="el" href="#a61b4964e2f2ad061b54002141c45bf35" title="Returns the current number of constructed elements.">size()</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<p>This overload provides read-only, bounds-checked access to an element. </p><ul>
<li>
Returns the same result as the non-const version but guarantees const access. </li>
<li>
Delegates to <code>operator[]</code> after index validation. </li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Use this method when accessing elements in a const context with safety guarantees. </dd></dl>

</div>
</div>
<a id="a6431a31d558c9e88bdc935b828d9448d" name="a6431a31d558c9e88bdc935b828d9448d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6431a31d558c9e88bdc935b828d9448d">&#9670;&#160;</a></span>capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classjh_1_1sync_1_1control__buf.html">jh::sync::control_buf</a>&lt; T, Alloc &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the total number of elements that can be stored without further allocation. </p>
<dl class="section return"><dt>Returns</dt><dd>The maximum number of elements that can be emplaced before triggering a new block allocation.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Capacity is managed in blocks of fixed size (<code>BLOCK_SIZE</code>) and is calculated as: <code>blocks.capacity() * BLOCK_SIZE</code>. </dd></dl>

</div>
</div>
<a id="a7bcb8f7de5413ce18ce960c5135f5841" name="a7bcb8f7de5413ce18ce960c5135f5841"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bcb8f7de5413ce18ce960c5135f5841">&#9670;&#160;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classjh_1_1sync_1_1control__buf.html">jh::sync::control_buf</a>&lt; T, Alloc &gt;::clear </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys all constructed elements and deallocates all blocks. </p>
<p>This function releases all memory held by the container and resets its size to zero. It also clears the internal block index vector. </p><ul>
<li>
All constructed elements are destroyed via allocator-aware destruction. </li>
<li>
All blocks are properly deallocated via their bound deleters. </li>
<li>
The internal block pointer vector is also cleared. </li>
</ul>
<dl class="section note"><dt>Note</dt><dd>After calling <code><a class="el" href="#a7bcb8f7de5413ce18ce960c5135f5841" title="Destroys all constructed elements and deallocates all blocks.">clear()</a></code>, the container is empty and has no allocated blocks. </dd></dl>

</div>
</div>
<a id="af7897780251e2ef6359464ef403e7efc" name="af7897780251e2ef6359464ef403e7efc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7897780251e2ef6359464ef403e7efc">&#9670;&#160;</a></span>emplace_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="classjh_1_1sync_1_1control__buf.html">jh::sync::control_buf</a>&lt; T, Alloc &gt;::emplace_back </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends a default-constructed element to the end of the buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the newly constructed element.</dd></dl>
<p>This method constructs a new element in-place at the logical end of the buffer. If the current block is full, a new block is allocated and all its elements are default-constructed. </p><ul>
<li>
Elements are constructed using <code>allocator_traits::construct</code>. </li>
<li>
New memory is allocated in chunks of <code>BLOCK_SIZE</code> elements. </li>
<li>
Each block is allocated only once and never reallocated or moved. </li>
<li>
Element addresses remain stable for the lifetime of the container. </li>
</ul>
<p>This function's interface is intentionally consistent with <code>std::vector&lt;T&gt;::emplace_back()</code> and <code>std::deque&lt;T&gt;::emplace_back()</code> (default-construction form), even though this container does not support in-place argument forwarding. </p><ul>
<li>
This design choice lowers the learning curve for users familiar with STL containers. </li>
<li>
It enables generic code to use <code><a class="el" href="#af7897780251e2ef6359464ef403e7efc" title="Appends a default-constructed element to the end of the buffer.">emplace_back()</a></code> in the same way across both control and data containers. </li>
<li>
It allows working with types like <code>std::mutex</code> and <code>std::atomic</code>, which cannot be stored in <code>std::vector</code> due to relocation or copying constraints, but still benefit from a consistent push-back interface. </li>
</ul>
<dl class="section note"><dt>Note</dt><dd>This function always performs default-construction only. Argument forwarding is not supported. </dd></dl>

</div>
</div>
<a id="a87b386c525c4e5b872d75d2eabdde91b" name="a87b386c525c4e5b872d75d2eabdde91b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87b386c525c4e5b872d75d2eabdde91b">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ac70d230f810cea946b8bb49576b6ddf0">control_buf</a> &amp; <a class="el" href="classjh_1_1sync_1_1control__buf.html">jh::sync::control_buf</a>&lt; T, Alloc &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#ac70d230f810cea946b8bb49576b6ddf0">control_buf</a>&lt; T, Alloc &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy-assigns the buffer topology from another instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Source buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to this buffer.</dd></dl>
<p>Equivalent to: </p><ol>
<li>
Destroying all existing blocks. </li>
<li>
Copying the allocator. </li>
<li>
Default-constructing <code>other.size()</code> elements. </li>
</ol>
<p>Element contents are never copied. </p>

</div>
</div>
<a id="ab8fe2ebf4843b558e4071bbbdeaae7bd" name="ab8fe2ebf4843b558e4071bbbdeaae7bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8fe2ebf4843b558e4071bbbdeaae7bd">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ac70d230f810cea946b8bb49576b6ddf0">control_buf</a> &amp; <a class="el" href="classjh_1_1sync_1_1control__buf.html">jh::sync::control_buf</a>&lt; T, Alloc &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ac70d230f810cea946b8bb49576b6ddf0">control_buf</a>&lt; T, Alloc &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move-assigns a control buffer from another buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The source buffer to move from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to this buffer after assignment.</dd></dl>
<p>Clears current contents and transfers ownership of all internal blocks and allocator state from <code class="param">other</code> to this buffer. </p><ul>
<li>
All previously allocated memory is destroyed before the move. </li>
<li>
Element memory is not copied; blocks are moved as raw pointers. </li>
<li>
The moved-from buffer is left in a valid but unspecified state. </li>
</ul>
<dl class="section note"><dt>Note</dt><dd>As with move construction, reusing the moved-from buffer requires an explicit call to <code><a class="el" href="#a7bcb8f7de5413ce18ce960c5135f5841" title="Destroys all constructed elements and deallocates all blocks.">clear()</a></code>. </dd></dl>

</div>
</div>
<a id="a0c6c4782a9dede3eaea638f053c19229" name="a0c6c4782a9dede3eaea638f053c19229"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c6c4782a9dede3eaea638f053c19229">&#9670;&#160;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T &amp; <a class="el" href="classjh_1_1sync_1_1control__buf.html">jh::sync::control_buf</a>&lt; T, Alloc &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides unchecked, read-only access to the element at index <code>i</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Zero-based index of the element to access. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Const reference to the element at the specified index.</dd></dl>
<p>This overload offers const access to the same element as the non-const version. </p><ul>
<li>
No bounds checking is performed. </li>
<li>
Safe to call as long as <code>i</code> is within <span class="tt">[0, <a class="el" href="#a61b4964e2f2ad061b54002141c45bf35" title="Returns the current number of constructed elements.">size()</a>)</span>. </li>
<li>
Useful in const contexts and read-only algorithms. </li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Use <code>at(i)</code> for bounds-checked access. </dd></dl>

</div>
</div>
<a id="a7bb2510b515a08d71c1bbdbbd8112b72" name="a7bb2510b515a08d71c1bbdbbd8112b72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bb2510b515a08d71c1bbdbbd8112b72">&#9670;&#160;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="classjh_1_1sync_1_1control__buf.html">jh::sync::control_buf</a>&lt; T, Alloc &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides unchecked access to the element at index <code>i</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Zero-based index of the element to access. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the element at the specified index.</dd></dl>
<p>This function does not perform bounds checking. It assumes the index is valid (i.e., less than <code><a class="el" href="#a61b4964e2f2ad061b54002141c45bf35" title="Returns the current number of constructed elements.">size()</a></code>). </p><ul>
<li>
Equivalent in usage to <code>std::vector::operator[]</code>. </li>
<li>
Allows direct indexed access for integration with generic code. </li>
<li>
Performs internal block lookup via division and modulus on <code>BLOCK_SIZE</code>. </li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Use <code>at(i)</code> if you need bounds checking. </dd></dl>

</div>
</div>
<a id="a5bb55a3d968b73c53ab02fdfc18afc19" name="a5bb55a3d968b73c53ab02fdfc18afc19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bb55a3d968b73c53ab02fdfc18afc19">&#9670;&#160;</a></span>reserve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classjh_1_1sync_1_1control__buf.html">jh::sync::control_buf</a>&lt; T, Alloc &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reserves space in the internal block index for at least <code>n</code> elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Desired minimum number of elements the buffer should be able to hold without reallocation.</td></tr>
  </table>
  </dd>
</dl>
<p>This function performs a preallocation on the internal <code>std::vector&lt;block_ptr&gt;</code> that manages block pointers. It does not preallocate the actual element blocks themselves. </p><ul>
<li>
Internally reserves <code>ceil(n / BLOCK_SIZE)</code> block pointer slots. </li>
<li>
Does not allocate or construct any elements or blocks. </li>
<li>
Useful mostly for reducing index vector reallocations during bulk appends. </li>
<li>
Cannot avoid per-block allocation due to the semantics of <code><a class="el" href="classjh_1_1sync_1_1control__buf.html" title="Fixed-capacity, block-allocated container for control-only types (e.g., mutexes, atomics).">control_buf</a></code>. </li>
</ul>
<dl class="section note"><dt>Note</dt><dd>The usefulness of <code><a class="el" href="#a5bb55a3d968b73c53ab02fdfc18afc19" title="Reserves space in the internal block index for at least n elements.">reserve()</a></code> is limited because control-type elements (e.g. mutexes) cannot be preconstructed or relocated. This function primarily exists for interface consistency and intent declaration. </dd></dl>

</div>
</div>
<a id="a6e9fbb4ea72c9c9b39d0315d82755e60" name="a6e9fbb4ea72c9c9b39d0315d82755e60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e9fbb4ea72c9c9b39d0315d82755e60">&#9670;&#160;</a></span>resize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classjh_1_1sync_1_1control__buf.html">jh::sync::control_buf</a>&lt; T, Alloc &gt;::resize </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resizes the container to contain exactly <code>n</code> elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The desired number of elements after resizing.</td></tr>
  </table>
  </dd>
</dl>
<p>This function adjusts the logical size of the container to <code>n</code>. </p><ul>
<li>
If <code>n &gt; <a class="el" href="#a61b4964e2f2ad061b54002141c45bf35" title="Returns the current number of constructed elements.">size()</a></code>, new elements are added via <code><a class="el" href="#af7897780251e2ef6359464ef403e7efc" title="Appends a default-constructed element to the end of the buffer.">emplace_back()</a></code>, which default-constructs new elements in-place. </li>
<li>
If <code>n &lt; <a class="el" href="#a61b4964e2f2ad061b54002141c45bf35" title="Returns the current number of constructed elements.">size()</a></code>, blocks beyond the necessary range are destroyed and released. </li>
<li>
If the new size does not align exactly to <code>BLOCK_SIZE</code>, the tail block may contain partially used space that remains physically allocated but is treated as logically unused. </li>
</ul>
<p>These remaining elements are not destroyed and retain their previous state. They are considered <em>logically uninitialized</em>, and the next call to <code><a class="el" href="#af7897780251e2ef6359464ef403e7efc" title="Appends a default-constructed element to the end of the buffer.">emplace_back()</a></code> will continue from where <code><a class="el" href="#a6e9fbb4ea72c9c9b39d0315d82755e60" title="Resizes the container to contain exactly n elements.">resize()</a></code> left off — it does not reinitialize the tail.</p>
<dl class="section note"><dt>Note</dt><dd>This behavior is safe and expected for most control types (e.g., <code>std::atomic</code>), where default-construction does not guarantee value initialization. However, if you rely on a default-constructed value having a known state (e.g., user-defined types), you must ensure to explicitly reset such objects after <code><a class="el" href="#a6e9fbb4ea72c9c9b39d0315d82755e60" title="Resizes the container to contain exactly n elements.">resize()</a></code>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Do not assume that elements beyond the new logical size are reset or zeroed. Treat them as undefined and reinitialize as needed. </dd></dl>

</div>
</div>
<a id="a8114c6e3d1dc1f5d466530f2b3ebf0fc" name="a8114c6e3d1dc1f5d466530f2b3ebf0fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8114c6e3d1dc1f5d466530f2b3ebf0fc">&#9670;&#160;</a></span>shrink_to_fit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classjh_1_1sync_1_1control__buf.html">jh::sync::control_buf</a>&lt; T, Alloc &gt;::shrink_to_fit </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to reduce the capacity of the internal block index vector to fit its size. </p>
<p>This function operates only on the internal <code>std::vector&lt;block_ptr&gt;</code> that stores pointers to element blocks. It does not modify or deallocate any element storage. </p><ul>
<li>
Does not affect the actual element blocks or constructed elements. </li>
<li>
Has no observable effect on memory usage unless the vector itself has excess capacity. </li>
<li>
Provided for interface symmetry with standard containers like <code>std::vector</code>. </li>
</ul>
<dl class="section note"><dt>Note</dt><dd>This function behaves similarly to <code>std::vector::shrink_to_fit()</code>, which in C++20 and beyond also has no mandated effect. </dd></dl>

</div>
</div>
<a id="a61b4964e2f2ad061b54002141c45bf35" name="a61b4964e2f2ad061b54002141c45bf35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61b4964e2f2ad061b54002141c45bf35">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = std::allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classjh_1_1sync_1_1control__buf.html">jh::sync::control_buf</a>&lt; T, Alloc &gt;::size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current number of constructed elements. </p>
<dl class="section return"><dt>Returns</dt><dd>Number of elements currently held in the buffer.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This reflects the logical size (i.e., how many elements were constructed via emplace or resize), not the total memory capacity. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/jh/synchronous/<a class="el" href="">control_buf.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
</div> <!-- top -->
<hr class="footer"/>
<div class="footer">
    <img class="footer-logo" src="Ojing.svg" alt="Ojing"/>
    <div class="footer-text">
        JH-Toolkit v1.4.0 · Generated by Doxygen
    </div>
    <div class="footer-note">
        We primarily support embedded documentation views in IDEs (classic CLion).
        To ensure compatibility with embedded rendering, some example code in this
        documentation intentionally contains HTML entities.
        In certain cases, Doxygen does not unescape these entities correctly.
        This is a known limitation and currently has no workaround.
    </div>
</div>
</body>
</html>
