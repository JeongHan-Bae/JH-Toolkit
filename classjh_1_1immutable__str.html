<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.16.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>JH-Toolkit: jh::immutable_str Class Reference</title>
<link rel="icon" href="Jindallae.svg" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="Oree.svg"/></td>
  <td id="projectalign">
   <div id="projectname">JH-Toolkit<span id="projectnumber">&#160;v1.4.0</span>
   </div>
   <div id="projectbrief">An engineering-oriented C++20 toolkit with duck-typed concepts, static design, async coroutines, and semantic containers — header-only, RTTI-free, and concurrency-friendly.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.16.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('classjh_1_1immutable__str.html','','classjh_1_1immutable__str-members'); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">jh::immutable_str Class Reference<span class="mlabels"><span class="mlabel final">final</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>Immutable string with optional automatic trimming and thread-safe hash caching.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="">jh/core/immutable_str.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a16351db0072bdf1f4957da8b27562de6" id="r_a16351db0072bdf1f4957da8b27562de6"><td class="memItemLeft">&#160;</td><td class="memItemRight"><a class="el" href="#a16351db0072bdf1f4957da8b27562de6">immutable_str</a> (const char *<a class="el" href="#a4bbdefbdc91ec2378c3c61bb892036ab">str</a>)</td></tr>
<tr class="memdesc:a16351db0072bdf1f4957da8b27562de6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an immutable string from a C-string.  <br /></td></tr>
<tr class="memitem:a2a1b5bb7841f5a57732aeaf51a778d27" id="r_a2a1b5bb7841f5a57732aeaf51a778d27"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a2a1b5bb7841f5a57732aeaf51a778d27 template"><td class="memItemLeft">&#160;</td><td class="memItemRight"><a class="el" href="#a2a1b5bb7841f5a57732aeaf51a778d27">immutable_str</a> (T)=delete</td></tr>
<tr class="memdesc:a2a1b5bb7841f5a57732aeaf51a778d27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deleted constructor to prevent unintended conversions.  <br /></td></tr>
<tr class="memitem:aa1401eab88c563901b1aa3cc3b7b4962" id="r_aa1401eab88c563901b1aa3cc3b7b4962"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptjh_1_1concepts_1_1mutex__like.html">jh::concepts::mutex_like</a> M&gt; </td></tr>
<tr class="memitem:aa1401eab88c563901b1aa3cc3b7b4962 template"><td class="memItemLeft">&#160;</td><td class="memItemRight"><a class="el" href="#aa1401eab88c563901b1aa3cc3b7b4962">immutable_str</a> (std::string_view sv, M &amp;mtx)</td></tr>
<tr class="memdesc:aa1401eab88c563901b1aa3cc3b7b4962"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an immutable string from a <code>std::string_view</code> with mutex protection.  <br /></td></tr>
<tr class="memitem:adfcfe938fedea587cd87919791c0c6b8" id="r_adfcfe938fedea587cd87919791c0c6b8"><td class="memItemLeft">&#160;</td><td class="memItemRight"><a class="el" href="#adfcfe938fedea587cd87919791c0c6b8">immutable_str</a> (const immutable_str &amp;)=delete</td></tr>
<tr class="memdesc:adfcfe938fedea587cd87919791c0c6b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deleted copy constructor.  <br /></td></tr>
<tr class="memitem:aa7a0eb974f2a10c64b325fd3c3d2954a" id="r_aa7a0eb974f2a10c64b325fd3c3d2954a"><td class="memItemLeft"><a class="el" href="#a16351db0072bdf1f4957da8b27562de6">immutable_str</a> &amp;&#160;</td><td class="memItemRight"><a class="el" href="#aa7a0eb974f2a10c64b325fd3c3d2954a">operator=</a> (const <a class="el" href="#a16351db0072bdf1f4957da8b27562de6">immutable_str</a> &amp;)=delete</td></tr>
<tr class="memdesc:aa7a0eb974f2a10c64b325fd3c3d2954a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deleted copy assignment operator.  <br /></td></tr>
<tr class="memitem:a27e63942777b530add43a00bbe431ed7" id="r_a27e63942777b530add43a00bbe431ed7"><td class="memItemLeft">&#160;</td><td class="memItemRight"><a class="el" href="#a27e63942777b530add43a00bbe431ed7">immutable_str</a> (immutable_str &amp;&amp;)=delete</td></tr>
<tr class="memdesc:a27e63942777b530add43a00bbe431ed7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deleted move constructor.  <br /></td></tr>
<tr class="memitem:ae9506383450933fedd643cf80316e29f" id="r_ae9506383450933fedd643cf80316e29f"><td class="memItemLeft"><a class="el" href="#a16351db0072bdf1f4957da8b27562de6">immutable_str</a> &amp;&#160;</td><td class="memItemRight"><a class="el" href="#ae9506383450933fedd643cf80316e29f">operator=</a> (<a class="el" href="#a16351db0072bdf1f4957da8b27562de6">immutable_str</a> &amp;&amp;)=delete</td></tr>
<tr class="memdesc:ae9506383450933fedd643cf80316e29f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deleted move assignment operator.  <br /></td></tr>
<tr class="memitem:a8479231216e134c7353cee1a48d8ff21" id="r_a8479231216e134c7353cee1a48d8ff21"><td class="memItemLeft">const char *&#160;</td><td class="memItemRight"><a class="el" href="#a8479231216e134c7353cee1a48d8ff21">c_str</a> () const noexcept</td></tr>
<tr class="memdesc:a8479231216e134c7353cee1a48d8ff21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the raw C-style string pointer.  <br /></td></tr>
<tr class="memitem:a4bbdefbdc91ec2378c3c61bb892036ab" id="r_a4bbdefbdc91ec2378c3c61bb892036ab"><td class="memItemLeft">std::string&#160;</td><td class="memItemRight"><a class="el" href="#a4bbdefbdc91ec2378c3c61bb892036ab">str</a> () const</td></tr>
<tr class="memdesc:a4bbdefbdc91ec2378c3c61bb892036ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the immutable content to a <code>std::string</code>.  <br /></td></tr>
<tr class="memitem:a63be28322c9130a4f52dc73300ab41bf" id="r_a63be28322c9130a4f52dc73300ab41bf"><td class="memItemLeft">std::string_view&#160;</td><td class="memItemRight"><a class="el" href="#a63be28322c9130a4f52dc73300ab41bf">view</a> () const noexcept</td></tr>
<tr class="memdesc:a63be28322c9130a4f52dc73300ab41bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a lightweight <code>std::string_view</code> to the immutable data.  <br /></td></tr>
<tr class="memitem:a0d580a0f03b9ac20b51f65455168d0be" id="r_a0d580a0f03b9ac20b51f65455168d0be"><td class="memItemLeft"><a class="el" href="structjh_1_1pod_1_1string__view.html">pod::string_view</a>&#160;</td><td class="memItemRight"><a class="el" href="#a0d580a0f03b9ac20b51f65455168d0be">pod_view</a> () const noexcept</td></tr>
<tr class="memdesc:a0d580a0f03b9ac20b51f65455168d0be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <code><a class="el" href="structjh_1_1pod_1_1string__view.html" title="Read-only string view with POD layout.">jh::pod::string_view</a></code> representing this immutable string.  <br /></td></tr>
<tr class="memitem:af07855f470c3eacb0b028f69c3975678" id="r_af07855f470c3eacb0b028f69c3975678"><td class="memItemLeft">std::uint64_t&#160;</td><td class="memItemRight"><a class="el" href="#af07855f470c3eacb0b028f69c3975678">size</a> () const noexcept</td></tr>
<tr class="memdesc:af07855f470c3eacb0b028f69c3975678"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of the immutable string.  <br /></td></tr>
<tr class="memitem:adce15e097d54b43f8e3e224be755662c" id="r_adce15e097d54b43f8e3e224be755662c"><td class="memItemLeft">bool&#160;</td><td class="memItemRight"><a class="el" href="#adce15e097d54b43f8e3e224be755662c">operator==</a> (const <a class="el" href="#a16351db0072bdf1f4957da8b27562de6">immutable_str</a> &amp;other) const noexcept</td></tr>
<tr class="memdesc:adce15e097d54b43f8e3e224be755662c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two <code><a class="el" href="classjh_1_1immutable__str.html" title="Immutable string with optional automatic trimming and thread-safe hash caching.">immutable_str</a></code> instances for equality.  <br /></td></tr>
<tr class="memitem:adbac4be0a7d45d0d1316959ef21d591a" id="r_adbac4be0a7d45d0d1316959ef21d591a"><td class="memItemLeft">std::uint64_t&#160;</td><td class="memItemRight"><a class="el" href="#adbac4be0a7d45d0d1316959ef21d591a">hash</a> () const noexcept</td></tr>
<tr class="memdesc:adbac4be0a7d45d0d1316959ef21d591a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the cached hash value of the immutable string.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-static-methods" class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a86ca0299c8be1d3dccd6b619c366b85b" id="r_a86ca0299c8be1d3dccd6b619c366b85b"><td class="memItemLeft">static bool&#160;</td><td class="memItemRight"><a class="el" href="#a86ca0299c8be1d3dccd6b619c366b85b">is_static_built</a> ()</td></tr>
<tr class="memdesc:a86ca0299c8be1d3dccd6b619c366b85b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports whether this header was built in static mode.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-static-attribs" class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:acbe90ad0ce5f0cc957af94143ead4c79" id="r_acbe90ad0ce5f0cc957af94143ead4c79"><td class="memItemLeft">static constexpr bool&#160;</td><td class="memItemRight"><a class="el" href="#acbe90ad0ce5f0cc957af94143ead4c79">auto_trim</a> = JH_IMMUTABLE_STR_AUTO_TRIM</td></tr>
<tr class="memdesc:acbe90ad0ce5f0cc957af94143ead4c79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global flag selecting whether <code><a class="el" href="classjh_1_1immutable__str.html" title="Immutable string with optional automatic trimming and thread-safe hash caching.">immutable_str</a></code> performs automatic leading/trailing whitespace trimming.  <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Immutable string with optional automatic trimming and thread-safe hash caching. </p>
<h4>Overview</h4>
<p><code><a class="el" href="classjh_1_1immutable__str.html" title="Immutable string with optional automatic trimming and thread-safe hash caching.">immutable_str</a></code> represents a <b>truly immutable</b> and <b>thread-safe</b> string object. Once constructed, its internal data is fixed in memory and cannot be modified, reallocated, or replaced. It is designed for efficient read-only access in concurrent systems, configuration registries, and shared constant datasets. </p>
<h4>Design Goals</h4>
<ul>
<li>
Guarantee memory-level immutability with zero write access after initialization. </li>
<li>
Provide deterministic lifetime ownership using <code>unique_ptr&lt;const char[]&gt;</code>. </li>
<li>
Support concurrent reads safely without synchronization overhead. </li>
<li>
Enable efficient sharing via <code>std::shared_ptr&lt;immutable_str&gt;</code> (<code><a class="el" href="namespacejh.html#af7d00b32739582480e12e4abeec9cac1" title="Atomically replaceable handle to an immutable string.">atomic_str_ptr</a></code>). </li>
<li>
Offer consistent hashing and transparent equality for unordered containers. </li>
</ul>
<h4>Key Features</h4>
<ul>
<li>
<b>True Immutability:</b> Internal buffer is never exposed for modification. </li>
<li>
<b>Thread-Safe Hashing:</b> Cached on first access using <code>std::once_flag</code>. </li>
<li>
<b>Optional Auto-Trim:</b> Leading/trailing whitespace removed at construction if enabled. </li>
<li>
<b>Memory Efficiency:</b> Minimal overhead — stores only a pointer, size, and cached hash. </li>
<li>
<b>Transparent Lookup:</b> Works directly with <code>const char*</code> keys in hash tables. </li>
</ul>
<h4>View Access</h4>
<p>The class provides several view accessors for interoperability: </p>
<ul>
<li>
<code><a class="el" href="#a8479231216e134c7353cee1a48d8ff21" title="Returns the raw C-style string pointer.">c_str()</a></code> — Returns a <b>null-terminated</b> read-only C-string pointer. </li>
<li>
<code><a class="el" href="#a63be28322c9130a4f52dc73300ab41bf" title="Returns a lightweight std::string_view to the immutable data.">view()</a></code> — Returns a <code>std::string_view</code> to the internal data (no copy). </li>
<li>
<code><a class="el" href="#a0d580a0f03b9ac20b51f65455168d0be" title="Returns a jh::pod::string_view representing this immutable string.">pod_view()</a></code> — Returns a <code><a class="el" href="structjh_1_1pod_1_1string__view.html" title="Read-only string view with POD layout.">jh::pod::string_view</a></code> for POD-style access. </li>
<li>
<code><a class="el" href="#a4bbdefbdc91ec2378c3c61bb892036ab" title="Converts the immutable content to a std::string.">str()</a></code> — Returns a full <code>std::string</code> <b>copy</b> of the immutable buffer. </li>
</ul>
<p><b>Note:</b> Only <code><a class="el" href="#a4bbdefbdc91ec2378c3c61bb892036ab" title="Converts the immutable content to a std::string.">str()</a></code> performs data copying; other view functions are zero-copy. </p>
<h4>Construction Semantics</h4>
<ul>
<li>
Constructible from <code>const char*</code> or <code>std::string_view</code> (with a lock). </li>
<li>
Deleted copy and move semantics to preserve immutability guarantees. </li>
<li>
Preferred factory: <code>jh::make_atomic()</code> for shared atomic usage. </li>
</ul>
<h4>Dual-Mode Header Integration</h4>
<ul>
<li>
Works under both <b>header-only</b> and <b>static library</b> modes via Dual-Mode Header system. </li>
<li>
Build mode internally controlled by <code>JH_INTERNAL_SHOULD_DEFINE</code>. </li>
<li>
Runtime detection available via <code><a class="el" href="#a86ca0299c8be1d3dccd6b619c366b85b" title="Reports whether this header was built in static mode.">is_static_built()</a></code>. </li>
</ul>
<h4>Thread Safety</h4>
<ul>
<li>
All accessors (<code><a class="el" href="#a8479231216e134c7353cee1a48d8ff21" title="Returns the raw C-style string pointer.">c_str()</a></code>, <code><a class="el" href="#a63be28322c9130a4f52dc73300ab41bf" title="Returns a lightweight std::string_view to the immutable data.">view()</a></code>, <code><a class="el" href="#adbac4be0a7d45d0d1316959ef21d591a" title="Computes the cached hash value of the immutable string.">hash()</a></code>, etc.) are thread-safe. </li>
<li>
No external synchronization required after construction. </li>
<li>
Hash is lazily computed once, guarded by <code>std::call_once</code>. </li>
</ul>
<h4>See Also</h4>
<ul>
<li>
<code><a class="el" href="namespacejh.html#abc89d1d2a2d84b2aba124fe8d9ee1d7b" title="Duck-typed alias of jh::conc::pointer_pool for content-based pooling of immutable objects.">jh::observe_pool</a></code> — object pool compatible with <code><a class="el" href="classjh_1_1immutable__str.html" title="Immutable string with optional automatic trimming and thread-safe hash caching.">immutable_str</a></code>. </li>
<li>
<code><a class="el" href="namespacejh.html#af7d00b32739582480e12e4abeec9cac1" title="Atomically replaceable handle to an immutable string.">jh::atomic_str_ptr</a></code> — alias for <code>std::shared_ptr&lt;immutable_str&gt;</code>. </li>
</ul>
</div><a name="doc-constructors" id="doc-constructors"></a><h2 id="header-doc-constructors" class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a16351db0072bdf1f4957da8b27562de6" name="a16351db0072bdf1f4957da8b27562de6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16351db0072bdf1f4957da8b27562de6">&#9670;&#160;</a></span>immutable_str() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">JH_INLINE jh::immutable_str::immutable_str </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel explicit">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an immutable string from a C-string. </p>
<p>Creates an immutable copy of the provided <b>null-terminated C-string</b>. The constructor performs an internal <code>strlen()</code> to determine the source length and allocates a new immutable buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="#a4bbdefbdc91ec2378c3c61bb892036ab" title="Converts the immutable content to a std::string.">str</a></td><td>A null-terminated C-string. May be <code>nullptr</code>, which is treated as an empty string.</td></tr>
  </table>
  </dd>
</dl>
<p>The caller must ensure that the input pointer remains valid and unmodified during construction. This is only safe when the input is either: </p>
<ul>
<li>
a string literal, or </li>
<li>
a thread-exclusive buffer not accessed concurrently. </li>
</ul>
<p>Passing a pointer that can be modified by another thread results in undefined behavior.</p>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>
Marked as <code>explicit</code> to prevent unintended implicit conversions. </li>
<li>
Uses <code>strlen()</code> internally to determine the input length. </li>
<li>
Trimming behavior depends on <code>JH_IMMUTABLE_STR_AUTO_TRIM</code>. </li>
<li>
For non-null-terminated or shared buffers, use <code>immutable_str(std::string_view, Mutex&amp;)</code> instead. </li>
<li>
Designed for safe interoperation with C-style APIs (e.g., LLVM <code>extern "C"</code>). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a2a1b5bb7841f5a57732aeaf51a778d27" name="a2a1b5bb7841f5a57732aeaf51a778d27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a1b5bb7841f5a57732aeaf51a778d27">&#9670;&#160;</a></span>immutable_str() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">jh::immutable_str::immutable_str </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel explicit">explicit</span><span class="mlabel delete">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deleted constructor to prevent unintended conversions. </p>
<p>This template overload disables single-argument construction from non-C-string types, ensuring that only <code>const char*</code> inputs are accepted. This avoids unsafe or ambiguous conversions that could lead to undefined behavior. </p>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>
Rejects non-string pointer inputs (e.g. numeric types, containers, or temporaries). </li>
<li>
Ensures that only <code>const char*</code> can be used for direct construction. </li>
<li>
For data without a null terminator or requiring lifetime protection, use <code>immutable_str(std::string_view, Mutex&amp;)</code> instead. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="aa1401eab88c563901b1aa3cc3b7b4962" name="aa1401eab88c563901b1aa3cc3b7b4962"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1401eab88c563901b1aa3cc3b7b4962">&#9670;&#160;</a></span>immutable_str() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="conceptjh_1_1concepts_1_1mutex__like.html">jh::concepts::mutex_like</a> M&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">jh::immutable_str::immutable_str </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>sv</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M &amp;</td>          <td class="paramname"><span class="paramname"><em>mtx</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an immutable string from a <code>std::string_view</code> with mutex protection. </p>
<p>Creates an immutable copy of the data referenced by <code>sv</code> while holding the provided mutex. This overload is intended for cases where the source memory may be transient, mutable, or shared between threads. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">M</td><td>Any type satisfying <code><a class="el" href="conceptjh_1_1concepts_1_1mutex__like.html" title="General mutex-like concept.">jh::concepts::mutex_like</a></code> — such as <code>std::mutex</code>, <code>std::shared_mutex</code>, or custom types.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>A <code>std::string_view</code> representing the source data. It may or may not be null-terminated. </td></tr>
    <tr><td class="paramname">mtx</td><td>A reference to a mutex protecting the lifetime of the buffer referenced by <code>sv</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>If <code>sv</code> contains embedded null (<span class="tt">'\0'</span>) characters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>
Performs a bounded null-character check using <code>::strnlen()</code> to verify that no embedded nulls exist within <code>sv.size()</code> bytes. </li>
<li>
Copies exactly <code>sv.size()</code> bytes into an internal immutable buffer, even if not null-terminated. </li>
<li>
The provided <code>mtx</code> <b>must</b> guard the same memory region as <code>sv.data()</code>; using an unrelated mutex leads to undefined behavior. </li>
<li>
Supports both exclusive and shared mutex types, via <code><a class="el" href="classjh_1_1sync_1_1const__lock.html" title="Scope-based immutability barrier for mutex_like types.">jh::sync::const_lock</a></code>. </li>
<li>
Recommended for constructing immutable strings from shared or non-terminated data regions. </li>
<li>
<b>Optional optimization:</b><br  />
 If you are certain that the source data is <em>not shared across threads</em>, you may explicitly use <code><a class="el" href="namespacejh_1_1typed.html#a026542219730998fd7f5830fc6ad1eb3" title="Global constant instance of null_mutex_t.">jh::typed::null_mutex</a></code> (from <code>&lt;jh/typed&gt;</code>) as the mutex parameter. It is a zero-cost, concept-compatible dummy mutex, and all locking operations become no-ops.<br  />
 <b>Note:</b> This must be explicitly specified; no automatic substitution is performed.  </li>
</ul>
</dd></dl>

</div>
</div>
<a id="adfcfe938fedea587cd87919791c0c6b8" name="adfcfe938fedea587cd87919791c0c6b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfcfe938fedea587cd87919791c0c6b8">&#9670;&#160;</a></span>immutable_str() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">jh::immutable_str::immutable_str </td>
          <td>(</td>
          <td class="paramtype">const immutable_str &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel delete">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deleted copy constructor. </p>
<p><code><a class="el" href="classjh_1_1immutable__str.html" title="Immutable string with optional automatic trimming and thread-safe hash caching.">immutable_str</a></code> manages its string data through <code>std::unique_ptr&lt;const char[]&gt;</code>, enforcing exclusive ownership. Copy construction would require duplicating the underlying data buffer, which is explicitly disallowed to maintain immutability. </p>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>
Prevents unintended shallow copies. </li>
<li>
Ensures that each instance has a unique, immutable data block. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a27e63942777b530add43a00bbe431ed7" name="a27e63942777b530add43a00bbe431ed7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27e63942777b530add43a00bbe431ed7">&#9670;&#160;</a></span>immutable_str() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">jh::immutable_str::immutable_str </td>
          <td>(</td>
          <td class="paramtype">immutable_str &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel delete">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deleted move constructor. </p>
<p>Unlike typical movable types, <code><a class="el" href="classjh_1_1immutable__str.html" title="Immutable string with optional automatic trimming and thread-safe hash caching.">immutable_str</a></code> forbids move semantics. Moving would transfer ownership of the underlying buffer, violating the immutability principle. </p>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>
Immutability implies that instances cannot change ownership post-construction. </li>
<li>
To share instances safely, use <code>std::shared_ptr&lt;jh::immutable_str&gt;</code>. </li>
</ul>
</dd></dl>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="a8479231216e134c7353cee1a48d8ff21" name="a8479231216e134c7353cee1a48d8ff21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8479231216e134c7353cee1a48d8ff21">&#9670;&#160;</a></span>c_str()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">JH_INLINE const char * jh::immutable_str::c_str </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the raw C-style string pointer. </p>
<p>Provides direct access to the internal immutable buffer as a <code>const char*</code>. The returned pointer is guaranteed to remain valid for the lifetime of the object. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to an immutable, null-terminated character sequence.</dd></dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>
The returned pointer must never be modified. </li>
<li>
Ownership remains with <code><a class="el" href="classjh_1_1immutable__str.html" title="Immutable string with optional automatic trimming and thread-safe hash caching.">immutable_str</a></code>; do not deallocate it. </li>
<li>
Safe for concurrent read access from multiple threads. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="adbac4be0a7d45d0d1316959ef21d591a" name="adbac4be0a7d45d0d1316959ef21d591a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbac4be0a7d45d0d1316959ef21d591a">&#9670;&#160;</a></span>hash()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">JH_INLINE std::uint64_t jh::immutable_str::hash </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the cached hash value of the immutable string. </p>
<p>Returns a 64-bit hash derived from the string's contents. The computation is performed lazily — the first call initializes the cached value in a thread-safe manner, and all subsequent calls return the stored result without recomputation. </p>
<dl class="section return"><dt>Returns</dt><dd>A 64-bit hash value uniquely representing the string contents.</dd></dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>
Lazy evaluation ensures hashing is performed only once per instance. </li>
<li>
Thread-safe: guarded internally by <code>std::once_flag</code>. </li>
<li>
Equivalent calls always return the same value for the same object. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a86ca0299c8be1d3dccd6b619c366b85b" name="a86ca0299c8be1d3dccd6b619c366b85b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86ca0299c8be1d3dccd6b619c366b85b">&#9670;&#160;</a></span>is_static_built()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">JH_INLINE bool jh::immutable_str::is_static_built </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports whether this header was built in static mode. </p>
<p>Indicates if the current <code><a class="el" href="classjh_1_1immutable__str.html" title="Immutable string with optional automatic trimming and thread-safe hash caching.">immutable_str</a></code> implementation was compiled as part of the static library target (<code>jh-toolkit-static</code>) or used in header-only mode (<code>jh-toolkit</code>). </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if compiled as part of <code>jh-toolkit-static</code>; otherwise <code>false</code>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>
This function supports runtime detection for dual-mode header builds. </li>
<li>
In header-only builds, it always returns <code>false</code>. </li>
<li>
In static library builds, it returns <code>true</code> (macro <code>JH_IS_STATIC_BUILD</code> defined). </li>
<li>
Useful for diagnostics or conditional logic depending on linkage mode. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="aa7a0eb974f2a10c64b325fd3c3d2954a" name="aa7a0eb974f2a10c64b325fd3c3d2954a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7a0eb974f2a10c64b325fd3c3d2954a">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a16351db0072bdf1f4957da8b27562de6">immutable_str</a> &amp; jh::immutable_str::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a16351db0072bdf1f4957da8b27562de6">immutable_str</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel delete">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deleted copy assignment operator. </p>
<p>Copy assignment is disabled to preserve the immutable property of <code><a class="el" href="classjh_1_1immutable__str.html" title="Immutable string with optional automatic trimming and thread-safe hash caching.">immutable_str</a></code>. Assigning one immutable instance to another would imply replacing its internal buffer, which contradicts its design. </p>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>
Prevents mutation through reassignment. </li>
<li>
Use <code>std::shared_ptr&lt;jh::immutable_str&gt;</code> if sharing semantics are required. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ae9506383450933fedd643cf80316e29f" name="ae9506383450933fedd643cf80316e29f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9506383450933fedd643cf80316e29f">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a16351db0072bdf1f4957da8b27562de6">immutable_str</a> &amp; jh::immutable_str::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a16351db0072bdf1f4957da8b27562de6">immutable_str</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel delete">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deleted move assignment operator. </p>
<p>Move assignment is disabled because <code><a class="el" href="classjh_1_1immutable__str.html" title="Immutable string with optional automatic trimming and thread-safe hash caching.">immutable_str</a></code> must remain constant for its entire lifetime. Any form of reassignment or ownership transfer is considered a modification of its internal state. </p>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>
Enforces strict immutability and thread safety. </li>
<li>
Instances should be shared through <code>std::shared_ptr</code>, not reassigned. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="adce15e097d54b43f8e3e224be755662c" name="adce15e097d54b43f8e3e224be755662c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adce15e097d54b43f8e3e224be755662c">&#9670;&#160;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">JH_INLINE bool jh::immutable_str::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a16351db0072bdf1f4957da8b27562de6">immutable_str</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two <code><a class="el" href="classjh_1_1immutable__str.html" title="Immutable string with optional automatic trimming and thread-safe hash caching.">immutable_str</a></code> instances for equality. </p>
<p>Performs a deep, byte-wise comparison of the internal buffers. This operator guarantees that two instances are considered equal only if their contents are identical. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Another <code><a class="el" href="classjh_1_1immutable__str.html" title="Immutable string with optional automatic trimming and thread-safe hash caching.">immutable_str</a></code> instance to compare with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if both strings contain identical data; otherwise <code>false</code>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>
Automatically implies <code>operator!=</code> as its logical negation. </li>
<li>
Comparison is content-based, not pointer-based. </li>
<li>
Safe for concurrent read operations on both operands. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a0d580a0f03b9ac20b51f65455168d0be" name="a0d580a0f03b9ac20b51f65455168d0be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d580a0f03b9ac20b51f65455168d0be">&#9670;&#160;</a></span>pod_view()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">JH_INLINE <a class="el" href="structjh_1_1pod_1_1string__view.html">pod::string_view</a> jh::immutable_str::pod_view </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a <code><a class="el" href="structjh_1_1pod_1_1string__view.html" title="Read-only string view with POD layout.">jh::pod::string_view</a></code> representing this immutable string. </p>
<p>Provides a POD-compatible, read-only view over the internal buffer. The returned object has the same layout and semantics as <code><a class="el" href="structjh_1_1pod_1_1string__view.html" title="Read-only string view with POD layout.">jh::pod::string_view</a></code> — that is, a pair of <code>const char*</code> and <code>uint64_t</code> describing a non-owning range of bytes. </p>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="structjh_1_1pod_1_1string__view.html" title="Read-only string view with POD layout.">jh::pod::string_view</a></code> referencing the same data as this object.</dd></dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>
No memory is copied or allocated. </li>
<li>
The view remains valid as long as the originating <code><a class="el" href="classjh_1_1immutable__str.html" title="Immutable string with optional automatic trimming and thread-safe hash caching.">immutable_str</a></code> exists. </li>
<li>
It enables deterministic hashing by allowing <code><a class="el" href="structjh_1_1pod_1_1string__view.html" title="Read-only string view with POD layout.">jh::pod::string_view</a></code> to compute stable hashes via any algorithm provided by <code><a class="el" href="namespacejh_1_1meta.html#a7ea475ab0421edb9edb93189740da707" title="Compile-time selectable hash algorithm tag (FNV, DJB2, SDBM, etc.).">jh::meta::c_hash</a></code>, unlike the non-deterministic nature of typical runtime hash functions. </li>
<li>
Comparison and hashing behavior are identical to <code><a class="el" href="structjh_1_1pod_1_1string__view.html" title="Read-only string view with POD layout.">jh::pod::string_view</a></code>. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="af07855f470c3eacb0b028f69c3975678" name="af07855f470c3eacb0b028f69c3975678"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af07855f470c3eacb0b028f69c3975678">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">JH_INLINE uint64_t jh::immutable_str::size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the length of the immutable string. </p>
<p>Provides the total number of characters contained in the string. The length is determined at construction time and remains constant throughout the object's lifetime. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of characters in the string.</dd></dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>
The value is fixed after initialization (no dynamic resizing). </li>
<li>
Equivalent to <code><a class="el" href="#a63be28322c9130a4f52dc73300ab41bf" title="Returns a lightweight std::string_view to the immutable data.">view()</a>.<a class="el" href="#af07855f470c3eacb0b028f69c3975678" title="Returns the length of the immutable string.">size()</a></code>. </li>
<li>
Safe for concurrent read access. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a4bbdefbdc91ec2378c3c61bb892036ab" name="a4bbdefbdc91ec2378c3c61bb892036ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bbdefbdc91ec2378c3c61bb892036ab">&#9670;&#160;</a></span>str()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">JH_INLINE std::string jh::immutable_str::str </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts the immutable content to a <code>std::string</code>. </p>
<p>Creates and returns a <b>copy</b> of the internal immutable data as a <code>std::string</code>. This is the only interface that performs a deep copy, preserving immutability while providing a mutable external representation. </p>
<dl class="section return"><dt>Returns</dt><dd>A <code>std::string</code> containing a copy of the immutable data.</dd></dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>
This operation allocates new memory for the returned <code>std::string</code>. </li>
<li>
Useful when interoperability with mutable string APIs is required. </li>
<li>
Thread-safe; does not modify the internal buffer. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a63be28322c9130a4f52dc73300ab41bf" name="a63be28322c9130a4f52dc73300ab41bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63be28322c9130a4f52dc73300ab41bf">&#9670;&#160;</a></span>view()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">JH_INLINE std::string_view jh::immutable_str::view </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a lightweight <code>std::string_view</code> to the immutable data. </p>
<p>Provides a non-owning view of the internal string data without copying. This is the most efficient accessor for read-only operations and comparison. </p>
<dl class="section return"><dt>Returns</dt><dd>A <code>std::string_view</code> referencing the immutable string data.</dd></dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>
The view remains valid for the lifetime of the <code><a class="el" href="classjh_1_1immutable__str.html" title="Immutable string with optional automatic trimming and thread-safe hash caching.">immutable_str</a></code> instance. </li>
<li>
No memory allocation occurs. </li>
<li>
Safe for concurrent reads; not safe if the underlying object is destroyed. </li>
</ul>
</dd></dl>

</div>
</div>
<a name="doc-variable-members" id="doc-variable-members"></a><h2 id="header-doc-variable-members" class="groupheader">Member Data Documentation</h2>
<a id="acbe90ad0ce5f0cc957af94143ead4c79" name="acbe90ad0ce5f0cc957af94143ead4c79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbe90ad0ce5f0cc957af94143ead4c79">&#9670;&#160;</a></span>auto_trim</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool jh::immutable_str::auto_trim = JH_IMMUTABLE_STR_AUTO_TRIM</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Global flag selecting whether <code><a class="el" href="classjh_1_1immutable__str.html" title="Immutable string with optional automatic trimming and thread-safe hash caching.">immutable_str</a></code> performs automatic leading/trailing whitespace trimming. </p>
<p>This value is controlled by the macro <code>JH_IMMUTABLE_STR_AUTO_TRIM</code>. The macro must be defined <b>before</b> including <code>&lt;jh/immutable_str&gt;</code>. If the macro is not defined beforehand, the default value is <code>true</code>. </p>
<p>Because <code>auto_trim</code> is an ordinary <code>constexpr bool</code>, it can be inspected in <code>constexpr</code> contexts and used inside concepts, templates, and other compile-time logic—avoiding the need for preprocessor conditionals (<code>#if</code> / <code>#ifdef</code>). </p>
<ul>
<li>
<code>true</code> (default): All constructed <code><a class="el" href="classjh_1_1immutable__str.html" title="Immutable string with optional automatic trimming and thread-safe hash caching.">immutable_str</a></code> instances remove leading and trailing ASCII whitespace. </li>
<li>
<code>false</code>: Whitespace is preserved exactly. </li>
</ul>
<h4>Usage Recommendation</h4>
<p>To ensure consistent behavior across translation units — especially when dependencies may include <code>&lt;jh/immutable_str&gt;</code> indirectly — place: </p>
<div class="fragment"><div class="line"><span class="preprocessor">#define JH_IMMUTABLE_STR_AUTO_TRIM false</span></div>
<div class="line"><span class="preprocessor">#include &lt;... all other includes ...&gt;</span></div>
</div><!-- fragment --><p>before any code that might include the header. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/jh/core/<a class="el" href="">immutable_str.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
</div> <!-- top -->
<hr class="footer"/>
<div class="footer">
    <img class="footer-logo" src="Ojing.svg" alt="Ojing"/>
    <div class="footer-text">
        JH-Toolkit v1.4.0 · Generated by Doxygen
    </div>
    <div class="footer-note">
        We primarily support embedded documentation views in IDEs (classic CLion).
        To ensure compatibility with embedded rendering, some example code in this
        documentation intentionally contains HTML entities.
        In certain cases, Doxygen does not unescape these entities correctly.
        This is a known limitation and currently has no workaround.
    </div>
</div>
</body>
</html>
