<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.16.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>JH-Toolkit: jh::conc::pointer_pool&lt; T, Hash, Eq &gt; Class Template Reference</title>
<link rel="icon" href="Jindallae.svg" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="Oree.svg"/></td>
  <td id="projectalign">
   <div id="projectname">JH-Toolkit<span id="projectnumber">&#160;v1.4.0</span>
   </div>
   <div id="projectbrief">An engineering-oriented C++20 toolkit with duck-typed concepts, static design, async coroutines, and semantic containers — header-only, RTTI-free, and concurrency-friendly.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.16.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('classjh_1_1conc_1_1pointer__pool.html','','classjh_1_1conc_1_1pointer__pool-members'); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">jh::conc::pointer_pool&lt; T, Hash, Eq &gt; Class Template Reference<span class="mlabels"><span class="mlabel final">final</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>Weak pointer-observed pool for immutable or structurally immutable objects.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="">jh/concurrent/pointer_pool.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5635484c314767535b158e999f11bb3e" id="r_a5635484c314767535b158e999f11bb3e"><td class="memItemLeft">&#160;</td><td class="memItemRight"><a class="el" href="#a5635484c314767535b158e999f11bb3e">pointer_pool</a> (std::uint64_t reserve_size=<a class="el" href="#a36de498d501ee194c0327fd3f3c02850">MIN_RESERVED_SIZE</a>)</td></tr>
<tr class="memdesc:a5635484c314767535b158e999f11bb3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a pool with an initial reserved capacity.  <br /></td></tr>
<tr class="memitem:a11deac7ee6e03401927e324318b993bd" id="r_a11deac7ee6e03401927e324318b993bd"><td class="memItemLeft">&#160;</td><td class="memItemRight"><a class="el" href="#a11deac7ee6e03401927e324318b993bd">pointer_pool</a> (const pointer_pool &amp;)=delete</td></tr>
<tr class="memdesc:a11deac7ee6e03401927e324318b993bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deleted copy constructor.  <br /></td></tr>
<tr class="memitem:a627cc87befae4da634e00507707fe852" id="r_a627cc87befae4da634e00507707fe852"><td class="memItemLeft"><a class="el" href="#a5635484c314767535b158e999f11bb3e">pointer_pool</a> &amp;&#160;</td><td class="memItemRight"><a class="el" href="#a627cc87befae4da634e00507707fe852">operator=</a> (const <a class="el" href="#a5635484c314767535b158e999f11bb3e">pointer_pool</a> &amp;)=delete</td></tr>
<tr class="memdesc:a627cc87befae4da634e00507707fe852"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deleted copy assignment operator.  <br /></td></tr>
<tr class="memitem:a2772de882702c1784af4f6bbb1dcebb5" id="r_a2772de882702c1784af4f6bbb1dcebb5"><td class="memItemLeft">&#160;</td><td class="memItemRight"><a class="el" href="#a2772de882702c1784af4f6bbb1dcebb5">pointer_pool</a> (pointer_pool &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:a2772de882702c1784af4f6bbb1dcebb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor.  <br /></td></tr>
<tr class="memitem:acf375ea05aecc56f1e4bb97e42accf56" id="r_acf375ea05aecc56f1e4bb97e42accf56"><td class="memItemLeft"><a class="el" href="#a5635484c314767535b158e999f11bb3e">pointer_pool</a> &amp;&#160;</td><td class="memItemRight"><a class="el" href="#acf375ea05aecc56f1e4bb97e42accf56">operator=</a> (<a class="el" href="#a5635484c314767535b158e999f11bb3e">pointer_pool</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:acf375ea05aecc56f1e4bb97e42accf56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator.  <br /></td></tr>
<tr class="memitem:adb9b3b4c28f20b8aee749bbf9357e09a" id="r_adb9b3b4c28f20b8aee749bbf9357e09a"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:adb9b3b4c28f20b8aee749bbf9357e09a template"><td class="memItemLeft">std::shared_ptr&lt; T &gt;&#160;</td><td class="memItemRight"><a class="el" href="#adb9b3b4c28f20b8aee749bbf9357e09a">acquire</a> (Args &amp;&amp;... args) const =delete</td></tr>
<tr class="memdesc:adb9b3b4c28f20b8aee749bbf9357e09a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deleted <code><a class="el" href="#adb9b3b4c28f20b8aee749bbf9357e09a" title="Deleted acquire() for const pointer_pool.">acquire()</a></code> for <code>const <a class="el" href="classjh_1_1conc_1_1pointer__pool.html" title="Weak pointer-observed pool for immutable or structurally immutable objects.">pointer_pool</a></code>.  <br /></td></tr>
<tr class="memitem:adc33a2a2b7ea82ab585e626ee3ddf602" id="r_adc33a2a2b7ea82ab585e626ee3ddf602"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:adc33a2a2b7ea82ab585e626ee3ddf602 template"><td class="memItemLeft">std::shared_ptr&lt; T &gt;&#160;</td><td class="memItemRight"><a class="el" href="#adc33a2a2b7ea82ab585e626ee3ddf602">acquire</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:adc33a2a2b7ea82ab585e626ee3ddf602"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves an object from the pool, or creates a new one if none exists.  <br /></td></tr>
<tr class="memitem:a2b1d8b83a4d1036c2c2e7a910a5e2385" id="r_a2b1d8b83a4d1036c2c2e7a910a5e2385"><td class="memItemLeft">void&#160;</td><td class="memItemRight"><a class="el" href="#a2b1d8b83a4d1036c2c2e7a910a5e2385">cleanup</a> ()</td></tr>
<tr class="memdesc:a2b1d8b83a4d1036c2c2e7a910a5e2385"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes expired weak references from the pool.  <br /></td></tr>
<tr class="memitem:ad237f701226e639f0e3eb38a086e11d9" id="r_ad237f701226e639f0e3eb38a086e11d9"><td class="memItemLeft">void&#160;</td><td class="memItemRight"><a class="el" href="#ad237f701226e639f0e3eb38a086e11d9">cleanup_shrink</a> ()</td></tr>
<tr class="memdesc:ad237f701226e639f0e3eb38a086e11d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes expired entries and conditionally shrinks the reserved capacity.  <br /></td></tr>
<tr class="memitem:a33f91215748a8b26aa66904eef0e1fca" id="r_a33f91215748a8b26aa66904eef0e1fca"><td class="memItemLeft">std::uint64_t&#160;</td><td class="memItemRight"><a class="el" href="#a33f91215748a8b26aa66904eef0e1fca">size</a> () const</td></tr>
<tr class="memdesc:a33f91215748a8b26aa66904eef0e1fca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current number of elements in the pool.  <br /></td></tr>
<tr class="memitem:ae6e8404480a354f18da887e75834e86f" id="r_ae6e8404480a354f18da887e75834e86f"><td class="memItemLeft">std::uint64_t&#160;</td><td class="memItemRight"><a class="el" href="#ae6e8404480a354f18da887e75834e86f">capacity</a> () const</td></tr>
<tr class="memdesc:ae6e8404480a354f18da887e75834e86f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current reserved size of the pool.  <br /></td></tr>
<tr class="memitem:aed0de0b67b6d05b5a640231482d77fbc" id="r_aed0de0b67b6d05b5a640231482d77fbc"><td class="memItemLeft">void&#160;</td><td class="memItemRight"><a class="el" href="#aed0de0b67b6d05b5a640231482d77fbc">clear</a> ()</td></tr>
<tr class="memdesc:aed0de0b67b6d05b5a640231482d77fbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears all entries and resets the pool to its initial state.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-static-attribs" class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a36de498d501ee194c0327fd3f3c02850" id="r_a36de498d501ee194c0327fd3f3c02850"><td class="memItemLeft">static std::uint64_t constexpr&#160;</td><td class="memItemRight"><a class="el" href="#a36de498d501ee194c0327fd3f3c02850">MIN_RESERVED_SIZE</a> = 16</td></tr>
<tr class="memdesc:a36de498d501ee194c0327fd3f3c02850"><td class="mdescLeft">&#160;</td><td class="mdescRight">The minimum reserved capacity for the pool.  <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename T, typename Hash, typename Eq&gt;<br />
requires ( requires(const std::weak_ptr&lt;T&gt;&amp; t) { { Hash{}(t) } -&gt; std::convertible_to&lt;size_t&gt;; } &amp;&amp; requires(const std::weak_ptr&lt;T&gt;&amp; a, const std::weak_ptr&lt;T&gt;&amp; b) { { Eq{}(a, b) } -&gt; std::convertible_to&lt;bool&gt;; })<br />
class jh::conc::pointer_pool&lt; T, Hash, Eq &gt;</div><p>Weak pointer-observed pool for immutable or structurally immutable objects. </p>
<h4>Core Behavior</h4>
<ol>
<li>
Objects are always constructed first using the forwarded arguments. </li>
<li>
The pool lock is acquired only when attempting insertion. </li>
<li>
If an equivalent object already exists, that instance is returned and the temporary is discarded. </li>
<li>
If no match exists, the temporary becomes the canonical instance stored in the pool. </li>
</ol>
<p>This construct-first, lock-then-insert pattern is required because lookup is defined by the object's own equality; no external key or pre-hash structure can be used. </p>
<h4>Design Characteristics</h4>
<ul>
<li>
<b>Non-intrusive:</b> The pool never owns objects; it records only <code>std::weak_ptr</code> while ownership remains external. </li>
<li>
<b>Deferred cleanup:</b> Expired entries are removed only during insertion, capacity checks, or explicit cleanup calls. </li>
<li>
<b>Adaptive capacity:</b> The container may grow or shrink depending on occupancy thresholds evaluated during insertion. </li>
<li>
<b>Thread-safe:</b> Lookups and insertions coordinate through <code>std::shared_mutex</code>. </li>
<li>
<b>Discard-friendly:</b> Temporary objects are cheap to abandon when a matching instance exists. </li>
</ul>
<h4>Usage Notes</h4>
<ul>
<li>
Best suited for immutable or structurally immutable types whose identity is fully determined at construction. </li>
<li>
For heavier objects, prefer a two-phase initialization pattern: construct only identity fields immediately and defer expensive setup until the object becomes the accepted instance. </li>
<li>
Fields contributing to equality and hashing must remain constant while managed by the pool. </li>
</ul>
<h4>Concurrency and Safety</h4>
<ul>
<li>
Concurrent calls to <code><a class="el" href="#adb9b3b4c28f20b8aee749bbf9357e09a" title="Deleted acquire() for const pointer_pool.">acquire()</a></code> are safe. </li>
<li>
Insertion and deduplication are atomic under exclusive locking. </li>
<li>
Externally held <code>std::shared_ptr</code> objects remain valid even if the pool is cleared or destroyed. </li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Hash and equality functors need only reflect object-level identity. When using <code><a class="el" href="namespacejh.html#abc89d1d2a2d84b2aba124fe8d9ee1d7b" title="Duck-typed alias of jh::conc::pointer_pool for content-based pooling of immutable objects.">jh::observe_pool</a></code>, these are automatically derived from <code>std::hash&lt;T&gt;()</code> or adl <code>hash(t)</code> or <code>t.hash()</code>, and <code>operator==()</code> to ensure consistent behavior.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>On Windows environments based on the Universal CRT (including MinGW variants), <code>std::shared_ptr</code> and <code>std::weak_ptr</code> may exhibit incorrect reference-count synchronization under high concurrency. As a result, <code>weak_ptr::lock()</code> may succeed against an object whose underlying <code>shared_ptr</code> has already been destroyed, leading to invalid access or crashes even under otherwise correct usage. Additionally, insertion of <code>std::weak_ptr</code> into <code>std::unordered_*</code> containers on these platforms incurs significant jitter. <br  />
 Due to these platform-specific defects, high-pressure concurrent use of <code><a class="el" href="classjh_1_1conc_1_1pointer__pool.html" title="Weak pointer-observed pool for immutable or structurally immutable objects.">pointer_pool</a></code> is not recommended on Windows UCRT-based toolchains. </dd></dl>
</div><a name="doc-constructors" id="doc-constructors"></a><h2 id="header-doc-constructors" class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a5635484c314767535b158e999f11bb3e" name="a5635484c314767535b158e999f11bb3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5635484c314767535b158e999f11bb3e">&#9670;&#160;</a></span>pointer_pool() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Hash, typename Eq&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classjh_1_1conc_1_1pointer__pool.html">jh::conc::pointer_pool</a>&lt; T, Hash, Eq &gt;::pointer_pool </td>
          <td>(</td>
          <td class="paramtype">std::uint64_t</td>          <td class="paramname"><span class="paramname"><em>reserve_size</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a36de498d501ee194c0327fd3f3c02850">MIN_RESERVED_SIZE</a></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel explicit">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a pool with an initial reserved capacity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reserve_size</td><td>The initial capacity to reserve for the internal hash set. Defaults to <code>MIN_RESERVED_SIZE</code> (<span class="tt">16</span>).</td></tr>
  </table>
  </dd>
</dl>
<p>Initializes the pool's internal storage and establishes the adaptive resizing baseline. This constructor performs no object construction; it only reserves memory for the underlying <code>std::unordered_set</code> that stores weak references.</p>
<dl class="section note"><dt>Note</dt><dd>The reserved size determines the initial hash set capacity and defines the minimum capacity threshold for future adaptive resizing. The pool will never shrink below <code>MIN_RESERVED_SIZE</code> (<span class="tt">16</span>), ensuring predictable allocation behavior and avoiding frequent reallocation during low-load periods. </dd></dl>

</div>
</div>
<a id="a11deac7ee6e03401927e324318b993bd" name="a11deac7ee6e03401927e324318b993bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11deac7ee6e03401927e324318b993bd">&#9670;&#160;</a></span>pointer_pool() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Hash, typename Eq&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classjh_1_1conc_1_1pointer__pool.html">jh::conc::pointer_pool</a>&lt; T, Hash, Eq &gt;::pointer_pool </td>
          <td>(</td>
          <td class="paramtype">const pointer_pool&lt; T, Hash, Eq &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel delete">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deleted copy constructor. </p>
<p>Copying is disabled because two pools observing the same set of immutable objects have no meaningful deduplication relationship. A duplicated observer would only increase contention and break the one-pool-per-type principle for resource or handle management.</p>
<dl class="section note"><dt>Note</dt><dd>For structurally immutable resource types, only one pool should exist in the entire program. For simple data deduplication (e.g. shared strings), threads can directly share <code>std::reference_wrapper</code> or <code>shared_ptr</code> instead of copying the pool. </dd></dl>

</div>
</div>
<a id="a2772de882702c1784af4f6bbb1dcebb5" name="a2772de882702c1784af4f6bbb1dcebb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2772de882702c1784af4f6bbb1dcebb5">&#9670;&#160;</a></span>pointer_pool() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Hash, typename Eq&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classjh_1_1conc_1_1pointer__pool.html">jh::conc::pointer_pool</a>&lt; T, Hash, Eq &gt;::pointer_pool </td>
          <td>(</td>
          <td class="paramtype">pointer_pool&lt; T, Hash, Eq &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor. </p>
<p>Transfers internal weak references and capacity state from another pool. The source pool is locked during transfer and cleared afterward to ensure a valid empty state.</p>
<dl class="section note"><dt>Note</dt><dd>Moving a pool transfers observation authority, not ownership of objects. Since the pool tracks objects via <code>weak_ptr</code>, live instances remain valid and unaffected. After a move, entries may temporarily exist in both the old and new pool, but this is acceptable for deduplication use. </dd></dl>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="adc33a2a2b7ea82ab585e626ee3ddf602" name="adc33a2a2b7ea82ab585e626ee3ddf602"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc33a2a2b7ea82ab585e626ee3ddf602">&#9670;&#160;</a></span>acquire() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Hash, typename Eq&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; T &gt; <a class="el" href="classjh_1_1conc_1_1pointer__pool.html">jh::conc::pointer_pool</a>&lt; T, Hash, Eq &gt;::acquire </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves an object from the pool, or creates a new one if none exists. </p>
<p>Constructs a temporary instance of <code>T</code> using the forwarded arguments, then attempts to insert it into the pool. If a logically equivalent instance already exists (as determined by <code>Eq</code>), it is reused and the newly created temporary object is discarded. Otherwise, the new instance is inserted and returned.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Args</td><td>Constructor argument types for <code>T</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>Arguments forwarded to <code>T</code>'s constructor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>std::shared_ptr&lt;T&gt;</code> representing the pooled object.</dd></dl>
<p><b>Acquisition Flow:</b></p>
<ol>
<li>
A new object is tentatively constructed using the forwarded arguments. </li>
<li>
The pool lock is acquired only during insertion and lookup. </li>
<li>
If a logically equivalent instance already exists, it is reused — the temporary object is immediately discarded. </li>
<li>
If not found, the new object is inserted and its <code>shared_ptr</code> returned. </li>
</ol>
<dl class="section note"><dt>Note</dt><dd>The pool employs a construct-first, lock-then-insert model. This avoids holding the pool lock during object construction, enabling support for non-copyable or non-movable types. Temporary objects may be discarded if an equivalent instance already exists, so types should support lightweight provisional construction (e.g. lazy initialization of heavy internal resources). </dd></dl>

</div>
</div>
<a id="adb9b3b4c28f20b8aee749bbf9357e09a" name="adb9b3b4c28f20b8aee749bbf9357e09a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb9b3b4c28f20b8aee749bbf9357e09a">&#9670;&#160;</a></span>acquire() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Hash, typename Eq&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; T &gt; <a class="el" href="classjh_1_1conc_1_1pointer__pool.html">jh::conc::pointer_pool</a>&lt; T, Hash, Eq &gt;::acquire </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel delete">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deleted <code><a class="el" href="#adb9b3b4c28f20b8aee749bbf9357e09a" title="Deleted acquire() for const pointer_pool.">acquire()</a></code> for <code>const <a class="el" href="classjh_1_1conc_1_1pointer__pool.html" title="Weak pointer-observed pool for immutable or structurally immutable objects.">pointer_pool</a></code>. </p>
<p>Prevents acquiring or inserting objects through a constant pool reference. Since acquisition may modify the internal pool state, it is not permitted on <code>const</code> instances.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Args</td><td>Constructor argument types for <code>T</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This overload exists purely to provide a compile-time diagnostic when <code><a class="el" href="#adb9b3b4c28f20b8aee749bbf9357e09a" title="Deleted acquire() for const pointer_pool.">acquire()</a></code> is accidentally called on a constant pool reference. Immutable access to existing shared objects should be performed through previously returned <code>std::shared_ptr</code> instances. </dd></dl>

</div>
</div>
<a id="ae6e8404480a354f18da887e75834e86f" name="ae6e8404480a354f18da887e75834e86f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6e8404480a354f18da887e75834e86f">&#9670;&#160;</a></span>capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Hash, typename Eq&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::uint64_t <a class="el" href="classjh_1_1conc_1_1pointer__pool.html">jh::conc::pointer_pool</a>&lt; T, Hash, Eq &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the current reserved size of the pool. </p>
<dl class="section return"><dt>Returns</dt><dd>The reserved size limit before expansion or contraction. </dd></dl>

</div>
</div>
<a id="a2b1d8b83a4d1036c2c2e7a910a5e2385" name="a2b1d8b83a4d1036c2c2e7a910a5e2385"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b1d8b83a4d1036c2c2e7a910a5e2385">&#9670;&#160;</a></span>cleanup()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Hash, typename Eq&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classjh_1_1conc_1_1pointer__pool.html">jh::conc::pointer_pool</a>&lt; T, Hash, Eq &gt;::cleanup </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes expired weak references from the pool. </p>
<p>Scans the internal container and erases all <code>weak_ptr</code> entries that have expired (that is, their corresponding <code>shared_ptr</code> instances have been destroyed). </p>
<p>This operation reclaims hash table slots and prevents unbounded growth when many pooled objects are released. </p>
<dl class="section note"><dt>Note</dt><dd>This function is safe to call at any time and is intended for <b>manual maintenance</b>. Automatic cleanup also occurs opportunistically during insertion or expansion when capacity thresholds are reached. </dd></dl>

</div>
</div>
<a id="ad237f701226e639f0e3eb38a086e11d9" name="ad237f701226e639f0e3eb38a086e11d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad237f701226e639f0e3eb38a086e11d9">&#9670;&#160;</a></span>cleanup_shrink()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Hash, typename Eq&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classjh_1_1conc_1_1pointer__pool.html">jh::conc::pointer_pool</a>&lt; T, Hash, Eq &gt;::cleanup_shrink </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes expired entries and conditionally shrinks the reserved capacity. </p>
<p>Performs the same expired-entry cleanup as <code><a class="el" href="#a2b1d8b83a4d1036c2c2e7a910a5e2385" title="Removes expired weak references from the pool.">cleanup()</a></code>, then evaluates the current usage ratio to determine whether capacity should be reduced.</p>
<p>If the number of active entries falls below <span class="tt">0.25</span> of the current reserved size (the low-watermark ratio), the reserved capacity is reduced to one half of its previous value. The pool will never shrink below <code>MIN_RESERVED_SIZE</code>. </p>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>
Both manual and automatic shrinkage follow the same rule: capacity is reduced by half instead of being minimized to fit the current usage exactly. </li>
<li>
This conservative policy prevents oscillation between expansion and contraction when workload size fluctuates, reducing allocation jitter. </li>
<li>
Since a previously expanded pool indicates historically higher load, shrinking only halfway preserves readiness for future reuse without significant memory overhead. </li>
</ul>
</dd></dl>
<p>This function is intended for <b>manual maintenance</b> when predictable memory release is desired. It complements the automatic, event-driven resizing that may also perform half shrinkage during expansion checks. </p>

</div>
</div>
<a id="aed0de0b67b6d05b5a640231482d77fbc" name="aed0de0b67b6d05b5a640231482d77fbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed0de0b67b6d05b5a640231482d77fbc">&#9670;&#160;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Hash, typename Eq&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classjh_1_1conc_1_1pointer__pool.html">jh::conc::pointer_pool</a>&lt; T, Hash, Eq &gt;::clear </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears all entries and resets the pool to its initial state. </p>
<p>Removes all elements from the internal container and resets <code>capacity_</code> to <code>MIN_RESERVED_SIZE</code>. This operation is functionally equivalent to <code><a class="el" href="#aed0de0b67b6d05b5a640231482d77fbc" title="Clears all entries and resets the pool to its initial state.">clear()</a></code> on standard containers, but is <b>thread-safe</b> and ensures consistent internal state for concurrent environments. </p>
<p>Because the pool only stores <code>weak_ptr</code> references, clearing it merely removes observation records and does not affect the lifetime of externally held <code>shared_ptr</code> instances. For immutable data types, deduplication integrity remains intact. </p>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>
For <b>structurally immutable resource or handle pools</b>, calling <code><a class="el" href="#aed0de0b67b6d05b5a640231482d77fbc" title="Clears all entries and resets the pool to its initial state.">clear()</a></code> is not recommended, as it abandons tracking of active handles and may cause side effects. </li>
<li>
After clearing, <code><a class="el" href="#ae6e8404480a354f18da887e75834e86f" title="Gets the current reserved size of the pool.">capacity()</a></code> is reset to <code>MIN_RESERVED_SIZE</code>, fully restoring the pool to its initial baseline. </li>
<li>
Unlike move operations, which preserve capacity to prevent unnecessary re-expansion, <code><a class="el" href="#aed0de0b67b6d05b5a640231482d77fbc" title="Clears all entries and resets the pool to its initial state.">clear()</a></code> always resets the capacity to its minimum for a deterministic clean state. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a627cc87befae4da634e00507707fe852" name="a627cc87befae4da634e00507707fe852"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a627cc87befae4da634e00507707fe852">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Hash, typename Eq&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a5635484c314767535b158e999f11bb3e">pointer_pool</a> &amp; <a class="el" href="classjh_1_1conc_1_1pointer__pool.html">jh::conc::pointer_pool</a>&lt; T, Hash, Eq &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a5635484c314767535b158e999f11bb3e">pointer_pool</a>&lt; T, Hash, Eq &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel delete">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deleted copy assignment operator. </p>
<p>Copy assignment is not supported for the same reasons as copy construction: duplicating the pool would create two independent observers of the same logical object space, defeating deduplication semantics. </p>

</div>
</div>
<a id="acf375ea05aecc56f1e4bb97e42accf56" name="acf375ea05aecc56f1e4bb97e42accf56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf375ea05aecc56f1e4bb97e42accf56">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Hash, typename Eq&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a5635484c314767535b158e999f11bb3e">pointer_pool</a> &amp; <a class="el" href="classjh_1_1conc_1_1pointer__pool.html">jh::conc::pointer_pool</a>&lt; T, Hash, Eq &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a5635484c314767535b158e999f11bb3e">pointer_pool</a>&lt; T, Hash, Eq &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment operator. </p>
<p>Moves the weak reference set and capacity state from another pool. Both pools are locked during transfer to ensure atomicity.</p>
<dl class="section note"><dt>Note</dt><dd>During move assignment, all existing weak references in the current pool are released and replaced by those from the source pool. This only removes the pool's <em>observation</em> of those objects — their actual lifetimes remain intact because ownership is held by external <code>std::shared_ptr</code> instances. <br  />
 Moving represents transfer of observation scope. Since deduplication is tolerant to transient duplicates, the existence of similar entries in both pools after move is not a correctness issue. The moved-from pool is cleared and remains valid for later reuse.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>For structurally immutable resource or handle pools, move assignment is not semantically appropriate, as such pools are expected to be unique within their management domain. </dd></dl>

</div>
</div>
<a id="a33f91215748a8b26aa66904eef0e1fca" name="a33f91215748a8b26aa66904eef0e1fca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33f91215748a8b26aa66904eef0e1fca">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Hash, typename Eq&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::uint64_t <a class="el" href="classjh_1_1conc_1_1pointer__pool.html">jh::conc::pointer_pool</a>&lt; T, Hash, Eq &gt;::size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the current number of elements in the pool. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of stored weak_ptrs (including expired ones). </dd></dl>

</div>
</div>
<a name="doc-variable-members" id="doc-variable-members"></a><h2 id="header-doc-variable-members" class="groupheader">Member Data Documentation</h2>
<a id="a36de498d501ee194c0327fd3f3c02850" name="a36de498d501ee194c0327fd3f3c02850"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36de498d501ee194c0327fd3f3c02850">&#9670;&#160;</a></span>MIN_RESERVED_SIZE</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Hash, typename Eq&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::uint64_t constexpr <a class="el" href="classjh_1_1conc_1_1pointer__pool.html">jh::conc::pointer_pool</a>&lt; T, Hash, Eq &gt;::MIN_RESERVED_SIZE = 16</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The minimum reserved capacity for the pool. </p>
<p>Defines the lower bound of the adaptive capacity management system. The pool will never shrink below this threshold even when mostly empty, ensuring predictable memory usage and avoiding excessive reallocation.</p>
<dl class="section note"><dt>Note</dt><dd>This value is also used as the default reserve size when constructing a new pool. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/jh/concurrent/<a class="el" href="">pointer_pool.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
</div> <!-- top -->
<hr class="footer"/>
<div class="footer">
    <img class="footer-logo" src="Ojing.svg" alt="Ojing"/>
    <div class="footer-text">
        JH-Toolkit v1.4.0 · Generated by Doxygen
    </div>
    <div class="footer-note">
        We primarily support embedded documentation views in IDEs (classic CLion).
        To ensure compatibility with embedded rendering, some example code in this
        documentation intentionally contains HTML entities.
        In certain cases, Doxygen does not unescape these entities correctly.
        This is a known limitation and currently has no workaround.
    </div>
</div>
</body>
</html>
