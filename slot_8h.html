<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.16.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>JH-Toolkit: include/jh/asynchronous/slot.h File Reference</title>
<link rel="icon" href="Jindallae.svg" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="Oree.svg"/></td>
  <td id="projectalign">
   <div id="projectname">JH-Toolkit<span id="projectnumber">&#160;v1.4.0</span>
   </div>
   <div id="projectbrief">An engineering-oriented C++20 toolkit with duck-typed concepts, static design, async coroutines, and semantic containers — header-only, RTTI-free, and concurrency-friendly.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.16.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('slot_8h.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">slot.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Coroutine-based asynchronous <code>slot</code>/<code>listener</code>/<code>event_signal</code> system with <span class="tt">One-Slot-Per-Hub</span> semantics, multi-listener <span class="tt">fan-in</span>, and user-controlled <span class="tt">fan-out</span> logic inside the <span class="tt">slot</span> coroutine.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;coroutine&gt;</code><br />
<code>#include &lt;optional&gt;</code><br />
<code>#include &lt;mutex&gt;</code><br />
<code>#include &lt;chrono&gt;</code><br />
<code>#include &lt;functional&gt;</code><br />
<code>#include &quot;<a class="el" href="">jh/typed</a>&quot;</code><br />
</div>
<p><a href="">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:jh_3A_3Aasync_3A_3Aslot" id="r_jh_3A_3Aasync_3A_3Aslot"><td class="memItemLeft">class &#160;</td><td class="memItemRight"><a class="el" href="classjh_1_1async_1_1slot.html">jh::async::slot</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Coroutine representing the user-defined asynchronous state machine.  <a href="classjh_1_1async_1_1slot.html#details">More...</a><br /></td></tr>
<tr class="memitem:jh_3A_3Aasync_3A_3Aslot_3A_3Apromise_5Ftype" id="r_jh_3A_3Aasync_3A_3Aslot_3A_3Apromise_5Ftype"><td class="memItemLeft">struct &#160;</td><td class="memItemRight"><a class="el" href="structjh_1_1async_1_1slot_1_1promise__type.html">jh::async::slot::promise_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Slot coroutine promise type.  <a href="structjh_1_1async_1_1slot_1_1promise__type.html#details">More...</a><br /></td></tr>
<tr class="memitem:jh_3A_3Aasync_3A_3Aslot_5Fhub" id="r_jh_3A_3Aasync_3A_3Aslot_5Fhub"><td class="memItemLeft">class &#160;</td><td class="memItemRight"><a class="el" href="classjh_1_1async_1_1slot__hub.html">jh::async::slot_hub</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronization domain managing timed mutex acquisition and binding exactly one slot.  <a href="classjh_1_1async_1_1slot__hub.html#details">More...</a><br /></td></tr>
<tr class="memitem:jh_3A_3Aasync_3A_3Alistener_3C_20T_20_3E" id="r_jh_3A_3Aasync_3A_3Alistener_3C_20T_20_3E"><td class="memItemLeft">class &#160;</td><td class="memItemRight"><a class="el" href="classjh_1_1async_1_1listener.html">jh::async::listener&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A one-shot inbox that serves as the <b>fan-in aggregation point</b>.  <a href="classjh_1_1async_1_1listener.html#details">More...</a><br /></td></tr>
<tr class="memitem:jh_3A_3Aasync_3A_3Aevent_5Fsignal_3C_20T_20_3E" id="r_jh_3A_3Aasync_3A_3Aevent_5Fsignal_3C_20T_20_3E"><td class="memItemLeft">class &#160;</td><td class="memItemRight"><a class="el" href="classjh_1_1async_1_1event__signal.html">jh::async::event_signal&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lightweight push-only event emitter.  <a href="classjh_1_1async_1_1event__signal.html#details">More...</a><br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Coroutine-based asynchronous <code>slot</code>/<code>listener</code>/<code>event_signal</code> system with <span class="tt">One-Slot-Per-Hub</span> semantics, multi-listener <span class="tt">fan-in</span>, and user-controlled <span class="tt">fan-out</span> logic inside the <span class="tt">slot</span> coroutine. </p>
<dl class="section copyright"><dt>Copyright</dt><dd>Copyright 2025 JeongHan-Bae &lt;mastropseudo@gmail.com&gt; <br  />
 Licensed under the Apache License, Version 2.0 (the "License"); <br  />
 you may not use this file except in compliance with the License.<br  />
 You may obtain a copy of the License at<br  />
 <br  />
 <a href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a><br  />
 <br  />
 Unless required by applicable law or agreed to in writing, software<br  />
 distributed under the License is distributed on an "AS IS" BASIS,<br  />
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.<br  />
 See the License for the specific language governing permissions and<br  />
 limitations under the License.<br  />
 <br  />
 Full license: <a href="https://github.com/JeongHan-Bae/JH-Toolkit?tab=Apache-2.0-1-ov-file#readme">GitHub</a></dd></dl>
<dl class="section author"><dt>Author</dt><dd>JeongHan-Bae <a href="#" onclick="location.href='mai'+'lto:'+'mas'+'tr'+'ops'+'eu'+'do@'+'gm'+'ail'+'.c'+'om'; return false;">&lt;mastropseudo@gmail.com&gt;</a> </dd></dl>
<h3>Overview</h3>
<p>This module defines a minimal coroutine-driven event dispatch mechanism. A <code>slot</code> is a coroutine that represents arbitrary user-defined behavior. A <code>listener&lt;T&gt;</code> is an awaitable endpoint that provides values of type <code>T</code> into the <code>slot</code> when an event is emitted. </p>
<p>A <code>slot_hub</code> manages synchronization, timeout behavior, and the <span class="tt">One-to-One</span> binding between the <span class="tt">hub</span> and a single <span class="tt">slot</span> . All listeners created from a <code>slot_hub</code> forward events only to the <code>slot</code> bound to that <code>slot_hub</code>. </p>
<h4>Design Notes</h4>
<ul>
<li>
<b><code>slot_hub</code> ↔ <code>slot</code> is strictly <span class="tt">One-to-One</span>.</b><br  />
 A <code>slot_hub</code> can bind exactly one slot. All listeners made from that <code>slot_hub</code> always deliver values to that same <code>slot</code>. <br  />
 <span class="tt">hub</span> stands for "synchronization domain/kernel," and <span class="tt">slot</span> stands for "unique control coroutine." <br  />
 We allow multiple pairs of <span class="tt">hubs</span> and <span class="tt">slots</span>, but there is a <span class="tt">One-to-One</span> correspondence between <span class="tt">hubs</span> and <span class="tt">slots</span>.  </li>
<li>
<b>One <code>slot</code> → many <code>listener</code>s.</b><br  />
 Multiple <code>listener</code>s are being monitored at different stages or under different conditions. Listening to multiple listeners within the same stage constitutes a synchronization barrier (semantically incorrect).  </li>
<li>
<b>One <code>listener</code> → many <code>event_signal</code>s (fan-in).</b><br  />
 A <code>listeners</code> may be connected to multiple <code>event_signal</code> objects. All <span class="tt">signals</span> write into the same <span class="tt">inbox</span> and attempt to resume the <code>slot</code>. The user can distinguish signal sources by encoding IDs/tags in the payload.  </li>
<li>
<b>No fan-out in <span class="tt">signals</span> — fan-out belongs to the <code>slot</code>.</b><br  />
 <code>event_signal</code> performs only "push to listener". Routing, filtering, branching, switching, multi-stage flow control, and fan-out behavior are entirely user-defined inside the <span class="tt">slot</span> coroutine.  </li>
<li>
<b>Listener <span class="tt">inbox</span> is a one-shot handoff <span class="tt">slot</span> , not a buffer.</b><br  />
 A value is written into the <span class="tt">inbox</span> only if the <code>listener</code> succeeds in acquiring the hub's mutex within the timeout window. Once written, the <code>slot</code> is resumed immediately, consumes the value during <code>await_resume()</code>, and the inbox is cleared. <br  />
 Because the write and the <span class="tt">slot</span> resumption occur while holding the same lock, the inbox is <b>never</b> overwritten, <b>never</b> accumulates unread entries, and <b>never</b> loses values due to replacement. If the lock cannot be acquired, <b>nothing</b> is written at all. <br  />
 This implements a high-pressure fuse: either the event is <b>fully delivered</b> <pre>write → resume → consume → clear</pre> or <b>not delivered</b> at all.  </li>
<li>
<b><code>spawn()</code> binds the <code>slot</code> to the calling thread.</b><br  />
 After <code>spawn()</code>, all event-triggered resumes occur on that same thread.  </li>
<li>
<b>Unified lifetime.</b><br  />
 <code>slot</code>, <code>slot_hub</code>, and all <code>listener</code>s are expected to share the same lifetime. Moving a <code>slot</code> after binding/spawn may break this constraint and <b>must be avoided</b>. <code>event_signal</code> must not outlive its mapped <code>listener</code>.  </li>
</ul>
<h4>Usage Model</h4>
<p>The usage pattern is conceptually divided into two independent parts. Each part has its own internal ordering constraints, while the two parts themselves do not impose ordering constraints on each other. </p>
<h5>Part 1 — Infrastructure Construction</h5>
<p>These steps must occur in the following order: </p>
<ol>
<li>
Create a <code>slot_hub</code>. </li>
<li>
Create one or more <code>listener</code>s from the hub. </li>
<li>
Create a <span class="tt">slot</span> coroutine that observes these <code>listener</code>s. </li>
<li>
Bind the <code>slot</code> to the <span class="tt">hub</span> via <code>bind_slot()</code>. </li>
<li>
Call <code>spawn()</code> to start the coroutine and bind it to the calling thread. </li>
</ol>
<h5>Part 2 — Event Binding and Dispatching</h5>
<ol>
<li>
A <code>listener</code> must already exist before connecting <code>event_signal</code>s to it. </li>
<li>
<code>event_signal::connect(listener*)</code> must be called before the first <code>emit()</code> targeting that listener. </li>
<li>
<code>emit()</code> should be called after <code>slot.spawn()</code> was called. </li>
</ol>
<p>Advanced patterns (multi-signal, switching, state machines, routing, phase transitions, conditional awaits) are implemented entirely in the <span class="tt">slot</span> coroutine. The library provides only the suspension/resume primitives. </p>
<h4>Mechanics of Slot Coroutines</h4>
<ol>
<li>
The <code>slot</code> is created and suspended at <code>initial_suspend()</code>. </li>
<li>
The <code>slot_hub</code> binds exactly one <code>slot</code>; <code>listener</code>s use this binding. </li>
<li>
<code>spawn()</code> resumes the coroutine for the first time. </li>
<li>
<code>co_await listener</code> suspends the coroutine and registers its handle. </li>
<li>
An <code>event_signal</code> writes into the listener <span class="tt">inbox</span> and resumes the <code>slot</code> after acquiring the hub's timed mutex.  </li>
<li>
<code>co_yield {}</code> yields a <code>monostate</code> and resumes execution immediately — useful for deterministic scheduling points.  </li>
<li>
Normal completion enters <code>final_suspend()</code>. </li>
</ol>
<h4>Queuing and Backpressure</h4>
<p>Traditional Buffer Queues are presenting a synchronous mechanism, not an asynchronous one, which is why we reject them. <br  />
 <code>std::timed_mutex</code> is essentially a timed queuing aid with timeout (overpressure) circuit breaking to ensure that emit is invoked according to the order of calls. <br  />
 </p><table class="doxtable">
<tr>
<th>Aspect</th><th>Lock Queues</th><th>Buffer Queues</th></tr>
<tr>
<td>Data Buffering</td><td><b>No</b> — values are written only if the lock is acquired; at most one in-flight value</td><td><b>Yes</b> — values are enqueued and buffered until consumed</td></tr>
<tr>
<td>Queuing Mechanism</td><td><b>FIFO lock waiters</b> — emitters are queued implicitly via the mutex</td><td><b>Explicit data queue</b> — typically implemented via ring buffer or linked list</td></tr>
<tr>
<td>Overflow Control</td><td><b>Timeout</b> — emit is rejected if lock cannot be acquired in time</td><td><b>Unbounded or bounded buffer</b> — may require manual pressure control</td></tr>
<tr>
<td>Resume Semantics</td><td><b>Inline</b> — <span class="tt">slot</span> is resumed immediately after value is written</td><td><b>Out-of-band</b> — consumer must poll or wait</td></tr>
<tr>
<td>Synchronization Role</td><td><b>Integral</b> — part of the event delivery protocol</td><td><b>Separate</b> — often requires condition variables or manual signaling</td></tr>
<tr>
<td>Fan-in Behavior</td><td><b>Yes</b> — multiple signals may target a single listener via mutex arbitration</td><td><b>Possible</b> — but usually requires a multiplexer</td></tr>
<tr>
<td>Fan-out Support</td><td><b>No</b> — deliberate omission; routing is done inside slot</td><td><b>Optional</b> — may push to multiple consumers</td></tr>
</table>
<h4>Important Constraints</h4>
<ul>
<li>
<code>slot_hub</code> may bind only one <code>slot</code>. </li>
<li>
<code>event_signal</code> must not outlive the <code>listener</code> it is connected to. </li>
<li>
<code>slot</code>, <code>slot_hub</code>, and <code>listener</code>s must share the same overall lifetime. </li>
<li>
<code>slot</code> alone is responsible for any fan-out or complex routing logic. </li>
</ul>
<h4>Example Usage</h4>
<div class="fragment"><div class="line"><a class="code hl_class" href="classjh_1_1async_1_1slot__hub.html">jh::async::slot_hub</a> hub(std::chrono::milliseconds(TIMEOUT_MS));</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> make_slot = [...](<a class="code hl_class" href="classjh_1_1async_1_1listener.html">jh::async::listener&lt;T&gt;</a> &amp;li, ...) -&gt; <a class="code hl_class" href="classjh_1_1async_1_1slot.html">jh::async::slot</a> {</div>
<div class="line">    <span class="keywordflow">for</span> (;;) {</div>
<div class="line">        <span class="keyword">auto</span> v1 = <span class="keyword">co_await</span> li;</div>
<div class="line">        ...</div>
<div class="line">        <span class="keyword">co_yield</span> {};</div>
<div class="line">    }</div>
<div class="line">    ...</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> listener1 = hub.make_listener&lt;T&gt;();</div>
<div class="line"><a class="code hl_class" href="classjh_1_1async_1_1event__signal.html">jh::async::event_signal&lt;T&gt;</a> sig1;</div>
<div class="line">sig1.<a class="code hl_function" href="classjh_1_1async_1_1event__signal.html#a7473c88ed2c92403c5b513282522fdd1">connect</a>(&amp;listener1);</div>
<div class="line"><a class="code hl_class" href="classjh_1_1async_1_1slot.html">jh::async::slot</a> s = make_slot(listener1, ...);</div>
<div class="line">hub.bind_slot(s);</div>
<div class="line"> </div>
<div class="line">s.<a class="code hl_function" href="classjh_1_1async_1_1slot.html#a573f3725cbe0f3ea772b3baf16e92d14">spawn</a>();</div>
<div class="line"><span class="comment">// now, emitting events will resume the &lt;tt&gt;slot&lt;/tt&gt; coroutine</span></div>
<div class="ttc" id="aclassjh_1_1async_1_1event__signal_html"><div class="ttname"><a href="classjh_1_1async_1_1event__signal.html">jh::async::event_signal</a></div><div class="ttdoc">Lightweight push-only event emitter.</div><div class="ttdef"><b>Definition</b> slot.h:672</div></div>
<div class="ttc" id="aclassjh_1_1async_1_1event__signal_html_a7473c88ed2c92403c5b513282522fdd1"><div class="ttname"><a href="classjh_1_1async_1_1event__signal.html#a7473c88ed2c92403c5b513282522fdd1">jh::async::event_signal::connect</a></div><div class="ttdeci">void connect(listener&lt; T &gt; *l) noexcept</div><div class="ttdoc">Connect this signal to a listener.</div><div class="ttdef"><b>Definition</b> slot.h:680</div></div>
<div class="ttc" id="aclassjh_1_1async_1_1listener_html"><div class="ttname"><a href="classjh_1_1async_1_1listener.html">jh::async::listener</a></div><div class="ttdoc">A one-shot inbox that serves as the fan-in aggregation point.</div><div class="ttdef"><b>Definition</b> slot.h:563</div></div>
<div class="ttc" id="aclassjh_1_1async_1_1slot__hub_html"><div class="ttname"><a href="classjh_1_1async_1_1slot__hub.html">jh::async::slot_hub</a></div><div class="ttdoc">Synchronization domain managing timed mutex acquisition and binding exactly one slot.</div><div class="ttdef"><b>Definition</b> slot.h:457</div></div>
<div class="ttc" id="aclassjh_1_1async_1_1slot_html"><div class="ttname"><a href="classjh_1_1async_1_1slot.html">jh::async::slot</a></div><div class="ttdoc">Coroutine representing the user-defined asynchronous state machine.</div><div class="ttdef"><b>Definition</b> slot.h:334</div></div>
<div class="ttc" id="aclassjh_1_1async_1_1slot_html_a573f3725cbe0f3ea772b3baf16e92d14"><div class="ttname"><a href="classjh_1_1async_1_1slot.html#a573f3725cbe0f3ea772b3baf16e92d14">jh::async::slot::spawn</a></div><div class="ttdeci">void spawn()</div><div class="ttdoc">Start the coroutine associated with this slot.</div><div class="ttdef"><b>Definition</b> slot.h:367</div></div>
</div><!-- fragment --><dl class="section version"><dt>Version</dt><dd><pre>1.4.x</pre> </dd></dl>
<dl class="section date"><dt>Date</dt><dd><pre>2025</pre> </dd></dl>
</div></div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
</div> <!-- top -->
<hr class="footer"/>
<div class="footer">
    <img class="footer-logo" src="Ojing.svg" alt="Ojing"/>
    <div class="footer-text">
        JH-Toolkit v1.4.0 · Generated by Doxygen
    </div>
    <div class="footer-note">
        We primarily support embedded documentation views in IDEs (classic CLion).
        To ensure compatibility with embedded rendering, some example code in this
        documentation intentionally contains HTML entities.
        In certain cases, Doxygen does not unescape these entities correctly.
        This is a known limitation and currently has no workaround.
    </div>
</div>
</body>
</html>
