<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.16.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>JH-Toolkit: jh::sync::ipc::process_mutex&lt; S, HighPriv &gt; Class Template Reference</title>
<link rel="icon" href="Jindallae.svg" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="Oree.svg"/></td>
  <td id="projectalign">
   <div id="projectname">JH-Toolkit<span id="projectnumber">&#160;v1.4.0</span>
   </div>
   <div id="projectbrief">An engineering-oriented C++20 toolkit with duck-typed concepts, static design, async coroutines, and semantic containers — header-only, RTTI-free, and concurrency-friendly.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.16.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('classjh_1_1sync_1_1ipc_1_1process__mutex.html','','classjh_1_1sync_1_1ipc_1_1process__mutex-members'); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">jh::sync::ipc::process_mutex&lt; S, HighPriv &gt; Class Template Reference<span class="mlabels"><span class="mlabel final">final</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>Cross-platform named process-wide mutex primitive.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="">jh/synchronous/ipc/process_mutex.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a68e0930d4403060a6003dd819fe8aa60" id="r_a68e0930d4403060a6003dd819fe8aa60"><td class="memItemLeft"><a id="a68e0930d4403060a6003dd819fe8aa60" name="a68e0930d4403060a6003dd819fe8aa60"></a>
&#160;</td><td class="memItemRight"><b>process_mutex</b> (const process_mutex &amp;)=delete</td></tr>
<tr class="memdesc:a68e0930d4403060a6003dd819fe8aa60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deleted copy constructor. <br /></td></tr>
<tr class="memitem:a3dfd6340f8061aa6471783c573c921dc" id="r_a3dfd6340f8061aa6471783c573c921dc"><td class="memItemLeft"><a id="a3dfd6340f8061aa6471783c573c921dc" name="a3dfd6340f8061aa6471783c573c921dc"></a>
<a class="el" href="#a68e0930d4403060a6003dd819fe8aa60">process_mutex</a> &amp;&#160;</td><td class="memItemRight"><b>operator=</b> (const <a class="el" href="#a68e0930d4403060a6003dd819fe8aa60">process_mutex</a> &amp;)=delete</td></tr>
<tr class="memdesc:a3dfd6340f8061aa6471783c573c921dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deleted copy assignment. <br /></td></tr>
<tr class="memitem:af2c1fec097dfb7f0b74c45a85621fa85" id="r_af2c1fec097dfb7f0b74c45a85621fa85"><td class="memItemLeft"><a id="af2c1fec097dfb7f0b74c45a85621fa85" name="af2c1fec097dfb7f0b74c45a85621fa85"></a>
&#160;</td><td class="memItemRight"><b>process_mutex</b> (process_mutex &amp;&amp;)=delete</td></tr>
<tr class="memdesc:af2c1fec097dfb7f0b74c45a85621fa85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deleted move constructor. <br /></td></tr>
<tr class="memitem:a2cb970cfbd5dde10d4d2e99b0258d152" id="r_a2cb970cfbd5dde10d4d2e99b0258d152"><td class="memItemLeft"><a id="a2cb970cfbd5dde10d4d2e99b0258d152" name="a2cb970cfbd5dde10d4d2e99b0258d152"></a>
<a class="el" href="#a68e0930d4403060a6003dd819fe8aa60">process_mutex</a> &amp;&#160;</td><td class="memItemRight"><b>operator=</b> (<a class="el" href="#a68e0930d4403060a6003dd819fe8aa60">process_mutex</a> &amp;&amp;)=delete</td></tr>
<tr class="memdesc:a2cb970cfbd5dde10d4d2e99b0258d152"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deleted move assignment. <br /></td></tr>
<tr class="memitem:aa84a480ab52ea3008c8593669109409c" id="r_aa84a480ab52ea3008c8593669109409c"><td class="memItemLeft">void&#160;</td><td class="memItemRight"><a class="el" href="#aa84a480ab52ea3008c8593669109409c">lock</a> ()</td></tr>
<tr class="memdesc:aa84a480ab52ea3008c8593669109409c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquire the lock (blocking).  <br /></td></tr>
<tr class="memitem:af28c48a74f1d459a02257bd6e2d74864" id="r_af28c48a74f1d459a02257bd6e2d74864"><td class="memItemLeft"><a id="af28c48a74f1d459a02257bd6e2d74864" name="af28c48a74f1d459a02257bd6e2d74864"></a>
bool&#160;</td><td class="memItemRight"><b>try_lock</b> ()</td></tr>
<tr class="memdesc:af28c48a74f1d459a02257bd6e2d74864"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try acquire without blocking. <br /></td></tr>
<tr class="memitem:a72ebd0c74163f6c13bb2997d4804d673" id="r_a72ebd0c74163f6c13bb2997d4804d673"><td class="memTemplParams" colspan="2">template&lt;typename Rep, typename Period&gt; </td></tr>
<tr class="memitem:a72ebd0c74163f6c13bb2997d4804d673 template"><td class="memItemLeft">bool&#160;</td><td class="memItemRight"><a class="el" href="#a72ebd0c74163f6c13bb2997d4804d673">try_lock_for</a> (const std::chrono::duration&lt; Rep, Period &gt; &amp;d)</td></tr>
<tr class="memdesc:a72ebd0c74163f6c13bb2997d4804d673"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to acquire the lock, waiting for a maximum duration.  <br /></td></tr>
<tr class="memitem:a182f097e4b01d83323d301b6bef639bd" id="r_a182f097e4b01d83323d301b6bef639bd"><td class="memTemplParams" colspan="2">template&lt;typename Clock, typename Duration&gt; </td></tr>
<tr class="memitem:a182f097e4b01d83323d301b6bef639bd template"><td class="memItemLeft">bool&#160;</td><td class="memItemRight"><a class="el" href="#a182f097e4b01d83323d301b6bef639bd">try_lock_until</a> (const std::chrono::time_point&lt; Clock, Duration &gt; &amp;tp)</td></tr>
<tr class="memdesc:a182f097e4b01d83323d301b6bef639bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to acquire the lock until an absolute time point.  <br /></td></tr>
<tr class="memitem:abf5aed569e12eeee88eda44a50319395" id="r_abf5aed569e12eeee88eda44a50319395"><td class="memItemLeft">void&#160;</td><td class="memItemRight"><a class="el" href="#abf5aed569e12eeee88eda44a50319395">unlock</a> ()</td></tr>
<tr class="memdesc:abf5aed569e12eeee88eda44a50319395"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release the lock.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-static-methods" class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a22daf18e7bf3cb7e92a4d8dc41cbf4f4" id="r_a22daf18e7bf3cb7e92a4d8dc41cbf4f4"><td class="memItemLeft"><a id="a22daf18e7bf3cb7e92a4d8dc41cbf4f4" name="a22daf18e7bf3cb7e92a4d8dc41cbf4f4"></a>
static constexpr const char *&#160;</td><td class="memItemRight"><b>name</b> () noexcept</td></tr>
<tr class="memdesc:a22daf18e7bf3cb7e92a4d8dc41cbf4f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get OS-visible name. <br /></td></tr>
<tr class="memitem:a29e3b62b48f803ab81f9cafa5a4f7f3c" id="r_a29e3b62b48f803ab81f9cafa5a4f7f3c"><td class="memItemLeft"><a id="a29e3b62b48f803ab81f9cafa5a4f7f3c" name="a29e3b62b48f803ab81f9cafa5a4f7f3c"></a>
static <a class="el" href="#a68e0930d4403060a6003dd819fe8aa60">process_mutex</a> &amp;&#160;</td><td class="memItemRight"><b>instance</b> ()</td></tr>
<tr class="memdesc:a29e3b62b48f803ab81f9cafa5a4f7f3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Singleton instance. <br /></td></tr>
<tr class="memitem:aeb148339b1070c848afc5bd37cde040e" id="r_aeb148339b1070c848afc5bd37cde040e"><td class="memItemLeft">static void&#160;</td><td class="memItemRight"><a class="el" href="#aeb148339b1070c848afc5bd37cde040e">unlink</a> ()</td></tr>
<tr class="memdesc:aeb148339b1070c848afc5bd37cde040e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the semaphore name from the namespace (POSIX only).  <br /></td></tr>
<tr class="memitem:a268ecf17c57b7bceff844a4c36eb86b0" id="r_a268ecf17c57b7bceff844a4c36eb86b0"><td class="memItemLeft"><a id="a268ecf17c57b7bceff844a4c36eb86b0" name="a268ecf17c57b7bceff844a4c36eb86b0"></a>
static void&#160;</td><td class="memItemRight"><b>unlink</b> ()=delete</td></tr>
<tr class="memdesc:a268ecf17c57b7bceff844a4c36eb86b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disabled if HighPriv == false. Non-privileged mutexes cannot call <a class="el" href="#aeb148339b1070c848afc5bd37cde040e" title="Remove the semaphore name from the namespace (POSIX only).">unlink()</a>. <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;jh::meta::TStr S, bool HighPriv = false&gt;<br />
requires (<a class="el" href="namespacejh_1_1sync_1_1ipc_1_1limits.html#ac9d6d7cefc59eb289082b37bca1603b9">limits::valid_object_name</a>&lt;S, limits::max_name_length&gt;())<br />
class jh::sync::ipc::process_mutex&lt; S, HighPriv &gt;</div><p>Cross-platform named process-wide mutex primitive. </p>
<h4>Overview</h4>
<p><code><a class="el" href="classjh_1_1sync_1_1ipc_1_1process__mutex.html" title="Cross-platform named process-wide mutex primitive.">jh::sync::ipc::process_mutex</a></code> is a low-level inter-process synchronization primitive that mirrors the behavior of <code>std::timed_mutex</code>, extended to operate across process boundaries via OS-level named semaphores. Each unique template literal <code>S</code> defines a globally visible named mutex. </p>
<h4>Semantic model</h4>
<ul>
<li>
Acts as an <b>IPC primitive</b> — not a composition of higher-level constructs. </li>
<li>
Provides the same contract as <code>std::timed_mutex</code>: <ul>
<li>
Exclusive ownership semantics (single holder at a time). </li>
<li>
Non-recursive — attempting to lock twice without unlocking causes deadlock. </li>
<li>
Unlocking without ownership or multiple consecutive unlocks is <b>undefined behavior</b>. </li>
</ul>
</li>
<li>
Integrates with RAII-style locking utilities such as <code>std::lock_guard</code>, <code>std::unique_lock</code>, or equivalent user-defined wrappers. </li>
<li>
Supports <code><a class="el" href="#af28c48a74f1d459a02257bd6e2d74864" title="Try acquire without blocking.">try_lock()</a></code>, <code><a class="el" href="#a72ebd0c74163f6c13bb2997d4804d673" title="Attempt to acquire the lock, waiting for a maximum duration.">try_lock_for()</a></code>, and <code><a class="el" href="#a182f097e4b01d83323d301b6bef639bd" title="Attempt to acquire the lock until an absolute time point.">try_lock_until()</a></code> for timed acquisition. </li>
</ul>
<p><b>Cross-platform behavior</b> </p><ul>
<li>
<b>POSIX</b>: implemented via <code>sem_open()</code>, <code>sem_wait()</code>, and <code>sem_post()</code>. </li>
<li>
<b>Windows / MSYS2</b>: implemented via <code>CreateSemaphore()</code> and <code>WaitForSingleObject()</code>. </li>
<li>
All standard privilege levels are sufficient; administrative rights are <b>not</b> required. </li>
</ul>
<h4>Error and UB conditions</h4>
<ul>
<li>
Calling <code><a class="el" href="#abf5aed569e12eeee88eda44a50319395" title="Release the lock.">unlock()</a></code> without owning the mutex, or calling it multiple times, is undefined behavior. </li>
<li>
Calling <code><a class="el" href="#aa84a480ab52ea3008c8593669109409c" title="Acquire the lock (blocking).">lock()</a></code> twice without an intervening <code><a class="el" href="#abf5aed569e12eeee88eda44a50319395" title="Release the lock.">unlock()</a></code> causes deadlock. </li>
<li>
POSIX may silently ignore double-unlock; Windows may terminate the process. </li>
</ul>
<h4>Usage recommendation</h4>
<p>Use RAII-style management whenever possible: </p><div class="fragment"><div class="line"><span class="keyword">auto</span>&amp; m = <a class="code hl_class" href="classjh_1_1sync_1_1ipc_1_1process__mutex.html">jh::sync::ipc::process_mutex</a>&lt;<span class="stringliteral">&quot;example&quot;</span>&gt;<a class="code hl_function" href="#a29e3b62b48f803ab81f9cafa5a4f7f3c">::instance</a>();</div>
<div class="line">std::lock_guard guard(m); <span class="comment">// automatically unlocks on scope exit</span></div>
<div class="ttc" id="aclassjh_1_1sync_1_1ipc_1_1process__mutex_html"><div class="ttname"><a href="classjh_1_1sync_1_1ipc_1_1process__mutex.html">jh::sync::ipc::process_mutex</a></div><div class="ttdoc">Cross-platform named process-wide mutex primitive.</div><div class="ttdef"><b>Definition</b> process_mutex.h:218</div></div>
<div class="ttc" id="aclassjh_1_1sync_1_1ipc_1_1process__mutex_html_a29e3b62b48f803ab81f9cafa5a4f7f3c"><div class="ttname"><a href="#a29e3b62b48f803ab81f9cafa5a4f7f3c">jh::sync::ipc::process_mutex::instance</a></div><div class="ttdeci">static process_mutex &amp; instance()</div><div class="ttdoc">Singleton instance.</div><div class="ttdef"><b>Definition</b> process_mutex.h:233</div></div>
</div><!-- fragment --> <p>This ensures exception safety and correct pairing of <code><a class="el" href="#aa84a480ab52ea3008c8593669109409c" title="Acquire the lock (blocking).">lock()</a></code>/<code><a class="el" href="#abf5aed569e12eeee88eda44a50319395" title="Release the lock.">unlock()</a></code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">S</td><td>Bare name string (letters, digits, dot, dash, underscore). </td></tr>
    <tr><td class="paramname">HighPriv</td><td>If true, exposes <code><a class="el" href="#aeb148339b1070c848afc5bd37cde040e" title="Remove the semaphore name from the namespace (POSIX only).">unlink()</a></code> for POSIX. </td></tr>
  </table>
  </dd>
</dl>
</div><a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="aa84a480ab52ea3008c8593669109409c" name="aa84a480ab52ea3008c8593669109409c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa84a480ab52ea3008c8593669109409c">&#9670;&#160;</a></span>lock()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;jh::meta::TStr S, bool HighPriv = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classjh_1_1sync_1_1ipc_1_1process__mutex.html">jh::sync::ipc::process_mutex</a>&lt; S, HighPriv &gt;::lock </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Acquire the lock (blocking). </p>
<h4>Semantics</h4>
<p>Blocks the calling thread or process until the mutex becomes available. Once acquired, the caller obtains exclusive ownership of the process-wide synchronization primitive. </p>
<h4>Reentrancy</h4>
<p>This mutex is <b>non-recursive</b>. Calling <code><a class="el" href="#aa84a480ab52ea3008c8593669109409c" title="Acquire the lock (blocking).">lock()</a></code> twice from the same thread or process without a corresponding <code><a class="el" href="#abf5aed569e12eeee88eda44a50319395" title="Release the lock.">unlock()</a></code> causes a <b>self-deadlock</b>, identical to the behavior of <code>std::timed_mutex</code>. </p>
<h4>Contract</h4>
<ul>
<li>
Each <code><a class="el" href="#aa84a480ab52ea3008c8593669109409c" title="Acquire the lock (blocking).">lock()</a></code> call must eventually be paired with <code><a class="el" href="#abf5aed569e12eeee88eda44a50319395" title="Release the lock.">unlock()</a></code>. </li>
<li>
Re-locking a held mutex results in deadlock. </li>
<li>
Unlocking without ownership is undefined behavior. </li>
</ul>
<h4>Usage recommendation</h4>
<p>When using <code><a class="el" href="classjh_1_1sync_1_1ipc_1_1process__mutex.html" title="Cross-platform named process-wide mutex primitive.">process_mutex</a></code> within a lexical scope, prefer RAII-style management with <code>std::lock_guard</code> or an equivalent wrapper to ensure exception-safe unlock. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the underlying system call fails unexpectedly. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a72ebd0c74163f6c13bb2997d4804d673" name="a72ebd0c74163f6c13bb2997d4804d673"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72ebd0c74163f6c13bb2997d4804d673">&#9670;&#160;</a></span>try_lock_for()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;jh::meta::TStr S, bool HighPriv = false&gt; </div>
<div class="memtemplate">
template&lt;typename Rep, typename Period&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classjh_1_1sync_1_1ipc_1_1process__mutex.html">jh::sync::ipc::process_mutex</a>&lt; S, HighPriv &gt;::try_lock_for </td>
          <td>(</td>
          <td class="paramtype">const std::chrono::duration&lt; Rep, Period &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>d</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempt to acquire the lock, waiting for a maximum duration. </p>
<p>On Windows, this maps to <code>WaitForSingleObject</code> with a bounded timeout. On POSIX systems with the <b>Realtime Extension (POSIX.1b)</b> (e.g. Linux/glibc), this maps to <code>sem_timedwait</code>. On pure POSIX systems without the extension (e.g. Darwin, BSD), timed waiting is emulated with <b>sem_trywait + exponential backoff sleep</b>, which approximates the same semantics while avoiding busy spinning.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Rep</td><td>Representation type of duration. </td></tr>
    <tr><td class="paramname">Period</td><td>Period type of duration. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>Duration to wait. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if lock acquired, <b>false</b> if timed out. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the underlying system call fails unexpectedly.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>See <code>try_lock_until</code> for details. </dd></dl>

</div>
</div>
<a id="a182f097e4b01d83323d301b6bef639bd" name="a182f097e4b01d83323d301b6bef639bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a182f097e4b01d83323d301b6bef639bd">&#9670;&#160;</a></span>try_lock_until()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;jh::meta::TStr S, bool HighPriv = false&gt; </div>
<div class="memtemplate">
template&lt;typename Clock, typename Duration&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classjh_1_1sync_1_1ipc_1_1process__mutex.html">jh::sync::ipc::process_mutex</a>&lt; S, HighPriv &gt;::try_lock_until </td>
          <td>(</td>
          <td class="paramtype">const std::chrono::time_point&lt; Clock, Duration &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>tp</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempt to acquire the lock until an absolute time point. </p>
<p>Windows uses <code>WaitForSingleObject</code> with a computed relative timeout. POSIX with the <b>Realtime Extension (POSIX.1b)</b> (e.g. Linux/glibc) uses <code>sem_timedwait</code> with an absolute <code>timespec</code>. Pure POSIX systems without the extension (e.g. Darwin, BSD) emulate timed waiting via <b>sem_trywait + exponential backoff sleep</b>, preserving observable semantics (success/timeout) without excessive CPU usage.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Clock</td><td>Clock type. </td></tr>
    <tr><td class="paramname">Duration</td><td>Duration type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tp</td><td>Absolute time point at which the attempt should time out. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if lock acquired, <b>false</b> if timed out. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the underlying system call fails unexpectedly.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Backoff is doubled each iteration, capped at 5 ms, to balance responsiveness and CPU usage. </dd></dl>

</div>
</div>
<a id="aeb148339b1070c848afc5bd37cde040e" name="aeb148339b1070c848afc5bd37cde040e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb148339b1070c848afc5bd37cde040e">&#9670;&#160;</a></span>unlink()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;jh::meta::TStr S, bool HighPriv = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classjh_1_1sync_1_1ipc_1_1process__mutex.html">jh::sync::ipc::process_mutex</a>&lt; S, HighPriv &gt;::unlink </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove the semaphore name from the namespace (POSIX only). </p>
<h4>Semantics</h4>
<ul>
<li>
On POSIX systems, this calls <code>sem_unlink()</code> with the internally constructed name. </li>
<li>
If the semaphore exists and is successfully unlinked: <ul>
<li>
The name is removed immediately from the namespace. </li>
<li>
Existing open handles (in this or other processes) remain valid until they are closed via <code>sem_close()</code>. </li>
<li>
The semaphore object is destroyed only when the last handle closes. </li>
</ul>
</li>
<li>
If the semaphore name does not exist (<code>errno == ENOENT</code>): the call is silently ignored. No exception is thrown. </li>
<li>
If <code>sem_unlink()</code> fails for any other reason (e.g. permissions, resource errors), an exception is thrown. </li>
</ul>
<h4>Idempotency</h4>
<p>This operation is explicitly <b>idempotent</b>: calling <code><a class="el" href="#aeb148339b1070c848afc5bd37cde040e" title="Remove the semaphore name from the namespace (POSIX only).">unlink()</a></code> multiple times is safe. Once the semaphore is removed, subsequent calls are treated as no-ops. </p>
<h4>Windows</h4>
<p>On Windows / MSYS2, there is no unlink concept. Named semaphores are automatically destroyed by the OS when the last handle is closed. </p>

</div>
</div>
<a id="abf5aed569e12eeee88eda44a50319395" name="abf5aed569e12eeee88eda44a50319395"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf5aed569e12eeee88eda44a50319395">&#9670;&#160;</a></span>unlock()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;jh::meta::TStr S, bool HighPriv = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classjh_1_1sync_1_1ipc_1_1process__mutex.html">jh::sync::ipc::process_mutex</a>&lt; S, HighPriv &gt;::unlock </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Release the lock. </p>
<h4>Semantics</h4>
<p>Releases ownership of the process-wide mutex. This operation must only be called by a participant that currently holds the lock; calling <code><a class="el" href="#abf5aed569e12eeee88eda44a50319395" title="Release the lock.">unlock()</a></code> without prior ownership or invoking it multiple times consecutively constitutes <b>undefined behavior</b>. </p>
<h4>Error model</h4>
<ul>
<li>
On POSIX systems, improper unlocking may silently fail or leave the semaphore count inconsistent. </li>
<li>
On Windows, calling <code>ReleaseSemaphore()</code> from a thread that does not own the lock may raise a runtime error or terminate the process. </li>
</ul>
<h4>Contract</h4>
<ul>
<li>
The caller is responsible for ensuring lock ownership before calling <code><a class="el" href="#abf5aed569e12eeee88eda44a50319395" title="Release the lock.">unlock()</a></code>. </li>
<li>
Repeated unlocking or unlocking without acquisition is <b>UB</b>. </li>
<li>
If required, ownership can be tracked manually (e.g. via <code>thread_local</code> flags or process-scoped state) depending on usage scope. </li>
</ul>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the underlying system call fails unexpectedly. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/jh/synchronous/ipc/<a class="el" href="">process_mutex.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
</div> <!-- top -->
<hr class="footer"/>
<div class="footer">
    <img class="footer-logo" src="Ojing.svg" alt="Ojing"/>
    <div class="footer-text">
        JH-Toolkit v1.4.0 · Generated by Doxygen
    </div>
    <div class="footer-note">
        We primarily support embedded documentation views in IDEs (classic CLion).
        To ensure compatibility with embedded rendering, some example code in this
        documentation intentionally contains HTML entities.
        In certain cases, Doxygen does not unescape these entities correctly.
        This is a known limitation and currently has no workaround.
    </div>
</div>
</body>
</html>
