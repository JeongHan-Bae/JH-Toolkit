<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.16.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>JH-Toolkit: jh::conc::flat_pool&lt; Key, Value, Hash, Alloc &gt; Class Template Reference</title>
<link rel="icon" href="Jindallae.svg" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="Oree.svg"/></td>
  <td id="projectalign">
   <div id="projectname">JH-Toolkit<span id="projectnumber">&#160;v1.4.0</span>
   </div>
   <div id="projectbrief">An engineering-oriented C++20 toolkit with duck-typed concepts, static design, async coroutines, and semantic containers â€” header-only, RTTI-free, and concurrency-friendly.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.16.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('classjh_1_1conc_1_1flat__pool.html','','classjh_1_1conc_1_1flat__pool-members'); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">jh::conc::flat_pool&lt; Key, Value, Hash, Alloc &gt; Class Template Reference<span class="mlabels"><span class="mlabel final">final</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>Hash-ordered, contiguous resource interning pool.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="">jh/concurrent/flat_pool.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:ptr" id="r_ptr"><td class="memItemLeft">struct &#160;</td><td class="memItemRight"><a class="el" href="structjh_1_1conc_1_1flat__pool_1_1ptr.html">ptr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference-counted handle to a pooled object.  <a href="structjh_1_1conc_1_1flat__pool_1_1ptr.html#details">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-types" class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:af79c6502a669200bc37add1249f187a0" id="r_af79c6502a669200bc37add1249f187a0"><td class="memItemLeft"><a id="af79c6502a669200bc37add1249f187a0" name="af79c6502a669200bc37add1249f187a0"></a>
using&#160;</td><td class="memItemRight"><b>value_type</b> = detail::value_t&lt;Key, Value&gt;</td></tr>
<tr class="memdesc:af79c6502a669200bc37add1249f187a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stored element type (<code>Key</code> or <code>std::pair&lt;Key, Value&gt;</code>). <br /></td></tr>
<tr class="memitem:a7880488593a6eefda26adb44b149f9fc" id="r_a7880488593a6eefda26adb44b149f9fc"><td class="memItemLeft">using&#160;</td><td class="memItemRight"><a class="el" href="#a7880488593a6eefda26adb44b149f9fc">allocator_type</a></td></tr>
<tr class="memdesc:a7880488593a6eefda26adb44b149f9fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocator rebound for value <code>storage_</code> only.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac32d8a004ad7a4d8ee9081a0349999e2" id="r_ac32d8a004ad7a4d8ee9081a0349999e2"><td class="memItemLeft">&#160;</td><td class="memItemRight"><a class="el" href="#ac32d8a004ad7a4d8ee9081a0349999e2">flat_pool</a> (std::uint64_t reserve_size=<a class="el" href="#aa7b703e74ffc8eabccc65468e1ef0c14">MIN_RESERVED_SIZE</a>)</td></tr>
<tr class="memdesc:ac32d8a004ad7a4d8ee9081a0349999e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <a class="el" href="classjh_1_1conc_1_1flat__pool.html" title="Hash-ordered, contiguous resource interning pool.">flat_pool</a> with pre-reserved contiguous storage.  <br /></td></tr>
<tr class="memitem:ac7602b0a52e7f7002549e55d883c651f" id="r_ac7602b0a52e7f7002549e55d883c651f"><td class="memItemLeft">&#160;</td><td class="memItemRight"><a class="el" href="#ac7602b0a52e7f7002549e55d883c651f">flat_pool</a> (const <a class="el" href="#a7880488593a6eefda26adb44b149f9fc">allocator_type</a> &amp;alloc)</td></tr>
<tr class="memdesc:ac7602b0a52e7f7002549e55d883c651f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <a class="el" href="classjh_1_1conc_1_1flat__pool.html" title="Hash-ordered, contiguous resource interning pool.">flat_pool</a> using a custom allocator.  <br /></td></tr>
<tr class="memitem:a552aeddc5b830bda0c8f3ba30389bce8" id="r_a552aeddc5b830bda0c8f3ba30389bce8"><td class="memItemLeft">&#160;</td><td class="memItemRight"><a class="el" href="#a552aeddc5b830bda0c8f3ba30389bce8">flat_pool</a> (std::uint64_t reserve_size, const <a class="el" href="#a7880488593a6eefda26adb44b149f9fc">allocator_type</a> &amp;alloc)</td></tr>
<tr class="memdesc:a552aeddc5b830bda0c8f3ba30389bce8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <a class="el" href="classjh_1_1conc_1_1flat__pool.html" title="Hash-ordered, contiguous resource interning pool.">flat_pool</a> with a custom allocator and explicit reserved capacity.  <br /></td></tr>
<tr class="memitem:a57c6a22d8ba0f06bd8757da0881c6edd" id="r_a57c6a22d8ba0f06bd8757da0881c6edd"><td class="memItemLeft"><a id="a57c6a22d8ba0f06bd8757da0881c6edd" name="a57c6a22d8ba0f06bd8757da0881c6edd"></a>
&#160;</td><td class="memItemRight"><b>flat_pool</b> (const flat_pool &amp;other)=delete</td></tr>
<tr class="memdesc:a57c6a22d8ba0f06bd8757da0881c6edd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy construction is disabled to preserve handle and index validity. <br /></td></tr>
<tr class="memitem:a20183e3712454206a52f085dcfa92c34" id="r_a20183e3712454206a52f085dcfa92c34"><td class="memItemLeft"><a id="a20183e3712454206a52f085dcfa92c34" name="a20183e3712454206a52f085dcfa92c34"></a>
<a class="el" href="#ac32d8a004ad7a4d8ee9081a0349999e2">flat_pool</a> &amp;&#160;</td><td class="memItemRight"><b>operator=</b> (const <a class="el" href="#ac32d8a004ad7a4d8ee9081a0349999e2">flat_pool</a> &amp;other)=delete</td></tr>
<tr class="memdesc:a20183e3712454206a52f085dcfa92c34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment is disabled to prevent duplication of owned storage. <br /></td></tr>
<tr class="memitem:abef4136c6d5c73973fcb53d22c7fa6d0" id="r_abef4136c6d5c73973fcb53d22c7fa6d0"><td class="memItemLeft"><a id="abef4136c6d5c73973fcb53d22c7fa6d0" name="abef4136c6d5c73973fcb53d22c7fa6d0"></a>
&#160;</td><td class="memItemRight"><b>flat_pool</b> (flat_pool &amp;&amp;other)=delete</td></tr>
<tr class="memdesc:abef4136c6d5c73973fcb53d22c7fa6d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move construction is disabled because pooled objects are index-bound. <br /></td></tr>
<tr class="memitem:ac4c22baa3472a40d7b2c4d2524c1b02d" id="r_ac4c22baa3472a40d7b2c4d2524c1b02d"><td class="memItemLeft"><a id="ac4c22baa3472a40d7b2c4d2524c1b02d" name="ac4c22baa3472a40d7b2c4d2524c1b02d"></a>
&#160;</td><td class="memItemRight"><b>flat_pool</b> (flat_pool &amp;&amp;other, const <a class="el" href="#a7880488593a6eefda26adb44b149f9fc">allocator_type</a> &amp;alloc)=delete</td></tr>
<tr class="memdesc:ac4c22baa3472a40d7b2c4d2524c1b02d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocator-aware move construction is disabled for safety. <br /></td></tr>
<tr class="memitem:aa682e3b41cc3e1c3475c6a0cb48bf450" id="r_aa682e3b41cc3e1c3475c6a0cb48bf450"><td class="memItemLeft"><a id="aa682e3b41cc3e1c3475c6a0cb48bf450" name="aa682e3b41cc3e1c3475c6a0cb48bf450"></a>
<a class="el" href="#ac32d8a004ad7a4d8ee9081a0349999e2">flat_pool</a> &amp;&#160;</td><td class="memItemRight"><b>operator=</b> (<a class="el" href="#ac32d8a004ad7a4d8ee9081a0349999e2">flat_pool</a> &amp;&amp;other)=delete</td></tr>
<tr class="memdesc:aa682e3b41cc3e1c3475c6a0cb48bf450"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment is disabled to avoid dangling pool handles. <br /></td></tr>
<tr class="memitem:a550eda54e672ea9b2cda5fbcb6eb0a18" id="r_a550eda54e672ea9b2cda5fbcb6eb0a18"><td class="memTemplParams" colspan="2">template&lt;typename KArg&gt; <br />
requires (<a class="el" href="conceptjh_1_1typed_1_1monostate__t.html">jh::typed::monostate_t</a>&lt;Value&gt;)</td></tr>
<tr class="memitem:a550eda54e672ea9b2cda5fbcb6eb0a18 template"><td class="memItemLeft"><a class="el" href="structjh_1_1conc_1_1flat__pool_1_1ptr.html">ptr</a>&#160;</td><td class="memItemRight"><a class="el" href="#a550eda54e672ea9b2cda5fbcb6eb0a18">acquire</a> (KArg &amp;&amp;key)</td></tr>
<tr class="memdesc:a550eda54e672ea9b2cda5fbcb6eb0a18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves or creates a pooled object associated with a key (set-like).  <br /></td></tr>
<tr class="memitem:aa51bf504d3da45e06604182501c67532" id="r_aa51bf504d3da45e06604182501c67532"><td class="memTemplParams" colspan="2"><a id="aa51bf504d3da45e06604182501c67532" name="aa51bf504d3da45e06604182501c67532"></a>
template&lt;typename KArg&gt; <br />
requires (!<a class="el" href="conceptjh_1_1typed_1_1monostate__t.html">jh::typed::monostate_t</a>&lt;Value&gt;)</td></tr>
<tr class="memitem:aa51bf504d3da45e06604182501c67532 template"><td class="memItemLeft"><a class="el" href="structjh_1_1conc_1_1flat__pool_1_1ptr.html">ptr</a>&#160;</td><td class="memItemRight"><b>acquire</b> (KArg &amp;&amp;key)=delete</td></tr>
<tr class="memdesc:aa51bf504d3da45e06604182501c67532"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deleted overload for map-like pools without value arguments. <br /></td></tr>
<tr class="memitem:a749b58a94bb73a54d2506078621b472e" id="r_a749b58a94bb73a54d2506078621b472e"><td class="memTemplParams" colspan="2">template&lt;typename KArg, typename... Args&gt; <br />
requires (!<a class="el" href="conceptjh_1_1typed_1_1monostate__t.html">jh::typed::monostate_t</a>&lt;Value&gt;)</td></tr>
<tr class="memitem:a749b58a94bb73a54d2506078621b472e template"><td class="memItemLeft"><a class="el" href="structjh_1_1conc_1_1flat__pool_1_1ptr.html">ptr</a>&#160;</td><td class="memItemRight"><a class="el" href="#a749b58a94bb73a54d2506078621b472e">acquire</a> (KArg &amp;&amp;key, std::tuple&lt; Args... &gt; args_tuple)</td></tr>
<tr class="memdesc:a749b58a94bb73a54d2506078621b472e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves or creates a pooled key-value entry (map-like).  <br /></td></tr>
<tr class="memitem:a200c54151ebe954172239b83ee6ee6a8" id="r_a200c54151ebe954172239b83ee6ee6a8"><td class="memTemplParams" colspan="2"><a id="a200c54151ebe954172239b83ee6ee6a8" name="a200c54151ebe954172239b83ee6ee6a8"></a>
template&lt;typename KArg, typename... Args&gt; <br />
requires (<a class="el" href="conceptjh_1_1typed_1_1monostate__t.html">jh::typed::monostate_t</a>&lt;Value&gt;)</td></tr>
<tr class="memitem:a200c54151ebe954172239b83ee6ee6a8 template"><td class="memItemLeft"><a class="el" href="structjh_1_1conc_1_1flat__pool_1_1ptr.html">ptr</a>&#160;</td><td class="memItemRight"><b>acquire</b> (KArg &amp;&amp;key, std::tuple&lt; Args... &gt; args_tuple)=delete</td></tr>
<tr class="memdesc:a200c54151ebe954172239b83ee6ee6a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">args acquire is deleted for set-like pools <br /></td></tr>
<tr class="memitem:a329d8c6e6a243c832cc8513a94d1087e" id="r_a329d8c6e6a243c832cc8513a94d1087e"><td class="memItemLeft"><a class="el" href="structjh_1_1conc_1_1flat__pool_1_1ptr.html">ptr</a>&#160;</td><td class="memItemRight"><a class="el" href="#a329d8c6e6a243c832cc8513a94d1087e">find</a> (const Key &amp;key)</td></tr>
<tr class="memdesc:a329d8c6e6a243c832cc8513a94d1087e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Looks up an existing pooled object without creating a new one.  <br /></td></tr>
<tr class="memitem:a72b37a52b44bca8275ac2d319ccb5e68" id="r_a72b37a52b44bca8275ac2d319ccb5e68"><td class="memItemLeft">bool&#160;</td><td class="memItemRight"><a class="el" href="#a72b37a52b44bca8275ac2d319ccb5e68">empty</a> ()</td></tr>
<tr class="memdesc:a72b37a52b44bca8275ac2d319ccb5e68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the pool contains no active entries.  <br /></td></tr>
<tr class="memitem:af7066986c05baa636cd978768671a058" id="r_af7066986c05baa636cd978768671a058"><td class="memItemLeft">std::size_t&#160;</td><td class="memItemRight"><a class="el" href="#af7066986c05baa636cd978768671a058">capacity</a> ()</td></tr>
<tr class="memdesc:af7066986c05baa636cd978768671a058"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current storage capacity of the pool.  <br /></td></tr>
<tr class="memitem:ad383caf554309623d596c1a7d8717632" id="r_ad383caf554309623d596c1a7d8717632"><td class="memItemLeft">std::size_t&#160;</td><td class="memItemRight"><a class="el" href="#ad383caf554309623d596c1a7d8717632">size</a> ()</td></tr>
<tr class="memdesc:ad383caf554309623d596c1a7d8717632"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of active entries in the pool.  <br /></td></tr>
<tr class="memitem:aaa615c0b8bc3dc01bca04bf726942d2a" id="r_aaa615c0b8bc3dc01bca04bf726942d2a"><td class="memItemLeft">std::pair&lt; std::size_t, std::size_t &gt;&#160;</td><td class="memItemRight"><a class="el" href="#aaa615c0b8bc3dc01bca04bf726942d2a">occupancy_rate</a> ()</td></tr>
<tr class="memdesc:aaa615c0b8bc3dc01bca04bf726942d2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a snapshot of pool capacity and active entry count.  <br /></td></tr>
<tr class="memitem:a97a29e766058f5171a1a3c09d5f30f1b" id="r_a97a29e766058f5171a1a3c09d5f30f1b"><td class="memItemLeft">void&#160;</td><td class="memItemRight"><a class="el" href="#a97a29e766058f5171a1a3c09d5f30f1b">resize_pool</a> ()</td></tr>
<tr class="memdesc:a97a29e766058f5171a1a3c09d5f30f1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shrinks internal storage to fit active entries.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-static-attribs" class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:aa7b703e74ffc8eabccc65468e1ef0c14" id="r_aa7b703e74ffc8eabccc65468e1ef0c14"><td class="memItemLeft"><a id="aa7b703e74ffc8eabccc65468e1ef0c14" name="aa7b703e74ffc8eabccc65468e1ef0c14"></a>
static std::uint64_t constexpr&#160;</td><td class="memItemRight"><b>MIN_RESERVED_SIZE</b> = 16</td></tr>
<tr class="memdesc:aa7b703e74ffc8eabccc65468e1ef0c14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum reserved size for the pool. <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-friends" class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:ae936e6b590c9ad624f39af182dacb0b2" id="r_ae936e6b590c9ad624f39af182dacb0b2"><td class="memItemLeft"><a id="ae936e6b590c9ad624f39af182dacb0b2" name="ae936e6b590c9ad624f39af182dacb0b2"></a>
class&#160;</td><td class="memItemRight"><b>flat_pool::ptr</b></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename Key, typename Value = jh::typed::monostate, typename Hash = jh::hash&lt;Key&gt;, typename Alloc = std::allocator&lt;detail::value_t&lt;Key, Value&gt;&gt;&gt;<br />
requires ((requires(const Key &amp;k) { { Hash{}(k) } -&gt; std::convertible_to&lt;size_t&gt;; }) &amp;&amp; (requires(const Key &amp;a, const Key &amp;b) { { a == b } -&gt; std::convertible_to&lt;bool&gt;; }) &amp;&amp; <a class="el" href="conceptjh_1_1concepts_1_1is__contiguous__reallocable.html">jh::concepts::is_contiguous_reallocable</a>&lt;Key&gt; &amp;&amp; (<a class="el" href="conceptjh_1_1typed_1_1monostate__t.html">jh::typed::monostate_t</a>&lt;Value&gt; || <a class="el" href="conceptjh_1_1concepts_1_1is__contiguous__reallocable.html">jh::concepts::is_contiguous_reallocable</a>&lt;Value&gt;))<br />
class jh::conc::flat_pool&lt; Key, Value, Hash, Alloc &gt;</div><p>Hash-ordered, contiguous resource interning pool. </p>
<h4>Conceptual Model</h4>
<p><code><a class="el" href="classjh_1_1conc_1_1flat__pool.html" title="Hash-ordered, contiguous resource interning pool.">flat_pool</a></code> interns objects by mapping keys to stable integer indices inside a contiguous storage vector. Each unique key corresponds to at most one active slot at any time. </p>
<p>The pool maintains a sorted index of <code>(hash, index)</code> pairs, allowing logarithmic lookup by hash followed by linear resolution of hash collisions. This design preserves the full entropy of the hash value and avoids bucket-based aliasing. </p>
<h4>Key-Value Semantics</h4>
<p>The pool may operate in two modes: </p>
<ul>
<li>
<b>Set-like:</b> When <code>Value</code> is <code><a class="el" href="structjh_1_1typed_1_1monostate.html" title="Trivial empty type representing &quot;no value&quot;.">jh::typed::monostate</a></code>, only keys are stored. </li>
<li>
<b>Map-like:</b> Otherwise, the pool stores <code>(Key, Value)</code> pairs, where the value is constructed only upon first insertion. </li>
</ul>
<h4>Construction and Deduplication</h4>
<p>Acquisition follows a two-phase lookup strategy: </p>
<ol>
<li>
Shared-lock lookup to detect an existing entry. </li>
<li>
Exclusive-lock recheck followed by insertion if absent. </li>
</ol>
<p>For map-like pools, value construction is deferred until the key is confirmed to be absent, ensuring that repeated acquisitions do not incur unnecessary construction cost. </p>
<h4>Lifetime Management</h4>
<p>Each slot maintains an atomic reference count. When the count reaches zero, the slot is marked as free and may be reused by subsequent insertions. </p>
<p>Slots are not immediately destroyed or removed from storage. Instead, they participate in a free-slot reuse mechanism that minimizes memory churn. </p>
<h4>Concurrency Guarantees</h4>
<ul>
<li>
Lookup operations acquire only shared locks. </li>
<li>
Insertion and release require exclusive access. </li>
<li>
Reference counting is performed atomically. </li>
</ul>
<h4>Reallocation Safety</h4>
<p>Although indices remain stable, vector reallocation may invalidate references or pointers to stored objects. To address this, the pool provides a <code>no_reallocate_guard</code> mechanism that prevents reallocation while dereferencing pooled objects in concurrent environments. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Key</td><td>Key type defining object identity. </td></tr>
    <tr><td class="paramname">Value</td><td>Optional associated value type (<code><a class="el" href="structjh_1_1typed_1_1monostate.html" title="Trivial empty type representing &quot;no value&quot;.">jh::typed::monostate</a></code> for key-only). </td></tr>
    <tr><td class="paramname">Hash</td><td>Hash functor used to compute full-width hash values (<code><a class="el" href="structjh_1_1hash.html" title="Behaviorally deduced hash functor.">jh::hash</a></code> for auto hash-derivation). </td></tr>
    <tr><td class="paramname">Alloc</td><td>Allocator type for contiguous storage.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Unlike <code><a class="el" href="classjh_1_1conc_1_1pointer__pool.html" title="Weak pointer-observed pool for immutable or structurally immutable objects.">pointer_pool</a></code> or its user-facing interface <code><a class="el" href="namespacejh.html#abc89d1d2a2d84b2aba124fe8d9ee1d7b" title="Duck-typed alias of jh::conc::pointer_pool for content-based pooling of immutable objects.">observe_pool</a></code>, <code><a class="el" href="classjh_1_1conc_1_1flat__pool.html" title="Hash-ordered, contiguous resource interning pool.">flat_pool</a></code>(<code><a class="el" href="namespacejh.html#a8eabe55fe3cf148e8b74b82dac631bec" title="Convenience alias of jh::conc::flat_pool with behaviorally deduced hashing.">resource_pool</a></code>) does not permit moves. <br  />
 As indicated by their user-facing interface names, <code><a class="el" href="classjh_1_1conc_1_1pointer__pool.html" title="Weak pointer-observed pool for immutable or structurally immutable objects.">pointer_pool</a></code>(<code><a class="el" href="namespacejh.html#abc89d1d2a2d84b2aba124fe8d9ee1d7b" title="Duck-typed alias of jh::conc::pointer_pool for content-based pooling of immutable objects.">observe_pool</a></code>) does not hold objects: it merely observes them. The worst-case scenario after a move is deduplication failure, but the system remains operational. <br  />
 <code><a class="el" href="classjh_1_1conc_1_1flat__pool.html" title="Hash-ordered, contiguous resource interning pool.">flat_pool</a></code>(<code><a class="el" href="namespacejh.html#a8eabe55fe3cf148e8b74b82dac631bec" title="Convenience alias of jh::conc::flat_pool with behaviorally deduced hashing.">resource_pool</a></code>), however, fully owns objects. Once moves are permitted, the <code><a class="el" href="structjh_1_1conc_1_1flat__pool_1_1ptr.html" title="Reference-counted handle to a pooled object.">flat_pool::ptr</a></code> handle becomes dangling, hence the move semantics are disabled to ensure safety. </dd></dl>
</div><a name="doc-typedef-members" id="doc-typedef-members"></a><h2 id="header-doc-typedef-members" class="groupheader">Member Typedef Documentation</h2>
<a id="a7880488593a6eefda26adb44b149f9fc" name="a7880488593a6eefda26adb44b149f9fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7880488593a6eefda26adb44b149f9fc">&#9670;&#160;</a></span>allocator_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key, typename Value = jh::typed::monostate, typename Hash = jh::hash&lt;Key&gt;, typename Alloc = std::allocator&lt;detail::value_t&lt;Key, Value&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classjh_1_1conc_1_1flat__pool.html">jh::conc::flat_pool</a>&lt; Key, Value, Hash, Alloc &gt;::allocator_type</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line"><span class="keyword">typename</span> std::allocator_traits&lt;Alloc&gt;::template rebind_alloc&lt;detail::value_t&lt;Key, Value&gt;&gt;</div>
</div><!-- fragment -->
<p>Allocator rebound for value <code>storage_</code> only. </p>

</div>
</div>
<a name="doc-constructors" id="doc-constructors"></a><h2 id="header-doc-constructors" class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ac32d8a004ad7a4d8ee9081a0349999e2" name="ac32d8a004ad7a4d8ee9081a0349999e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac32d8a004ad7a4d8ee9081a0349999e2">&#9670;&#160;</a></span>flat_pool() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key, typename Value = jh::typed::monostate, typename Hash = jh::hash&lt;Key&gt;, typename Alloc = std::allocator&lt;detail::value_t&lt;Key, Value&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classjh_1_1conc_1_1flat__pool.html">jh::conc::flat_pool</a>&lt; Key, Value, Hash, Alloc &gt;::flat_pool </td>
          <td>(</td>
          <td class="paramtype">std::uint64_t</td>          <td class="paramname"><span class="paramname"><em>reserve_size</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#aa7b703e74ffc8eabccc65468e1ef0c14">MIN_RESERVED_SIZE</a></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel explicit">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a <a class="el" href="classjh_1_1conc_1_1flat__pool.html" title="Hash-ordered, contiguous resource interning pool.">flat_pool</a> with pre-reserved contiguous storage. </p>
<p>Initializes an empty pool and pre-reserves internal storage to reduce reallocation overhead during early insertions. </p>
<p>The reservation applies to: </p>
<ul>
<li>
the contiguous value storage, </li>
<li>
the reference count buffer, </li>
<li>
the occupation bitmap, </li>
<li>
the hash-ordered entry index. </li>
</ul>
<p>If <code>reserve_size</code> is smaller than <code>MIN_RESERVED_SIZE</code>, the minimum value is used instead. This guarantees a baseline capacity suitable for typical workloads and avoids pathological reallocation behavior. </p>
<p>No objects are constructed during initialization. All slots are created lazily upon first acquisition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reserve_size</td><td>Initial number of slots to reserve. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac7602b0a52e7f7002549e55d883c651f" name="ac7602b0a52e7f7002549e55d883c651f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7602b0a52e7f7002549e55d883c651f">&#9670;&#160;</a></span>flat_pool() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key, typename Value = jh::typed::monostate, typename Hash = jh::hash&lt;Key&gt;, typename Alloc = std::allocator&lt;detail::value_t&lt;Key, Value&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classjh_1_1conc_1_1flat__pool.html">jh::conc::flat_pool</a>&lt; Key, Value, Hash, Alloc &gt;::flat_pool </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a7880488593a6eefda26adb44b149f9fc">allocator_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>alloc</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel explicit">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a <a class="el" href="classjh_1_1conc_1_1flat__pool.html" title="Hash-ordered, contiguous resource interning pool.">flat_pool</a> using a custom allocator. </p>
<p>Initializes an empty pool with allocator-aware contiguous storage and reserves the minimum required capacity.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alloc</td><td>Allocator used for internal value storage. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a552aeddc5b830bda0c8f3ba30389bce8" name="a552aeddc5b830bda0c8f3ba30389bce8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a552aeddc5b830bda0c8f3ba30389bce8">&#9670;&#160;</a></span>flat_pool() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key, typename Value = jh::typed::monostate, typename Hash = jh::hash&lt;Key&gt;, typename Alloc = std::allocator&lt;detail::value_t&lt;Key, Value&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classjh_1_1conc_1_1flat__pool.html">jh::conc::flat_pool</a>&lt; Key, Value, Hash, Alloc &gt;::flat_pool </td>
          <td>(</td>
          <td class="paramtype">std::uint64_t</td>          <td class="paramname"><span class="paramname"><em>reserve_size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a7880488593a6eefda26adb44b149f9fc">allocator_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>alloc</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel explicit">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a <a class="el" href="classjh_1_1conc_1_1flat__pool.html" title="Hash-ordered, contiguous resource interning pool.">flat_pool</a> with a custom allocator and explicit reserved capacity. </p>
<p>Initializes an empty pool using the provided allocator for contiguous value storage and pre-reserves internal capacity according to <code>reserve_size</code>. </p>
<p>The reservation applies uniformly to all internal structures, including: </p>
<ul>
<li>
the contiguous value storage vector, </li>
<li>
the reference count buffer, </li>
<li>
the occupation bitmap, </li>
<li>
the hash-ordered entry index. </li>
</ul>
<p>If <code>reserve_size</code> is smaller than <code>MIN_RESERVED_SIZE</code>, the minimum value is used instead. This ensures a baseline capacity and avoids early reallocation under light workloads. </p>
<p>No objects are constructed during initialization. All slots are created lazily upon first successful acquisition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reserve_size</td><td>Initial number of slots to reserve. </td></tr>
    <tr><td class="paramname">alloc</td><td>Allocator used for contiguous value storage. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="a550eda54e672ea9b2cda5fbcb6eb0a18" name="a550eda54e672ea9b2cda5fbcb6eb0a18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a550eda54e672ea9b2cda5fbcb6eb0a18">&#9670;&#160;</a></span>acquire() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key, typename Value = jh::typed::monostate, typename Hash = jh::hash&lt;Key&gt;, typename Alloc = std::allocator&lt;detail::value_t&lt;Key, Value&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename KArg&gt; <br />
requires (<a class="el" href="conceptjh_1_1typed_1_1monostate__t.html">jh::typed::monostate_t</a>&lt;Value&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structjh_1_1conc_1_1flat__pool_1_1ptr.html">ptr</a> <a class="el" href="classjh_1_1conc_1_1flat__pool.html">jh::conc::flat_pool</a>&lt; Key, Value, Hash, Alloc &gt;::acquire </td>
          <td>(</td>
          <td class="paramtype">KArg &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves or creates a pooled object associated with a key (set-like). </p>
<p>This overload is available only when the pool operates in <b>set-like</b> mode (<code>Value == <a class="el" href="structjh_1_1typed_1_1monostate.html" title="Trivial empty type representing &quot;no value&quot;.">jh::typed::monostate</a></code>). </p>
<p>If an equivalent key already exists in the pool, a handle to the existing slot is returned. Otherwise, a new slot containing the key is created. </p>
<p>No value construction is involved in this mode. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KArg</td><td>A cv/ref-qualified form of <code>Key</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key identifying the object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference-counted handle to the pooled key, or a null handle on failure. </dd></dl>

</div>
</div>
<a id="a749b58a94bb73a54d2506078621b472e" name="a749b58a94bb73a54d2506078621b472e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a749b58a94bb73a54d2506078621b472e">&#9670;&#160;</a></span>acquire() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key, typename Value = jh::typed::monostate, typename Hash = jh::hash&lt;Key&gt;, typename Alloc = std::allocator&lt;detail::value_t&lt;Key, Value&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename KArg, typename... Args&gt; <br />
requires (!<a class="el" href="conceptjh_1_1typed_1_1monostate__t.html">jh::typed::monostate_t</a>&lt;Value&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structjh_1_1conc_1_1flat__pool_1_1ptr.html">ptr</a> <a class="el" href="classjh_1_1conc_1_1flat__pool.html">jh::conc::flat_pool</a>&lt; Key, Value, Hash, Alloc &gt;::acquire </td>
          <td>(</td>
          <td class="paramtype">KArg &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::tuple&lt; Args... &gt;</td>          <td class="paramname"><span class="paramname"><em>args_tuple</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves or creates a pooled key-value entry (map-like). </p>
<p>This overload is available only when the pool operates in <b>map-like</b> mode (<code>Value != <a class="el" href="structjh_1_1typed_1_1monostate.html" title="Trivial empty type representing &quot;no value&quot;.">jh::typed::monostate</a></code>). </p>
<p>The value construction arguments are provided as a <code>std::tuple</code> and are used <em>only if</em> the key does not already exist in the pool. If an equivalent key is found, the existing entry is reused and the provided arguments are ignored. </p>
<p>This design ensures that expensive value construction is performed exactly once for each unique key, even under concurrent acquisition. </p>
<h5>Construction Semantics</h5>
<ul>
<li>
The key is used for lookup and deduplication. </li>
<li>
By default, the value is constructed by forwarding the provided arguments to <code>Value</code>'s constructor.  </li>
<li>
For <code>std::shared_ptr&lt;T&gt;</code> and <code>std::unique_ptr&lt;T&gt;</code>, the default behavior forwards the arguments to <code>std::make_shared&lt;T&gt;</code> and <code>std::make_unique&lt;T&gt;</code> respectively.  </li>
<li>
Repeated calls with the same key but different argument tuples will always return the originally constructed value.  </li>
</ul>
<h5>Custom Value Construction</h5>
<p>Value construction is customizable through a public extension point: <code><a class="el" href="structjh_1_1conc_1_1extension_1_1value__factory.html" title="Default value construction policy for flat_pool.">jh::conc::extension::value_factory&lt;Value&gt;</a></code>. Users may specialize this template to override how values are created. </p>
<p>A custom factory may be provided as follows: </p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span><a class="code hl_namespace" href="namespacejh_1_1conc_1_1extension.html">jh::conc::extension</a> {</div>
<div class="line">    <span class="keyword">template</span>&lt;&gt;</div>
<div class="line">    <span class="keyword">struct </span>value_factory&lt;Foo&gt; {</div>
<div class="line">        <span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</div>
<div class="line">        <span class="keyword">static</span> Foo make(Args&amp;&amp;... args) {</div>
<div class="line">            <span class="comment">// user-defined construction logic</span></div>
<div class="line">        }</div>
<div class="line">    };</div>
<div class="line">}</div>
<div class="ttc" id="anamespacejh_1_1conc_1_1extension_html"><div class="ttname"><a href="namespacejh_1_1conc_1_1extension.html">jh::conc::extension</a></div><div class="ttdef"><b>Definition</b> flat_pool.h:224</div></div>
</div><!-- fragment --><p>This mechanism is an <b>intentional public injection point</b> and allows customization without modifying or subclassing <code><a class="el" href="classjh_1_1conc_1_1flat__pool.html" title="Hash-ordered, contiguous resource interning pool.">flat_pool</a></code>. </p>
<p>Users should treat the argument tuple as <b>initialization parameters</b>, not update parameters. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KArg</td><td>A cv/ref-qualified form of <code>Key</code>. </td></tr>
    <tr><td class="paramname">Args</td><td>Types of arguments used for value construction.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key identifying the entry. </td></tr>
    <tr><td class="paramname">args_tuple</td><td>Tuple of arguments forwarded to value construction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference-counted handle to the pooled entry, or a null handle on failure. </dd></dl>

</div>
</div>
<a id="af7066986c05baa636cd978768671a058" name="af7066986c05baa636cd978768671a058"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7066986c05baa636cd978768671a058">&#9670;&#160;</a></span>capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key, typename Value = jh::typed::monostate, typename Hash = jh::hash&lt;Key&gt;, typename Alloc = std::allocator&lt;detail::value_t&lt;Key, Value&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classjh_1_1conc_1_1flat__pool.html">jh::conc::flat_pool</a>&lt; Key, Value, Hash, Alloc &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current storage capacity of the pool. </p>
<p>This value represents the number of slots currently allocated in the underlying contiguous storage. It reflects historical peak demand rather than current usage. </p>
<p>A larger capacity does not imply high active usage. The pool may have grown due to a temporary workload spike and later released most entries without shrinking. </p>
<p>Capacity is adjusted only through explicit maintenance operations such as <code><a class="el" href="#a97a29e766058f5171a1a3c09d5f30f1b" title="Shrinks internal storage to fit active entries.">resize_pool()</a></code>. </p>
<dl class="section return"><dt>Returns</dt><dd>The current storage capacity. </dd></dl>

</div>
</div>
<a id="a72b37a52b44bca8275ac2d319ccb5e68" name="a72b37a52b44bca8275ac2d319ccb5e68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72b37a52b44bca8275ac2d319ccb5e68">&#9670;&#160;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key, typename Value = jh::typed::monostate, typename Hash = jh::hash&lt;Key&gt;, typename Alloc = std::allocator&lt;detail::value_t&lt;Key, Value&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classjh_1_1conc_1_1flat__pool.html">jh::conc::flat_pool</a>&lt; Key, Value, Hash, Alloc &gt;::empty </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether the pool contains no active entries. </p>
<p>Returns <code>true</code> if there are currently no live entries registered in the pool. </p>
<p>This function reflects the <b>logical emptiness</b> of the pool, not its physical storage state. Internal capacity and previously allocated slots may still exist even when the pool is empty. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the pool has no active entries; otherwise <code>false</code>. </dd></dl>

</div>
</div>
<a id="a329d8c6e6a243c832cc8513a94d1087e" name="a329d8c6e6a243c832cc8513a94d1087e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a329d8c6e6a243c832cc8513a94d1087e">&#9670;&#160;</a></span>find()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key, typename Value = jh::typed::monostate, typename Hash = jh::hash&lt;Key&gt;, typename Alloc = std::allocator&lt;detail::value_t&lt;Key, Value&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structjh_1_1conc_1_1flat__pool_1_1ptr.html">ptr</a> <a class="el" href="classjh_1_1conc_1_1flat__pool.html">jh::conc::flat_pool</a>&lt; Key, Value, Hash, Alloc &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Looks up an existing pooled object without creating a new one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A valid handle if the key exists; otherwise, a null handle.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Unlike <code><a class="el" href="#a550eda54e672ea9b2cda5fbcb6eb0a18" title="Retrieves or creates a pooled object associated with a key (set-like).">acquire()</a></code>, this function never inserts new entries. </dd></dl>

</div>
</div>
<a id="aaa615c0b8bc3dc01bca04bf726942d2a" name="aaa615c0b8bc3dc01bca04bf726942d2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa615c0b8bc3dc01bca04bf726942d2a">&#9670;&#160;</a></span>occupancy_rate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key, typename Value = jh::typed::monostate, typename Hash = jh::hash&lt;Key&gt;, typename Alloc = std::allocator&lt;detail::value_t&lt;Key, Value&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::size_t, std::size_t &gt; <a class="el" href="classjh_1_1conc_1_1flat__pool.html">jh::conc::flat_pool</a>&lt; Key, Value, Hash, Alloc &gt;::occupancy_rate </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a snapshot of pool capacity and active entry count. </p>
<p>This function acts as a <b>health observer</b> rather than a strict capacity-management API. It reports the current storage capacity and the number of active entries as a logically consistent pair.</p>
<h5>Consistency Guarantee</h5>
<p>The returned <code>(capacity, size)</code> values are obtained under a single shared lock and therefore always reflect the same internal version of the pool state. Callers may rely on the two values being mutually consistent and not derived from different update epochs. </p>
<h5>Hot-Path vs Cold-Path Interpretation</h5>
<p>This metric is intended for <b>observational and heuristic use</b>. It does <em>not</em> imply that the pool should be immediately shrunk when utilization appears low. </p>
<ul>
<li>
<b>Hot paths:</b> Capacity growth reflects real demand. If the pool has expanded to a certain size, it indicates that the workload has required that capacity at some point. Shrinking on the hot path is therefore discouraged, as it may introduce allocation jitter and negate the benefit of prior expansion.  </li>
<li>
<b>Cold paths:</b> When the pool remains underutilized for an extended period and health metrics consistently indicate low occupancy, a controlled shrink (e.g. via <code><a class="el" href="#a97a29e766058f5171a1a3c09d5f30f1b" title="Shrinks internal storage to fit active entries.">resize_pool()</a></code>) may be considered to release unused memory.  </li>
</ul>
<h5>Slot Reuse Characteristics</h5>
<p>The pool preferentially reuses the lowest-index free slots. As a result, after a temporary surge in capacity, newly inserted entries naturally migrate toward the front of the storage vector over time. </p>
<p>This behavior means that tail regions tend to become empty first during cooling phases, making them suitable candidates for release without disrupting active entries. </p>
<dl class="section return"><dt>Returns</dt><dd>A pair consisting of: <ol>
<li>
the current storage capacity </li>
<li>
the number of active entries </li>
</ol>
</dd></dl>

</div>
</div>
<a id="a97a29e766058f5171a1a3c09d5f30f1b" name="a97a29e766058f5171a1a3c09d5f30f1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97a29e766058f5171a1a3c09d5f30f1b">&#9670;&#160;</a></span>resize_pool()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key, typename Value = jh::typed::monostate, typename Hash = jh::hash&lt;Key&gt;, typename Alloc = std::allocator&lt;detail::value_t&lt;Key, Value&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classjh_1_1conc_1_1flat__pool.html">jh::conc::flat_pool</a>&lt; Key, Value, Hash, Alloc &gt;::resize_pool </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shrinks internal storage to fit active entries. </p>
<p>This function scans for the highest-index active slot and reduces the capacity of internal storage to the smallest power-of-two sufficient to hold all active entries, subject to a minimum reserved size. </p>
<p>This operation acquires exclusive locks and must not be performed concurrently with active dereferencing unless guarded. </p>

</div>
</div>
<a id="ad383caf554309623d596c1a7d8717632" name="ad383caf554309623d596c1a7d8717632"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad383caf554309623d596c1a7d8717632">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key, typename Value = jh::typed::monostate, typename Hash = jh::hash&lt;Key&gt;, typename Alloc = std::allocator&lt;detail::value_t&lt;Key, Value&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classjh_1_1conc_1_1flat__pool.html">jh::conc::flat_pool</a>&lt; Key, Value, Hash, Alloc &gt;::size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of active entries in the pool. </p>
<p>This function reports the number of currently live, deduplicated entries registered in the pool. <br  />
 The returned value corresponds to the number of keys present in the internal index, not the number of allocated slots. </p>
<p>In particular: </p>
<ul>
<li>
Released entries that are eligible for reuse are not counted. </li>
<li>
Internal storage may contain inactive slots beyond this count. </li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>The number of active entries. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/jh/concurrent/<a class="el" href="">flat_pool.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
</div> <!-- top -->
<hr class="footer"/>
<div class="footer">
    <img class="footer-logo" src="Ojing.svg" alt="Ojing"/>
    <div class="footer-text">
        JH-Toolkit v1.4.0 Â· Generated by Doxygen
    </div>
    <div class="footer-note">
        We primarily support embedded documentation views in IDEs (classic CLion).
        To ensure compatibility with embedded rendering, some example code in this
        documentation intentionally contains HTML entities.
        In certain cases, Doxygen does not unescape these entities correctly.
        This is a known limitation and currently has no workaround.
    </div>
</div>
</body>
</html>
