<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.16.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>JH-Toolkit: jh Namespace Reference</title>
<link rel="icon" href="Jindallae.svg" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="Oree.svg"/></td>
  <td id="projectalign">
   <div id="projectname">JH-Toolkit<span id="projectnumber">&#160;v1.4.0</span>
   </div>
   <div id="projectbrief">An engineering-oriented C++20 toolkit with duck-typed concepts, static design, async coroutines, and semantic containers — header-only, RTTI-free, and concurrency-friendly.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.16.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('namespacejh.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">jh Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:container_5Fdeduction" id="r_container_5Fdeduction"><td class="memItemLeft">struct &#160;</td><td class="memItemRight"><a class="el" href="structjh_1_1container__deduction.html">container_deduction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">User customization point for container element deduction.  <a href="structjh_1_1container__deduction.html#details">More...</a><br /></td></tr>
<tr class="memitem:hash" id="r_hash"><td class="memItemLeft">struct &#160;</td><td class="memItemRight"><a class="el" href="structjh_1_1hash.html">hash</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Behaviorally deduced hash functor.  <a href="structjh_1_1hash.html#details">More...</a><br /></td></tr>
<tr class="memitem:hash_3C_20T_2C_20std_3A_3Aenable_5Fif_5Ft_3C_20jh_3A_3Aconcepts_3A_3Ahas_5Fstd_5Fhash_3C_20T_20_3E_20_3E_20_3E" id="r_hash_3C_20T_2C_20std_3A_3Aenable_5Fif_5Ft_3C_20jh_3A_3Aconcepts_3A_3Ahas_5Fstd_5Fhash_3C_20T_20_3E_20_3E_20_3E"><td class="memItemLeft">struct &#160;</td><td class="memItemRight"><a class="el" href="structjh_1_1hash_3_01T_00_01std_1_1enable__if__t_3_01jh_1_1concepts_1_1has__std__hash_3_01T_01_4_01_4_01_4.html">hash&lt; T, std::enable_if_t&lt; jh::concepts::has_std_hash&lt; T &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Case 1: std::hash&lt;T&gt; is valid.  <a href="structjh_1_1hash_3_01T_00_01std_1_1enable__if__t_3_01jh_1_1concepts_1_1has__std__hash_3_01T_01_4_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="memitem:hash_3C_20T_2C_20std_3A_3Aenable_5Fif_5Ft_3C_21jh_3A_3Aconcepts_3A_3Ahas_5Fstd_5Fhash_3C_20T_20_3E_20_26_26jh_3A_3Aconcepts_3A_3Ahas_5Fadl_5Fhash_3C_20T_20_3E_20_3E_20_3E" id="r_hash_3C_20T_2C_20std_3A_3Aenable_5Fif_5Ft_3C_21jh_3A_3Aconcepts_3A_3Ahas_5Fstd_5Fhash_3C_20T_20_3E_20_26_26jh_3A_3Aconcepts_3A_3Ahas_5Fadl_5Fhash_3C_20T_20_3E_20_3E_20_3E"><td class="memItemLeft">struct &#160;</td><td class="memItemRight"><a class="el" href="structjh_1_1hash_3_01T_00_01std_1_1enable__if__t_3_9jh_1_1concepts_1_1has__std__hash_3_01T_01_4_14944712e3c515b0d0b007ddbf79009d.html">hash&lt; T, std::enable_if_t&lt;!jh::concepts::has_std_hash&lt; T &gt; &amp;&amp;jh::concepts::has_adl_hash&lt; T &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Case 2: ADL-discovered hash(T).  <a href="structjh_1_1hash_3_01T_00_01std_1_1enable__if__t_3_9jh_1_1concepts_1_1has__std__hash_3_01T_01_4_14944712e3c515b0d0b007ddbf79009d.html#details">More...</a><br /></td></tr>
<tr class="memitem:hash_3C_20T_2C_20std_3A_3Aenable_5Fif_5Ft_3C_21jh_3A_3Aconcepts_3A_3Ahas_5Fstd_5Fhash_3C_20T_20_3E_20_26_26_21jh_3A_3Aconcepts_3A_3Ahas_5Fadl_5Fhash_3C_20T_20_3E_20_26_26jh_3A_3Aconcepts_3A_3Ahas_5Fmbr_5Fhash_3C_20T_20_3E_20_3E_20_3E" id="r_hash_3C_20T_2C_20std_3A_3Aenable_5Fif_5Ft_3C_21jh_3A_3Aconcepts_3A_3Ahas_5Fstd_5Fhash_3C_20T_20_3E_20_26_26_21jh_3A_3Aconcepts_3A_3Ahas_5Fadl_5Fhash_3C_20T_20_3E_20_26_26jh_3A_3Aconcepts_3A_3Ahas_5Fmbr_5Fhash_3C_20T_20_3E_20_3E_20_3E"><td class="memItemLeft">struct &#160;</td><td class="memItemRight"><a class="el" href="structjh_1_1hash_3_01T_00_01std_1_1enable__if__t_3_9jh_1_1concepts_1_1has__std__hash_3_01T_01_4_e765a43b8d847b9d7259401d2b74fed3.html">hash&lt; T, std::enable_if_t&lt;!jh::concepts::has_std_hash&lt; T &gt; &amp;&amp;!jh::concepts::has_adl_hash&lt; T &gt; &amp;&amp;jh::concepts::has_mbr_hash&lt; T &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Case 3: Member hash().  <a href="structjh_1_1hash_3_01T_00_01std_1_1enable__if__t_3_9jh_1_1concepts_1_1has__std__hash_3_01T_01_4_e765a43b8d847b9d7259401d2b74fed3.html#details">More...</a><br /></td></tr>
<tr class="memitem:iterator" id="r_iterator"><td class="memItemLeft">struct &#160;</td><td class="memItemRight"><a class="el" href="structjh_1_1iterator.html">iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward declaration of <code><a class="el" href="structjh_1_1iterator.html" title="Forward declaration of jh::iterator&lt;Container&gt;.">jh::iterator&lt;Container&gt;</a></code>.  <a href="structjh_1_1iterator.html#details">More...</a><br /></td></tr>
<tr class="memitem:recursive_5Fregistry" id="r_recursive_5Fregistry"><td class="memItemLeft">struct &#160;</td><td class="memItemRight"><a class="el" href="structjh_1_1recursive__registry.html">recursive_registry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait registry for detecting counting reentrance (recursive).  <a href="structjh_1_1recursive__registry.html#details">More...</a><br /></td></tr>
<tr class="memitem:reentrant_5Fregistry" id="r_reentrant_5Fregistry"><td class="memItemLeft">struct &#160;</td><td class="memItemRight"><a class="el" href="structjh_1_1reentrant__registry.html">reentrant_registry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait registry for detecting idempotent (structural) reentrance.  <a href="structjh_1_1reentrant__registry.html#details">More...</a><br /></td></tr>
<tr class="memitem:recursive_5Fregistry_3C_20std_3A_3Arecursive_5Fmutex_20_3E" id="r_recursive_5Fregistry_3C_20std_3A_3Arecursive_5Fmutex_20_3E"><td class="memItemLeft">struct &#160;</td><td class="memItemRight"><a class="el" href="structjh_1_1recursive__registry_3_01std_1_1recursive__mutex_01_4.html">recursive_registry&lt; std::recursive_mutex &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for <code>std::recursive_mutex</code>.  <a href="structjh_1_1recursive__registry_3_01std_1_1recursive__mutex_01_4.html#details">More...</a><br /></td></tr>
<tr class="memitem:recursive_5Fregistry_3C_20std_3A_3Arecursive_5Ftimed_5Fmutex_20_3E" id="r_recursive_5Fregistry_3C_20std_3A_3Arecursive_5Ftimed_5Fmutex_20_3E"><td class="memItemLeft">struct &#160;</td><td class="memItemRight"><a class="el" href="structjh_1_1recursive__registry_3_01std_1_1recursive__timed__mutex_01_4.html">recursive_registry&lt; std::recursive_timed_mutex &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for <code>std::recursive_timed_mutex</code>.  <a href="structjh_1_1recursive__registry_3_01std_1_1recursive__timed__mutex_01_4.html#details">More...</a><br /></td></tr>
<tr class="memitem:weak_5Fptr_5Fhash" id="r_weak_5Fptr_5Fhash"><td class="memItemLeft">struct &#160;</td><td class="memItemRight"><a class="el" href="structjh_1_1weak__ptr__hash.html">weak_ptr_hash</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Content-based hash functor for <code>std::weak_ptr&lt;T&gt;</code>.  <a href="structjh_1_1weak__ptr__hash.html#details">More...</a><br /></td></tr>
<tr class="memitem:weak_5Fptr_5Feq" id="r_weak_5Fptr_5Feq"><td class="memItemLeft">struct &#160;</td><td class="memItemRight"><a class="el" href="structjh_1_1weak__ptr__eq.html">weak_ptr_eq</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality functor for <code>std::weak_ptr&lt;T&gt;</code>.  <a href="structjh_1_1weak__ptr__eq.html#details">More...</a><br /></td></tr>
<tr class="memitem:flat_5Fmultimap" id="r_flat_5Fmultimap"><td class="memItemLeft">class &#160;</td><td class="memItemRight"><a class="el" href="classjh_1_1flat__multimap.html">flat_multimap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flat ordered multimap implemented as a sorted contiguous container.  <a href="classjh_1_1flat__multimap.html#details">More...</a><br /></td></tr>
<tr class="memitem:immutable_5Fstr" id="r_immutable_5Fstr"><td class="memItemLeft">class &#160;</td><td class="memItemRight"><a class="el" href="classjh_1_1immutable__str.html">immutable_str</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Immutable string with optional automatic trimming and thread-safe hash caching.  <a href="classjh_1_1immutable__str.html#details">More...</a><br /></td></tr>
<tr class="memitem:atomic_5Fstr_5Fhash" id="r_atomic_5Fstr_5Fhash"><td class="memItemLeft">struct &#160;</td><td class="memItemRight"><a class="el" href="structjh_1_1atomic__str__hash.html">atomic_str_hash</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Custom hash functor for <code><a class="el" href="#af7d00b32739582480e12e4abeec9cac1" title="Atomically replaceable handle to an immutable string.">atomic_str_ptr</a></code> and compatible types.  <a href="structjh_1_1atomic__str__hash.html#details">More...</a><br /></td></tr>
<tr class="memitem:atomic_5Fstr_5Feq" id="r_atomic_5Fstr_5Feq"><td class="memItemLeft">struct &#160;</td><td class="memItemRight"><a class="el" href="structjh_1_1atomic__str__eq.html">atomic_str_eq</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Custom equality functor for <code><a class="el" href="#af7d00b32739582480e12e4abeec9cac1" title="Atomically replaceable handle to an immutable string.">atomic_str_ptr</a></code> and compatible types.  <a href="structjh_1_1atomic__str__eq.html#details">More...</a><br /></td></tr>
<tr class="memitem:runtime_5Farr" id="r_runtime_5Farr"><td class="memItemLeft">class &#160;</td><td class="memItemRight"><a class="el" href="classjh_1_1runtime__arr.html">runtime_arr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A move-only, fixed-capacity array with runtime-determined length and RAII-based ownership.  <a href="classjh_1_1runtime__arr.html#details">More...</a><br /></td></tr>
<tr class="memitem:runtime_5Farr_3C_20bool_20_3E" id="r_runtime_5Farr_3C_20bool_20_3E"><td class="memItemLeft">class &#160;</td><td class="memItemRight"><a class="el" href="classjh_1_1runtime__arr_3_01bool_01_4.html">runtime_arr&lt; bool &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialized implementation of <code><a class="el" href="classjh_1_1runtime__arr_3_01bool_01_4.html" title="Specialized implementation of jh::runtime_arr&lt;bool&gt; — a compact, bit-packed boolean array.">jh::runtime_arr&lt;bool&gt;</a></code> — a compact, bit-packed boolean array.  <a href="classjh_1_1runtime__arr_3_01bool_01_4.html#details">More...</a><br /></td></tr>
<tr class="memitem:generator_5Frange" id="r_generator_5Frange"><td class="memItemLeft">class &#160;</td><td class="memItemRight"><a class="el" href="classjh_1_1generator__range.html">generator_range</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A range-like wrapper that enables iteration over a generator factory.  <a href="classjh_1_1generator__range.html#details">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-concepts" class="groupheader"><a id="concepts" name="concepts"></a>
Concepts</h2></td></tr>
<tr class="memitem:immutable_5Fstr_5Fcompatible" id="r_immutable_5Fstr_5Fcompatible"><td class="memItemLeft">concept &#160;</td><td class="memItemRight"><a class="el" href="conceptjh_1_1immutable__str__compatible.html">immutable_str_compatible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept for types compatible with <code><a class="el" href="classjh_1_1immutable__str.html" title="Immutable string with optional automatic trimming and thread-safe hash caching.">jh::immutable_str</a></code>. <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-typedef-members" class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:abc89d1d2a2d84b2aba124fe8d9ee1d7b" id="r_abc89d1d2a2d84b2aba124fe8d9ee1d7b"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:abc89d1d2a2d84b2aba124fe8d9ee1d7b template"><td class="memItemLeft">using&#160;</td><td class="memItemRight"><a class="el" href="#abc89d1d2a2d84b2aba124fe8d9ee1d7b">observe_pool</a></td></tr>
<tr class="memdesc:abc89d1d2a2d84b2aba124fe8d9ee1d7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Duck-typed alias of <code><a class="el" href="classjh_1_1conc_1_1pointer__pool.html" title="Weak pointer-observed pool for immutable or structurally immutable objects.">jh::conc::pointer_pool</a></code> for content-based pooling of immutable objects.  <br /></td></tr>
<tr class="memitem:a8eabe55fe3cf148e8b74b82dac631bec" id="r_a8eabe55fe3cf148e8b74b82dac631bec"><td class="memTemplParams" colspan="2">template&lt;typename Key, typename Value = jh::typed::monostate, typename Alloc = std::allocator&lt;jh::conc::detail::value_t&lt;Key, Value&gt;&gt;&gt; </td></tr>
<tr class="memitem:a8eabe55fe3cf148e8b74b82dac631bec template"><td class="memItemLeft">using&#160;</td><td class="memItemRight"><a class="el" href="#a8eabe55fe3cf148e8b74b82dac631bec">resource_pool</a> = <a class="el" href="classjh_1_1conc_1_1flat__pool.html">jh::conc::flat_pool</a>&lt;Key, Value, <a class="el" href="structjh_1_1hash.html">jh::hash</a>&lt;Key&gt;, Alloc&gt;</td></tr>
<tr class="memdesc:a8eabe55fe3cf148e8b74b82dac631bec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience alias of <code><a class="el" href="classjh_1_1conc_1_1flat__pool.html" title="Hash-ordered, contiguous resource interning pool.">jh::conc::flat_pool</a></code> with behaviorally deduced hashing.  <br /></td></tr>
<tr class="memitem:a75a3ccca5d795d8a10dd9bd5ca6e7201" id="r_a75a3ccca5d795d8a10dd9bd5ca6e7201"><td class="memTemplParams" colspan="2">template&lt;typename Key, typename Alloc = std::allocator&lt;Key&gt;&gt; </td></tr>
<tr class="memitem:a75a3ccca5d795d8a10dd9bd5ca6e7201 template"><td class="memItemLeft">using&#160;</td><td class="memItemRight"><a class="el" href="#a75a3ccca5d795d8a10dd9bd5ca6e7201">resource_pool_set</a> = <a class="el" href="classjh_1_1conc_1_1flat__pool.html">jh::conc::flat_pool</a>&lt;Key, <a class="el" href="structjh_1_1typed_1_1monostate.html">jh::typed::monostate</a>, <a class="el" href="structjh_1_1hash.html">jh::hash</a>&lt;Key&gt;, Alloc&gt;</td></tr>
<tr class="memdesc:a75a3ccca5d795d8a10dd9bd5ca6e7201"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set-style specialization of <code><a class="el" href="#a8eabe55fe3cf148e8b74b82dac631bec" title="Convenience alias of jh::conc::flat_pool with behaviorally deduced hashing.">jh::resource_pool</a></code>.  <br /></td></tr>
<tr class="memitem:af7d00b32739582480e12e4abeec9cac1" id="r_af7d00b32739582480e12e4abeec9cac1"><td class="memItemLeft">using&#160;</td><td class="memItemRight"><a class="el" href="#af7d00b32739582480e12e4abeec9cac1">atomic_str_ptr</a> = std::shared_ptr&lt;<a class="el" href="classjh_1_1immutable__str.html">immutable_str</a>&gt;</td></tr>
<tr class="memdesc:af7d00b32739582480e12e4abeec9cac1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically replaceable handle to an immutable string.  <br /></td></tr>
<tr class="memitem:a7d49c250af115c5a63acb88c1b38c3ec" id="r_a7d49c250af115c5a63acb88c1b38c3ec"><td class="memTemplParams" colspan="2">template&lt;typename K, typename Alloc = std::allocator&lt;K&gt;&gt; </td></tr>
<tr class="memitem:a7d49c250af115c5a63acb88c1b38c3ec template"><td class="memItemLeft">using&#160;</td><td class="memItemRight"><a class="el" href="#a7d49c250af115c5a63acb88c1b38c3ec">ordered_set</a></td></tr>
<tr class="memdesc:a7d49c250af115c5a63acb88c1b38c3ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ordered associative set based on a contiguous-array AVL tree.  <br /></td></tr>
<tr class="memitem:adc97eb86056b9268c8b5c7378587c2be" id="r_adc97eb86056b9268c8b5c7378587c2be"><td class="memTemplParams" colspan="2">template&lt;typename K, typename V, typename Alloc = std::allocator&lt;std::pair&lt;const K, V&gt;&gt;&gt; </td></tr>
<tr class="memitem:adc97eb86056b9268c8b5c7378587c2be template"><td class="memItemLeft">using&#160;</td><td class="memItemRight"><a class="el" href="#adc97eb86056b9268c8b5c7378587c2be">ordered_map</a></td></tr>
<tr class="memdesc:adc97eb86056b9268c8b5c7378587c2be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ordered associative map based on a contiguous-array AVL tree.  <br /></td></tr>
<tr class="memitem:aa319d5ba6c1957e7e6ae45673ae7c5a3" id="r_aa319d5ba6c1957e7e6ae45673ae7c5a3"><td class="memTemplParams" colspan="2"><a id="aa319d5ba6c1957e7e6ae45673ae7c5a3" name="aa319d5ba6c1957e7e6ae45673ae7c5a3"></a>
template&lt;typename T, typename U = typed::monostate&gt; </td></tr>
<tr class="memitem:aa319d5ba6c1957e7e6ae45673ae7c5a3 template"><td class="memItemLeft">using&#160;</td><td class="memItemRight"><b>generator</b> = <a class="el" href="classjh_1_1async_1_1generator.html">async::generator</a>&lt;T, U&gt;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a58aa95803840fb814bf92dd4954fb44c" id="r_a58aa95803840fb814bf92dd4954fb44c"><td class="memTemplParams" colspan="2">template&lt;typename F&gt; </td></tr>
<tr class="memitem:a58aa95803840fb814bf92dd4954fb44c template"><td class="memItemLeft">auto&#160;</td><td class="memItemRight"><a class="el" href="#a58aa95803840fb814bf92dd4954fb44c">to_range</a> (F &amp;&amp;f)</td></tr>
<tr class="memdesc:a58aa95803840fb814bf92dd4954fb44c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a generator factory (lambda or function) into a repeatable range.  <br /></td></tr>
<tr class="memitem:a462596edb2143953930b42ca4f9f96a1" id="r_a462596edb2143953930b42ca4f9f96a1"><td class="memTemplParams" colspan="2">template&lt;concepts::sequence Seq&gt; </td></tr>
<tr class="memitem:a462596edb2143953930b42ca4f9f96a1 template"><td class="memItemLeft">decltype(auto)&#160;</td><td class="memItemRight"><a class="el" href="#a462596edb2143953930b42ca4f9f96a1">to_range</a> (Seq &amp;&amp;s)</td></tr>
<tr class="memdesc:a462596edb2143953930b42ca4f9f96a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a sequence into a usable <code>std::ranges::range</code> object.  <br /></td></tr>
<tr class="memitem:aa5496e72bc5c5463742f77f45882f042" id="r_aa5496e72bc5c5463742f77f45882f042"><td class="memTemplParams" colspan="2"><a id="aa5496e72bc5c5463742f77f45882f042" name="aa5496e72bc5c5463742f77f45882f042"></a>
template&lt;typename T&gt; </td></tr>
<tr class="memitem:aa5496e72bc5c5463742f77f45882f042 template"><td class="memItemLeft"><a class="el" href="#af7d00b32739582480e12e4abeec9cac1">atomic_str_ptr</a>&#160;</td><td class="memItemRight"><b>make_atomic</b> (T str)=delete</td></tr>
<tr class="memitem:a310dcaec492c2c916669c623cbdbd34a" id="r_a310dcaec492c2c916669c623cbdbd34a"><td class="memItemLeft"><a class="el" href="#af7d00b32739582480e12e4abeec9cac1">atomic_str_ptr</a>&#160;</td><td class="memItemRight"><a class="el" href="#a310dcaec492c2c916669c623cbdbd34a">make_atomic</a> (const char *str)</td></tr>
<tr class="memdesc:a310dcaec492c2c916669c623cbdbd34a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a shared pointer to an <code><a class="el" href="classjh_1_1immutable__str.html" title="Immutable string with optional automatic trimming and thread-safe hash caching.">immutable_str</a></code>.  <br /></td></tr>
<tr class="memitem:a507177b377c063e2200fbf0518f9460e" id="r_a507177b377c063e2200fbf0518f9460e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="conceptjh_1_1concepts_1_1mutex__like.html">jh::concepts::mutex_like</a> M&gt; </td></tr>
<tr class="memitem:a507177b377c063e2200fbf0518f9460e template"><td class="memItemLeft"><a class="el" href="#af7d00b32739582480e12e4abeec9cac1">atomic_str_ptr</a>&#160;</td><td class="memItemRight"><a class="el" href="#a507177b377c063e2200fbf0518f9460e">safe_from</a> (std::string_view sv, M &amp;mtx)</td></tr>
<tr class="memdesc:a507177b377c063e2200fbf0518f9460e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a shared pointer to an <code><a class="el" href="classjh_1_1immutable__str.html" title="Immutable string with optional automatic trimming and thread-safe hash caching.">immutable_str</a></code> from a locked string view.  <br /></td></tr>
<tr class="memitem:a91b3ce49da3a766df2cc5820e813a38b" id="r_a91b3ce49da3a766df2cc5820e813a38b"><td class="memTemplParams" colspan="2">template&lt;concepts::sequence SeqType&gt; </td></tr>
<tr class="memitem:a91b3ce49da3a766df2cc5820e813a38b template"><td class="memItemLeft">generator&lt; <a class="el" href="namespacejh_1_1concepts.html#a288fd2a9c1ffde90dc5ca09475e9cd3f">concepts::sequence_value_t</a>&lt; SeqType &gt; &gt;&#160;</td><td class="memItemRight"><a class="el" href="#a91b3ce49da3a766df2cc5820e813a38b">make_generator</a> (const SeqType &amp;seq)</td></tr>
<tr class="memdesc:a91b3ce49da3a766df2cc5820e813a38b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a duck-typed <b>sequence-like</b> object into a generator.  <br /></td></tr>
<tr class="memitem:a17777ad53ec96266cfc3e5d7abe763c8" id="r_a17777ad53ec96266cfc3e5d7abe763c8"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a17777ad53ec96266cfc3e5d7abe763c8 template"><td class="memItemLeft">std::vector&lt; T &gt;&#160;</td><td class="memItemRight"><a class="el" href="#a17777ad53ec96266cfc3e5d7abe763c8">to_vector</a> (generator&lt; T &gt; &amp;gen)</td></tr>
<tr class="memdesc:a17777ad53ec96266cfc3e5d7abe763c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collects all yielded values from a generator into a <code>std::vector</code>.  <br /></td></tr>
<tr class="memitem:aa136f6ea5f81fa00a4f1bf070cd8ff97" id="r_aa136f6ea5f81fa00a4f1bf070cd8ff97"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:aa136f6ea5f81fa00a4f1bf070cd8ff97 template"><td class="memItemLeft">std::deque&lt; T &gt;&#160;</td><td class="memItemRight"><a class="el" href="#aa136f6ea5f81fa00a4f1bf070cd8ff97">to_deque</a> (generator&lt; T &gt; &amp;gen)</td></tr>
<tr class="memdesc:aa136f6ea5f81fa00a4f1bf070cd8ff97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collects all yielded values from a generator into a <code>std::deque</code>.  <br /></td></tr>
</table>
<a name="doc-typedef-members" id="doc-typedef-members"></a><h2 id="header-doc-typedef-members" class="groupheader">Typedef Documentation</h2>
<a id="af7d00b32739582480e12e4abeec9cac1" name="af7d00b32739582480e12e4abeec9cac1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7d00b32739582480e12e4abeec9cac1">&#9670;&#160;</a></span>atomic_str_ptr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#af7d00b32739582480e12e4abeec9cac1">jh::atomic_str_ptr</a> = std::shared_ptr&lt;<a class="el" href="classjh_1_1immutable__str.html">immutable_str</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomically replaceable handle to an immutable string. </p>
<p>An <code><a class="el" href="#af7d00b32739582480e12e4abeec9cac1" title="Atomically replaceable handle to an immutable string.">atomic_str_ptr</a></code> is simply a <code>std::shared_ptr&lt;immutable_str&gt;</code>. </p>
<p>Since <code>std::shared_ptr</code> has built-in atomic operations (<code>atomic_load</code>, <code>atomic_store</code>, <code>atomic_exchange</code>, <code>atomic_compare_exchange_*</code>, as well as their <code>*_explict</code> forms) and <code><a class="el" href="classjh_1_1immutable__str.html" title="Immutable string with optional automatic trimming and thread-safe hash caching.">jh::immutable_str</a></code> is itself immutable, the pointer can be safely loaded, stored, or replaced across threads without any additional synchronization. </p>
<ul>
<li>
Atomicity is provided by <code>std::shared_ptr</code> (C++11+). </li>
<li>
The underlying string never mutates, only the pointer changes. </li>
<li>
Suitable for concurrent configuration, caches, and shared views. </li>
</ul>

</div>
</div>
<a id="abc89d1d2a2d84b2aba124fe8d9ee1d7b" name="abc89d1d2a2d84b2aba124fe8d9ee1d7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc89d1d2a2d84b2aba124fe8d9ee1d7b">&#9670;&#160;</a></span>observe_pool</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#abc89d1d2a2d84b2aba124fe8d9ee1d7b">jh::observe_pool</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line"><a class="code hl_class" href="classjh_1_1conc_1_1pointer__pool.html">conc::pointer_pool&lt;T, weak_ptr_hash&lt;T&gt;</a>, <a class="code hl_struct" href="structjh_1_1weak__ptr__eq.html">weak_ptr_eq&lt;T&gt;</a>&gt;</div>
<div class="ttc" id="aclassjh_1_1conc_1_1pointer__pool_html"><div class="ttname"><a href="classjh_1_1conc_1_1pointer__pool.html">jh::conc::pointer_pool</a></div><div class="ttdoc">Weak pointer-observed pool for immutable or structurally immutable objects.</div><div class="ttdef"><b>Definition</b> pointer_pool.h:260</div></div>
<div class="ttc" id="astructjh_1_1weak__ptr__eq_html"><div class="ttname"><a href="structjh_1_1weak__ptr__eq.html">jh::weak_ptr_eq</a></div><div class="ttdoc">Equality functor for std::weak_ptr&lt;T&gt;.</div><div class="ttdef"><b>Definition</b> observe_pool.h:144</div></div>
</div><!-- fragment -->
<p>Duck-typed alias of <code><a class="el" href="classjh_1_1conc_1_1pointer__pool.html" title="Weak pointer-observed pool for immutable or structurally immutable objects.">jh::conc::pointer_pool</a></code> for content-based pooling of immutable objects. </p>
<p><code><a class="el" href="#abc89d1d2a2d84b2aba124fe8d9ee1d7b" title="Duck-typed alias of jh::conc::pointer_pool for content-based pooling of immutable objects.">jh::observe_pool&lt;T&gt;</a></code> provides logical deduplication of shared objects based on content hashing and equality. Objects are observed via <code>std::weak_ptr</code> and are never owned by the pool. </p>
<p>All concurrency, cleanup, and adaptive resizing behavior is defined entirely by <code><a class="el" href="classjh_1_1conc_1_1pointer__pool.html" title="Weak pointer-observed pool for immutable or structurally immutable objects.">jh::conc::pointer_pool</a></code>, of which <code><a class="el" href="#abc89d1d2a2d84b2aba124fe8d9ee1d7b" title="Duck-typed alias of jh::conc::pointer_pool for content-based pooling of immutable objects.">observe_pool</a></code> is a direct alias with fixed template parameters. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The pooled object type. <code>T</code> must be logically immutable, satisfy <code><a class="el" href="conceptjh_1_1concepts_1_1extended__hashable.html" title="Concept for types that can be hashed through any supported mechanism.">jh::concepts::extended_hashable</a></code>, and support content-based <code>operator==</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><b>Usage guidance:</b> <br  />
 <code><a class="el" href="#abc89d1d2a2d84b2aba124fe8d9ee1d7b" title="Duck-typed alias of jh::conc::pointer_pool for content-based pooling of immutable objects.">jh::observe_pool</a></code> relies on <code>std::shared_ptr</code> / <code>std::weak_ptr</code> for object tracking. This inevitably introduces heap fragmentation and reference-counting overhead. It is therefore intended only for types that are <b>neither copyable nor movable</b>, and for workloads where the total number of live objects and concurrency level remain modest. Excessive object counts or high parallel pressure may lead to allocation jitter and degraded performance. <br  />
 On Windows platforms using the Universal CRT (including MinGW variants), <code>std::shared_ptr</code> is not reliably thread-safe under contention. Practical limits are significantly lower than on other platforms; it is recommended to keep concurrency within approximately <b>4 threads</b> and the total number of live pooled objects within roughly <b>2k</b>. <br  />
 If the managed type is at least copyable or movable, prefer <code><a class="el" href="#a8eabe55fe3cf148e8b74b82dac631bec" title="Convenience alias of jh::conc::flat_pool with behaviorally deduced hashing.">jh::resource_pool&lt;T&gt;</a></code>. If a stable key can be used to identify objects, prefer <code><a class="el" href="#a8eabe55fe3cf148e8b74b82dac631bec" title="Convenience alias of jh::conc::flat_pool with behaviorally deduced hashing.">jh::resource_pool&lt;K, V&gt;</a></code>. When a key is available but the value type is neither copyable nor movable, using <code><a class="el" href="#a8eabe55fe3cf148e8b74b82dac631bec" title="Convenience alias of jh::conc::flat_pool with behaviorally deduced hashing.">jh::resource_pool&lt;K, std::shared_ptr&lt;V&gt;&gt;</a></code> is often a better alternative: hashing and equality are applied only to the key, avoiding expensive object-level comparisons and large-scale rehash jitter during resizing. </dd></dl>

</div>
</div>
<a id="adc97eb86056b9268c8b5c7378587c2be" name="adc97eb86056b9268c8b5c7378587c2be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc97eb86056b9268c8b5c7378587c2be">&#9670;&#160;</a></span>ordered_map</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, typename Alloc = std::allocator&lt;std::pair&lt;const K, V&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#adc97eb86056b9268c8b5c7378587c2be">jh::ordered_map</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line"><a class="code hl_class" href="classjh_1_1avl_1_1tree__map.html">avl::tree_map&lt;K, V, Alloc&gt;</a></div>
<div class="ttc" id="aclassjh_1_1avl_1_1tree__map_html"><div class="ttname"><a href="classjh_1_1avl_1_1tree__map.html">jh::avl::tree_map</a></div><div class="ttdoc">Contiguous-array AVL tree used by jh::ordered_map and jh::ordered_set.</div><div class="ttdef"><b>Definition</b> ordered_map.h:651</div></div>
</div><!-- fragment -->
<p>Ordered associative map based on a contiguous-array AVL tree. </p>
<p>This alias provides an ordered map storing unique keys of type <code>K</code> and mapped values of type <code>V</code>. The semantics match those of <code>std::map</code>: keys are unique, elements are stored in sorted key order, and the mapped value is accessible via key lookup or iterator dereferencing. Internally this type is backed by <code><a class="el" href="classjh_1_1avl_1_1tree__map.html" title="Contiguous-array AVL tree used by jh::ordered_map and jh::ordered_set.">avl::tree_map</a></code>, using a contiguous storage layout rather than the pointer-based red-black tree used by STL maps.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K</td><td>Key type. </td></tr>
    <tr><td class="paramname">V</td><td>Mapped value type. </td></tr>
    <tr><td class="paramname">Alloc</td><td>Allocator used for internal node storage. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7d49c250af115c5a63acb88c1b38c3ec" name="a7d49c250af115c5a63acb88c1b38c3ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d49c250af115c5a63acb88c1b38c3ec">&#9670;&#160;</a></span>ordered_set</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename Alloc = std::allocator&lt;K&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a7d49c250af115c5a63acb88c1b38c3ec">jh::ordered_set</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line"><a class="code hl_class" href="classjh_1_1avl_1_1tree__map.html">avl::tree_map&lt;K, jh::typed::monostate, Alloc&gt;</a></div>
</div><!-- fragment -->
<p>Ordered associative set based on a contiguous-array AVL tree. </p>
<p>This alias provides a set-like container storing unique keys of type <code>K</code>. The semantics match those of <code>std::set</code>: keys are unique, sorted in strictly increasing order, and no mapped value is stored. Internally this type is implemented using <code><a class="el" href="classjh_1_1avl_1_1tree__map.html" title="Contiguous-array AVL tree used by jh::ordered_map and jh::ordered_set.">avl::tree_map</a></code> with <code>monostate</code> as its value type, yielding a compact and allocation-free node layout.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K</td><td>Key type stored in the set. </td></tr>
    <tr><td class="paramname">Alloc</td><td>Allocator used for internal node storage. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8eabe55fe3cf148e8b74b82dac631bec" name="a8eabe55fe3cf148e8b74b82dac631bec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8eabe55fe3cf148e8b74b82dac631bec">&#9670;&#160;</a></span>resource_pool</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key, typename Value = jh::typed::monostate, typename Alloc = std::allocator&lt;jh::conc::detail::value_t&lt;Key, Value&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a8eabe55fe3cf148e8b74b82dac631bec">jh::resource_pool</a> = <a class="el" href="classjh_1_1conc_1_1flat__pool.html">jh::conc::flat_pool</a>&lt;Key, Value, <a class="el" href="structjh_1_1hash.html">jh::hash</a>&lt;Key&gt;, Alloc&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience alias of <code><a class="el" href="classjh_1_1conc_1_1flat__pool.html" title="Hash-ordered, contiguous resource interning pool.">jh::conc::flat_pool</a></code> with behaviorally deduced hashing. </p>
<p><code><a class="el" href="#a8eabe55fe3cf148e8b74b82dac631bec" title="Convenience alias of jh::conc::flat_pool with behaviorally deduced hashing.">jh::resource_pool&lt;Key, Value, Alloc&gt;</a></code> is a direct alias of <code><a class="el" href="classjh_1_1conc_1_1flat__pool.html" title="Hash-ordered, contiguous resource interning pool.">jh::conc::flat_pool</a></code> that fixes the hash functor to <code><a class="el" href="structjh_1_1hash.html" title="Behaviorally deduced hash functor.">jh::hash&lt;Key&gt;</a></code>. No additional abstraction layer or duck-typing mechanism is introduced. </p>
<p>The alias relies on <code><a class="el" href="structjh_1_1hash.html" title="Behaviorally deduced hash functor.">jh::hash&lt;Key&gt;</a></code> to successfully resolve a hashing strategy for <code>Key</code>, following its resolution order: <code>std::hash</code>, ADL-discovered free <code>hash(key)</code>, or <code>key.hash()</code>. </p>
<p>This design preserves the full behavior and constraints of <code><a class="el" href="classjh_1_1conc_1_1flat__pool.html" title="Hash-ordered, contiguous resource interning pool.">jh::conc::flat_pool</a></code> while reducing template verbosity for the common case where no custom hash functor is required. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Key</td><td>The key type defining logical identity. <code>Key</code> must satisfy <code><a class="el" href="conceptjh_1_1concepts_1_1extended__hashable.html" title="Concept for types that can be hashed through any supported mechanism.">jh::concepts::extended_hashable</a></code> and <code><a class="el" href="conceptjh_1_1concepts_1_1is__contiguous__reallocable.html" title="Concept that constrains types usable in contiguous, reallocating containers.">jh::concepts::is_contiguous_reallocable</a></code>.</td></tr>
    <tr><td class="paramname">Value</td><td>The value type stored in the pool. Must either be <code><a class="el" href="structjh_1_1typed_1_1monostate.html" title="Trivial empty type representing &quot;no value&quot;.">jh::typed::monostate</a></code> or satisfy <code><a class="el" href="conceptjh_1_1concepts_1_1is__contiguous__reallocable.html" title="Concept that constrains types usable in contiguous, reallocating containers.">jh::concepts::is_contiguous_reallocable</a></code>.</td></tr>
    <tr><td class="paramname">Alloc</td><td>Allocator used for internal storage. Defaults to an allocator compatible with the underlying <code>flat_pool</code> value representation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><b>Design intent:</b> <br  />
 <code><a class="el" href="#a8eabe55fe3cf148e8b74b82dac631bec" title="Convenience alias of jh::conc::flat_pool with behaviorally deduced hashing.">jh::resource_pool</a></code> exists solely to reduce the cognitive and syntactic cost of using <code>flat_pool</code> in the common case. <br  />
 When a nonstandard hashing strategy is required, users should instantiate <code><a class="el" href="classjh_1_1conc_1_1flat__pool.html" title="Hash-ordered, contiguous resource interning pool.">jh::conc::flat_pool</a></code> directly with an explicit hash functor. </dd></dl>

</div>
</div>
<a id="a75a3ccca5d795d8a10dd9bd5ca6e7201" name="a75a3ccca5d795d8a10dd9bd5ca6e7201"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75a3ccca5d795d8a10dd9bd5ca6e7201">&#9670;&#160;</a></span>resource_pool_set</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key, typename Alloc = std::allocator&lt;Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a75a3ccca5d795d8a10dd9bd5ca6e7201">jh::resource_pool_set</a> = <a class="el" href="classjh_1_1conc_1_1flat__pool.html">jh::conc::flat_pool</a>&lt;Key, <a class="el" href="structjh_1_1typed_1_1monostate.html">jh::typed::monostate</a>, <a class="el" href="structjh_1_1hash.html">jh::hash</a>&lt;Key&gt;, Alloc&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set-style specialization of <code><a class="el" href="#a8eabe55fe3cf148e8b74b82dac631bec" title="Convenience alias of jh::conc::flat_pool with behaviorally deduced hashing.">jh::resource_pool</a></code>. </p>
<p><code><a class="el" href="#a75a3ccca5d795d8a10dd9bd5ca6e7201" title="Set-style specialization of jh::resource_pool.">jh::resource_pool_set&lt;Key&gt;</a></code> is an alias of <code><a class="el" href="classjh_1_1conc_1_1flat__pool.html" title="Hash-ordered, contiguous resource interning pool.">jh::conc::flat_pool</a></code> with <code>Value</code> fixed to <code><a class="el" href="structjh_1_1typed_1_1monostate.html" title="Trivial empty type representing &quot;no value&quot;.">jh::typed::monostate</a></code>. It represents a concurrent pool of unique keys with no associated payload. </p>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="a310dcaec492c2c916669c623cbdbd34a" name="a310dcaec492c2c916669c623cbdbd34a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a310dcaec492c2c916669c623cbdbd34a">&#9670;&#160;</a></span>make_atomic()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#af7d00b32739582480e12e4abeec9cac1">atomic_str_ptr</a> jh::make_atomic </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a shared pointer to an <code><a class="el" href="classjh_1_1immutable__str.html" title="Immutable string with optional automatic trimming and thread-safe hash caching.">immutable_str</a></code>. </p>
<p>Constructs a new <code><a class="el" href="classjh_1_1immutable__str.html" title="Immutable string with optional automatic trimming and thread-safe hash caching.">jh::immutable_str</a></code> instance from a null-terminated C-string and wraps it in a <code>std::shared_ptr</code>. This is the standard factory function for creating atomic, immutable string objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Null-terminated C-string to initialize from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Shared pointer (<code><a class="el" href="#af7d00b32739582480e12e4abeec9cac1" title="Atomically replaceable handle to an immutable string.">atomic_str_ptr</a></code>) managing the constructed <code><a class="el" href="classjh_1_1immutable__str.html" title="Immutable string with optional automatic trimming and thread-safe hash caching.">immutable_str</a></code> instance.</dd></dl>
<ul>
<li>
Performs a direct construction of <code><a class="el" href="classjh_1_1immutable__str.html" title="Immutable string with optional automatic trimming and thread-safe hash caching.">immutable_str</a></code> without intermediate copies or moves. </li>
<li>
The returned object is reference-counted via <code>std::shared_ptr</code> and can be safely shared across threads. </li>
<li>
Trimming behavior (if enabled) follows <code>JH_IMMUTABLE_STR_AUTO_TRIM</code>. </li>
</ul>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>
Because <code><a class="el" href="classjh_1_1immutable__str.html" title="Immutable string with optional automatic trimming and thread-safe hash caching.">immutable_str</a></code> is non-copyable and non-movable, this factory is the only supported way to allocate it on the heap. </li>
<li>
Once constructed, the lifetime of the string is bound to its <code>std::shared_ptr</code> instance. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a91b3ce49da3a766df2cc5820e813a38b" name="a91b3ce49da3a766df2cc5820e813a38b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91b3ce49da3a766df2cc5820e813a38b">&#9670;&#160;</a></span>make_generator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;concepts::sequence SeqType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">generator&lt; <a class="el" href="namespacejh_1_1concepts.html#a288fd2a9c1ffde90dc5ca09475e9cd3f">concepts::sequence_value_t</a>&lt; SeqType &gt; &gt; <a class="el" href="namespacejh_1_1async.html#a91b3ce49da3a766df2cc5820e813a38b">jh::async::make_generator</a> </td>
          <td>(</td>
          <td class="paramtype">const SeqType &amp;</td>          <td class="paramname"><span class="paramname"><em>seq</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a duck-typed <b>sequence-like</b> object into a generator. </p>
<p>This overload provides the <b>most permissive</b> fallback version of <code><a class="el" href="#a91b3ce49da3a766df2cc5820e813a38b" title="Converts a duck-typed sequence-like object into a generator.">make_generator()</a></code>. It accepts any type that satisfies the minimal <code>jh::sequence</code> concept: having <code>begin()</code> and <code>end()</code> returning readable iterators and supporting <code>!=</code> comparison.</p>
<p>Unlike <code>std::ranges::range</code>, a <code>jh::sequence</code> does <b>not</b> guarantee forwarding or lifetime semantics — only that it can be read immutably. Therefore, this overload uses <b>const reference</b> and avoids forwarding or move-based iteration. </p>
<ul>
<li>
Acts as a <b>duck-typed fallback</b> for legacy or lightweight containers that behave like ranges but are not formally defined as such. </li>
<li>
Preserves the minimal safety invariant: iteration must not mutate <code>seq</code>. </li>
<li>
Ensures compatibility with <b>immutable const iteration</b> even in non-range-conforming types. </li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SeqType</td><td>The input sequence type; must satisfy <code>jh::sequence</code> but not <code>std::ranges::range</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seq</td><td>The sequence-like object to convert (read-only). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A generator yielding elements from <code>seq</code>. </dd></dl>

</div>
</div>
<a id="a507177b377c063e2200fbf0518f9460e" name="a507177b377c063e2200fbf0518f9460e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a507177b377c063e2200fbf0518f9460e">&#9670;&#160;</a></span>safe_from()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="conceptjh_1_1concepts_1_1mutex__like.html">jh::concepts::mutex_like</a> M&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#af7d00b32739582480e12e4abeec9cac1">atomic_str_ptr</a> jh::safe_from </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>sv</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M &amp;</td>          <td class="paramname"><span class="paramname"><em>mtx</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a shared pointer to an <code><a class="el" href="classjh_1_1immutable__str.html" title="Immutable string with optional automatic trimming and thread-safe hash caching.">immutable_str</a></code> from a locked string view. </p>
<p>Constructs a new <code><a class="el" href="classjh_1_1immutable__str.html" title="Immutable string with optional automatic trimming and thread-safe hash caching.">jh::immutable_str</a></code> using a <code>std::string_view</code> and an associated mutex-like object that guards the view's lifetime. This ensures thread-safe initialization from potentially mutable or shared buffers. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">M</td><td>Any type satisfying <code><a class="el" href="conceptjh_1_1concepts_1_1mutex__like.html" title="General mutex-like concept.">jh::concepts::mutex_like</a></code>, such as <code>std::mutex</code>, <code>std::shared_mutex</code>, or <code><a class="el" href="structjh_1_1typed_1_1null__mutex__t.html" title="Semantic placeholder for mutex_like types.">jh::typed::null_mutex_t</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sv</td><td>String view referencing existing string data. </td></tr>
    <tr><td class="paramname">mtx</td><td>Mutex-like object protecting the lifetime of the structure that owns <code>sv</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Shared pointer (<code><a class="el" href="#af7d00b32739582480e12e4abeec9cac1" title="Atomically replaceable handle to an immutable string.">atomic_str_ptr</a></code>) managing the constructed <code><a class="el" href="classjh_1_1immutable__str.html" title="Immutable string with optional automatic trimming and thread-safe hash caching.">immutable_str</a></code> instance.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>If <code>sv</code> contains embedded null (<code>'\0'</code>) characters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd><ul>
<li>
The caller must ensure that <code>mtx</code> correctly protects the memory region referenced by <code>sv</code>. </li>
<li>
Providing an unrelated or unlocked mutex may result in undefined behavior. </li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>
This overload is used when <code>std::string_view</code> refers to data from temporary, mutable, or shared contexts that require explicit synchronization. </li>
<li>
When the data is guaranteed to be thread-local or immutable, <code><a class="el" href="namespacejh_1_1typed.html#a026542219730998fd7f5830fc6ad1eb3" title="Global constant instance of null_mutex_t.">jh::typed::null_mutex</a></code> may be used for zero-cost locking. </li>
<li>
Because <code><a class="el" href="classjh_1_1immutable__str.html" title="Immutable string with optional automatic trimming and thread-safe hash caching.">immutable_str</a></code> cannot be copied or moved, it must always be constructed via this factory or <code>make_atomic()</code>. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="aa136f6ea5f81fa00a4f1bf070cd8ff97" name="aa136f6ea5f81fa00a4f1bf070cd8ff97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa136f6ea5f81fa00a4f1bf070cd8ff97">&#9670;&#160;</a></span>to_deque()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::deque&lt; T &gt; <a class="el" href="namespacejh_1_1async.html#aa136f6ea5f81fa00a4f1bf070cd8ff97">jh::async::to_deque</a> </td>
          <td>(</td>
          <td class="paramtype">generator&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>gen</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collects all yielded values from a generator into a <code>std::deque</code>. </p>
<p>This overload applies to generators that produce values but do not receive input (<code>U == <a class="el" href="structjh_1_1typed_1_1monostate.html" title="Trivial empty type representing &quot;no value&quot;.">typed::monostate</a></code>). It repeatedly advances the coroutine using <code>next()</code> until completion, appending each yielded element into a <code>std::deque</code>.</p>
<ul>
<li>
Designed for output-only generators. </li>
<li>
Maintains stable iterator validity across insertions. </li>
<li>
Uses the fastest STL <b>segmented linear container</b>, ideal for frequent <code>push_back()</code> operations. </li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The generator's <b>yielded value type</b>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gen</td><td>The generator instance to collect from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>std::deque</code> containing all yielded elements in order. </dd></dl>

</div>
</div>
<a id="a58aa95803840fb814bf92dd4954fb44c" name="a58aa95803840fb814bf92dd4954fb44c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58aa95803840fb814bf92dd4954fb44c">&#9670;&#160;</a></span>to_range() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto jh::to_range </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a generator factory (lambda or function) into a repeatable range. </p>
<p>This helper transforms a callable object that returns <code><a class="el" href="classjh_1_1async_1_1generator.html" title="Coroutine-based generator supporting both yielding and receiving values.">jh::async::generator&lt;T&gt;</a></code> (with <code>U == <a class="el" href="structjh_1_1typed_1_1monostate.html" title="Trivial empty type representing &quot;no value&quot;.">typed::monostate</a></code>) into a <code><a class="el" href="classjh_1_1async_1_1generator__range.html" title="A range-like wrapper that enables iteration over a generator factory.">jh::async::generator_range&lt;T&gt;</a></code>. The resulting object supports multiple independent iterations, since each call to <code>begin()</code> constructs a new generator instance.</p>
<p>The callable must take <b>no arguments</b>: </p>
<ul>
<li>
<code><a class="el" href="classjh_1_1async_1_1generator.html" title="Coroutine-based generator supporting both yielding and receiving values.">jh::async::generator&lt;T&gt;</a> func()</code> </li>
<li>
<code>[=]() -&gt; <a class="el" href="classjh_1_1async_1_1generator.html" title="Coroutine-based generator supporting both yielding and receiving values.">jh::async::generator&lt;T&gt;</a> { ... }</code> </li>
<li>
<code>[&amp;]() -&gt; <a class="el" href="classjh_1_1async_1_1generator.html" title="Coroutine-based generator supporting both yielding and receiving values.">jh::async::generator&lt;T&gt;</a> { ... }</code> </li>
<li>
<code>[+]() -&gt; <a class="el" href="classjh_1_1async_1_1generator.html" title="Coroutine-based generator supporting both yielding and receiving values.">jh::async::generator&lt;T&gt;</a> { ... }</code> </li>
</ul>
<p>Any captured state must be enclosed within the lambda's closure. External parameters cannot be forwarded dynamically. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>A callable returning <code><a class="el" href="classjh_1_1async_1_1generator.html" title="Coroutine-based generator supporting both yielding and receiving values.">jh::async::generator&lt;T&gt;</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>A generator factory function (no arguments). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A repeatable, range-compatible wrapper for the generator.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classjh_1_1async_1_1generator__range.html" title="A range-like wrapper that enables iteration over a generator factory.">jh::async::generator_range</a> </dd></dl>

</div>
</div>
<a id="a462596edb2143953930b42ca4f9f96a1" name="a462596edb2143953930b42ca4f9f96a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a462596edb2143953930b42ca4f9f96a1">&#9670;&#160;</a></span>to_range() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;concepts::sequence Seq&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) jh::to_range </td>
          <td>(</td>
          <td class="paramtype">Seq &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a sequence into a usable <code>std::ranges::range</code> object. </p>
<p>This is the user-facing interface for range conversion. It guarantees that any valid <code><a class="el" href="conceptjh_1_1concepts_1_1sequence.html" title="Concept that checks whether a type provides at least const (non-destructive) iteration.">jh::concepts::sequence</a></code> can be transformed into an object that models <code>std::ranges::range</code>, regardless of whether the original type is movable, copyable, or a simple sequence-like container. </p>
<p>The conversion is <b>idempotent</b> — if the input already models <code>std::ranges::range</code> and is safely movable or copyable, it is forwarded unchanged. Otherwise, the function wraps or adapts it internally to ensure range compatibility and reference safety. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Seq</td><td>A type satisfying <code><a class="el" href="conceptjh_1_1concepts_1_1sequence.html" title="Concept that checks whether a type provides at least const (non-destructive) iteration.">jh::concepts::sequence</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The input sequence to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An object guaranteed to model <code>std::ranges::range</code>, ready for direct use in range-based for loops or <code><a class="el" href="namespacestd_1_1ranges.html">std::ranges</a></code> algorithms. </dd></dl>

</div>
</div>
<a id="a17777ad53ec96266cfc3e5d7abe763c8" name="a17777ad53ec96266cfc3e5d7abe763c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17777ad53ec96266cfc3e5d7abe763c8">&#9670;&#160;</a></span>to_vector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; <a class="el" href="namespacejh_1_1async.html#a17777ad53ec96266cfc3e5d7abe763c8">jh::async::to_vector</a> </td>
          <td>(</td>
          <td class="paramtype">generator&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>gen</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collects all yielded values from a generator into a <code>std::vector</code>. </p>
<p>This overload applies to generators that produce values but do not receive input (<code>U == <a class="el" href="structjh_1_1typed_1_1monostate.html" title="Trivial empty type representing &quot;no value&quot;.">typed::monostate</a></code>). It repeatedly advances the coroutine using <code>next()</code> until completion, copying each yielded value into a contiguous <code>std::vector</code>.</p>
<ul>
<li>
Intended for output-only generators. </li>
<li>
Preserves iteration order and copies each yielded element. </li>
<li>
Acts as the most lightweight way to "materialize" a generator sequence. </li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The generator's <b>yielded value type</b>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gen</td><td>The generator instance to collect from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>std::vector</code> containing all yielded elements in order. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
</div> <!-- top -->
<hr class="footer"/>
<div class="footer">
    <img class="footer-logo" src="Ojing.svg" alt="Ojing"/>
    <div class="footer-text">
        JH-Toolkit v1.4.0 · Generated by Doxygen
    </div>
    <div class="footer-note">
        We primarily support embedded documentation views in IDEs (classic CLion).
        To ensure compatibility with embedded rendering, some example code in this
        documentation intentionally contains HTML entities.
        In certain cases, Doxygen does not unescape these entities correctly.
        This is a known limitation and currently has no workaround.
    </div>
</div>
</body>
</html>
