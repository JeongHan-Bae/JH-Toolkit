<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.16.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>JH-Toolkit: jh::meta::lookup_map&lt; K, V, N, Hash &gt; Struct Template Reference</title>
<link rel="icon" href="Jindallae.svg" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="Oree.svg"/></td>
  <td id="projectalign">
   <div id="projectname">JH-Toolkit<span id="projectnumber">&#160;v1.4.0</span>
   </div>
   <div id="projectbrief">An engineering-oriented C++20 toolkit with duck-typed concepts, static design, async coroutines, and semantic containers — header-only, RTTI-free, and concurrency-friendly.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.16.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('structjh_1_1meta_1_1lookup__map.html','','structjh_1_1meta_1_1lookup__map-members'); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">jh::meta::lookup_map&lt; K, V, N, Hash &gt; Struct Template Reference<span class="mlabels"><span class="mlabel final">final</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>Fixed-capacity hash-based flat map providing switch-like lookup semantics.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="">jh/metax/lookup_map.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:entry" id="r_entry"><td class="memItemLeft">struct &#160;</td><td class="memItemRight"><a class="el" href="structjh_1_1meta_1_1lookup__map_1_1entry.html">entry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Single entry stored in the lookup table.  <a href="structjh_1_1meta_1_1lookup__map_1_1entry.html#details">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-types" class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:af72b136e053a2d4c28c1693fe265b356" id="r_af72b136e053a2d4c28c1693fe265b356"><td class="memItemLeft">using&#160;</td><td class="memItemRight"><a class="el" href="#af72b136e053a2d4c28c1693fe265b356">container_type</a></td></tr>
<tr class="memdesc:af72b136e053a2d4c28c1693fe265b356"><td class="mdescLeft">&#160;</td><td class="mdescRight">Storage type selected based on POD suitability.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aecdfab1a64a4dd526ec4ec21e73d8e6e" id="r_aecdfab1a64a4dd526ec4ec21e73d8e6e"><td class="memTemplParams" colspan="2">template&lt;typename Arr&gt; </td></tr>
<tr class="memitem:aecdfab1a64a4dd526ec4ec21e73d8e6e template"><td class="memItemLeft">constexpr&#160;</td><td class="memItemRight"><a class="el" href="#aecdfab1a64a4dd526ec4ec21e73d8e6e">lookup_map</a> (Arr &amp;&amp;init, V default_val={}, Hash hasher={})</td></tr>
<tr class="memdesc:aecdfab1a64a4dd526ec4ec21e73d8e6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from an array of <code>std::pair&lt;K,V&gt;</code>.  <br /></td></tr>
<tr class="memitem:ad98064fef5b1d7eaffbbbfc8aaf2b45f" id="r_ad98064fef5b1d7eaffbbbfc8aaf2b45f"><td class="memTemplParams" colspan="2">template&lt;typename KeyIn&gt; </td></tr>
<tr class="memitem:ad98064fef5b1d7eaffbbbfc8aaf2b45f template"><td class="memItemLeft">constexpr const V &amp;&#160;</td><td class="memItemRight"><a class="el" href="#ad98064fef5b1d7eaffbbbfc8aaf2b45f">operator[]</a> (KeyIn &amp;&amp;key_in) const noexcept</td></tr>
<tr class="memdesc:ad98064fef5b1d7eaffbbbfc8aaf2b45f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lookup operator using transparent key conversion.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-attribs" class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ac88a3784110ac2bc7512022dca66b581" id="r_ac88a3784110ac2bc7512022dca66b581"><td class="memItemLeft"><a id="ac88a3784110ac2bc7512022dca66b581" name="ac88a3784110ac2bc7512022dca66b581"></a>
<a class="el" href="#af72b136e053a2d4c28c1693fe265b356">container_type</a>&#160;</td><td class="memItemRight"><b>entries</b></td></tr>
<tr class="memdesc:ac88a3784110ac2bc7512022dca66b581"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorted entries. <br /></td></tr>
<tr class="memitem:ad4896e75ba7bd5e92f4c6cd030afe765" id="r_ad4896e75ba7bd5e92f4c6cd030afe765"><td class="memItemLeft"><a id="ad4896e75ba7bd5e92f4c6cd030afe765" name="ad4896e75ba7bd5e92f4c6cd030afe765"></a>
V&#160;</td><td class="memItemRight"><b>default_value</b></td></tr>
<tr class="memdesc:ad4896e75ba7bd5e92f4c6cd030afe765"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value returned when key not found. <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-static-attribs" class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a1a7b144b8f1b3f1866d39f17a3f4e580" id="r_a1a7b144b8f1b3f1866d39f17a3f4e580"><td class="memItemLeft"><a id="a1a7b144b8f1b3f1866d39f17a3f4e580" name="a1a7b144b8f1b3f1866d39f17a3f4e580"></a>
static constexpr size_t&#160;</td><td class="memItemRight"><b>entry_size</b> = sizeof(<a class="el" href="structjh_1_1meta_1_1lookup__map_1_1entry.html">entry</a>)</td></tr>
<tr class="memitem:a5c8158300389e4baf850394d31a44197" id="r_a5c8158300389e4baf850394d31a44197"><td class="memItemLeft"><a id="a5c8158300389e4baf850394d31a44197" name="a5c8158300389e4baf850394d31a44197"></a>
static constexpr size_t&#160;</td><td class="memItemRight"><b>total_size</b> = entry_size * N</td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename K, typename V, size_t N, typename Hash&gt;<br />
requires requires(K k) { { Hash{}(k) } -&gt; std::convertible_to&lt;size_t&gt;; }<br />
struct jh::meta::lookup_map&lt; K, V, N, Hash &gt;</div><p>Fixed-capacity hash-based flat map providing switch-like lookup semantics. </p>
<p>Provides a switch-style lookup mechanism for types supporting hashing and equality. Designed to deliver predictable performance across constexpr and runtime paths.</p>
<h4>Design motivations</h4>
<ul>
<li>
The lookup cost is <code>O(log(N))</code>, based on binary search over precomputed hashes. </li>
<li>
For small <code>N</code>, the dominant cost is computing the hash. If a type would require hashing before participating in a switch-like dispatch, the total cost closely matches a switch under small-table conditions. </li>
<li>
For large <code>N</code>, both this structure and a compiler-lowered switch typically operate in <code>O(log(N))</code>, so asymptotic behavior does not differ significantly. </li>
<li>
Poor hash quality is tolerated: the structure remains correct and performance degrades safely toward <code>O(N)</code>. </li>
<li>
Hash collisions are resolved by short linear scans inside the <span class="tt">equal-hash</span> range. </li>
<li>
The structure generalizes switch semantics to types that are not natively switchable, capturing the complete hash-then-dispatch pattern while ensuring deterministic layout and constexpr capability. </li>
</ul>
<h4>Transparent lookup behavior</h4>
<ul>
<li>
Transparent <code>operator[]</code> queries are enabled through <code><a class="el" href="structjh_1_1meta_1_1extension_1_1key__traits.html" title="Default key conversion traits.">jh::meta::extension::key_traits&lt;K&gt;</a></code>, which defines how an apparent input type <code>KeyIn</code> is converted into the canonical key type <code>K</code>. </li>
<li>
This conversion is explicit: <b>a canonical <code>K</code> object will be constructed</b> from the apparent input. Therefore <code>K</code> is expected to be lightweight, such as a POD key or a full-lifetime literal-based string view (<code>"..."_psv</code>). </li>
<li>
This differs from heterogeneous lookup in <code>unordered_map</code>; the goal here is predictable constexpr behavior, not amortized dynamic optimization. </li>
</ul>
<h4>Implementation</h4>
<ol>
<li>
Entries are pre-hashed using <code>Hash</code> and stored as a fixed-size array. </li>
<li>
The array is sorted by hash, enabling binary search on the hash field. </li>
<li>
Equal-hash entries are resolved by a short linear comparison scan. </li>
<li>
Construction uses constexpr sorting when evaluated at compile time and runtime sorting otherwise. </li>
<li>
The container uses no dynamic allocation and provides deterministic layout. </li>
</ol>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K</td><td>Canonical key type stored in the map. </td></tr>
    <tr><td class="paramname">V</td><td>Value type associated with each key. </td></tr>
    <tr><td class="paramname">N</td><td>Number of stored entries. </td></tr>
    <tr><td class="paramname">Hash</td><td>Hash functor producing <code>size_t</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Prefer compile-time construction with lightweight POD keys or full-lifetime string-view literals (e.g. <code>"..."_psv</code>) to ensure zero-overhead canonical conversions through <code>key_traits</code>.  </dd></dl>
</div><a name="doc-typedef-members" id="doc-typedef-members"></a><h2 id="header-doc-typedef-members" class="groupheader">Member Typedef Documentation</h2>
<a id="af72b136e053a2d4c28c1693fe265b356" name="af72b136e053a2d4c28c1693fe265b356"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af72b136e053a2d4c28c1693fe265b356">&#9670;&#160;</a></span>container_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, size_t N, typename Hash&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structjh_1_1meta_1_1lookup__map.html">jh::meta::lookup_map</a>&lt; K, V, N, Hash &gt;::container_type</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><span class="keyword">decltype</span>([]() {</div>
<div class="line">           <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (<a class="code hl_concept" href="conceptjh_1_1pod_1_1pod__like.html">jh::pod::pod_like&lt;entry&gt;</a> &amp;&amp; (total_size &lt;= <a class="code hl_variable" href="namespacejh_1_1pod.html#aca802e7cca57b1c34f4d4877c914d035">jh::pod::max_pod_array_bytes</a>))</div>
<div class="line">               <span class="keywordflow">return</span> std::type_identity&lt;<a class="code hl_struct" href="structjh_1_1pod_1_1array.html">jh::pod::array&lt;entry, N&gt;</a>&gt;{};</div>
<div class="line">           <span class="keywordflow">else</span></div>
<div class="line">               <span class="keywordflow">return</span> std::type_identity&lt;std::array&lt;entry, N&gt;&gt;{};</div>
<div class="line">       }())::type</div>
<div class="ttc" id="aconceptjh_1_1pod_1_1pod__like_html"><div class="ttname"><a href="conceptjh_1_1pod_1_1pod__like.html">jh::pod::pod_like</a></div><div class="ttdoc">Concept for types that are safe to treat as plain old data (POD).</div><div class="ttdef"><b>Definition</b> pod_like.h:44</div></div>
<div class="ttc" id="anamespacejh_1_1pod_html_aca802e7cca57b1c34f4d4877c914d035"><div class="ttname"><a href="namespacejh_1_1pod.html#aca802e7cca57b1c34f4d4877c914d035">jh::pod::max_pod_array_bytes</a></div><div class="ttdeci">constexpr std::uint16_t max_pod_array_bytes</div><div class="ttdoc">Maximum size of a POD array (16KB). This is a compile-time constant.</div><div class="ttdef"><b>Definition</b> array.h:32</div></div>
<div class="ttc" id="astructjh_1_1pod_1_1array_html"><div class="ttname"><a href="structjh_1_1pod_1_1array.html">jh::pod::array</a></div><div class="ttdoc">POD-compatible fixed-size array, similar in shape to std::array, but simpler and fully POD.</div><div class="ttdef"><b>Definition</b> array.h:68</div></div>
</div><!-- fragment -->
<p>Storage type selected based on POD suitability. </p>
<p>If <code>entry</code> is POD-like and the total size does not exceed <code><a class="el" href="namespacejh_1_1pod.html#aca802e7cca57b1c34f4d4877c914d035" title="Maximum size of a POD array (16KB). This is a compile-time constant.">jh::pod::max_pod_array_bytes</a></code>, <code><a class="el" href="structjh_1_1pod_1_1array.html" title="POD-compatible fixed-size array, similar in shape to std::array, but simpler and fully POD.">jh::pod::array&lt;entry, N&gt;</a></code> is used; otherwise <code>std::array&lt;entry, N&gt;</code> is selected. <br  />
 Using the POD variant enables placement in read-only segments. </p>

</div>
</div>
<a name="doc-constructors" id="doc-constructors"></a><h2 id="header-doc-constructors" class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aecdfab1a64a4dd526ec4ec21e73d8e6e" name="aecdfab1a64a4dd526ec4ec21e73d8e6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecdfab1a64a4dd526ec4ec21e73d8e6e">&#9670;&#160;</a></span>lookup_map()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, size_t N, typename Hash&gt; </div>
<div class="memtemplate">
template&lt;typename Arr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structjh_1_1meta_1_1lookup__map.html">jh::meta::lookup_map</a>&lt; K, V, N, Hash &gt;::lookup_map </td>
          <td>(</td>
          <td class="paramtype">Arr &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>init</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V</td>          <td class="paramname"><span class="paramname"><em>default_val</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Hash</td>          <td class="paramname"><span class="paramname"><em>hasher</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel explicit">explicit</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct from an array of <code>std::pair&lt;K,V&gt;</code>. </p>
<p>Computes hashes, stores entries and sorts them by hash. Performs constexpr or runtime sorting depending on evaluation context.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">init</td><td>Array of key-value pairs. </td></tr>
    <tr><td class="paramname">default_val</td><td>Value returned when lookup fails. </td></tr>
    <tr><td class="paramname">hasher</td><td>Hash functor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="ad98064fef5b1d7eaffbbbfc8aaf2b45f" name="ad98064fef5b1d7eaffbbbfc8aaf2b45f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad98064fef5b1d7eaffbbbfc8aaf2b45f">&#9670;&#160;</a></span>operator[]()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K, typename V, size_t N, typename Hash&gt; </div>
<div class="memtemplate">
template&lt;typename KeyIn&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const V &amp; <a class="el" href="structjh_1_1meta_1_1lookup__map.html">jh::meta::lookup_map</a>&lt; K, V, N, Hash &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">KeyIn &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>key_in</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lookup operator using transparent key conversion. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyIn</td><td>Input key type convertible via <code>key_traits&lt;K&gt;</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key_in</td><td>Key to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the stored value or <code>default_value</code> if not found. </dd></dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>include/jh/metax/<a class="el" href="">lookup_map.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
</div> <!-- top -->
<hr class="footer"/>
<div class="footer">
    <img class="footer-logo" src="Ojing.svg" alt="Ojing"/>
    <div class="footer-text">
        JH-Toolkit v1.4.0 · Generated by Doxygen
    </div>
    <div class="footer-note">
        We primarily support embedded documentation views in IDEs (classic CLion).
        To ensure compatibility with embedded rendering, some example code in this
        documentation intentionally contains HTML entities.
        In certain cases, Doxygen does not unescape these entities correctly.
        This is a known limitation and currently has no workaround.
    </div>
</div>
</body>
</html>
