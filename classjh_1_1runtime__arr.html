<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.16.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>JH-Toolkit: jh::runtime_arr&lt; T, Alloc &gt; Class Template Reference</title>
<link rel="icon" href="Jindallae.svg" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="Oree.svg"/></td>
  <td id="projectalign">
   <div id="projectname">JH-Toolkit<span id="projectnumber">&#160;v1.4.0</span>
   </div>
   <div id="projectbrief">An engineering-oriented C++20 toolkit with duck-typed concepts, static design, async coroutines, and semantic containers — header-only, RTTI-free, and concurrency-friendly.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.16.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('classjh_1_1runtime__arr.html','','classjh_1_1runtime__arr-members'); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">jh::runtime_arr&lt; T, Alloc &gt; Class Template Reference<span class="mlabels"><span class="mlabel final">final</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>A move-only, fixed-capacity array with runtime-determined length and RAII-based ownership.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="">jh/core/runtime_arr.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:uninitialized_5Ft" id="r_uninitialized_5Ft"><td class="memItemLeft">struct &#160;</td><td class="memItemRight"><a class="el" href="structjh_1_1runtime__arr_1_1uninitialized__t.html">uninitialized_t</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-types" class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a97517148237e3df1e3bcc062e648aaf6" id="r_a97517148237e3df1e3bcc062e648aaf6"><td class="memItemLeft"><a id="a97517148237e3df1e3bcc062e648aaf6" name="a97517148237e3df1e3bcc062e648aaf6"></a>
using&#160;</td><td class="memItemRight"><b>value_type</b> = T</td></tr>
<tr class="memdesc:a97517148237e3df1e3bcc062e648aaf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value type alias. <br /></td></tr>
<tr class="memitem:ab912d4806390f4876a456096780ff139" id="r_ab912d4806390f4876a456096780ff139"><td class="memItemLeft"><a id="ab912d4806390f4876a456096780ff139" name="ab912d4806390f4876a456096780ff139"></a>
using&#160;</td><td class="memItemRight"><b>size_type</b> = std::uint64_t</td></tr>
<tr class="memdesc:ab912d4806390f4876a456096780ff139"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size type alias (64-bit). <br /></td></tr>
<tr class="memitem:aab773aa4d432c0b39562d3c91f17e437" id="r_aab773aa4d432c0b39562d3c91f17e437"><td class="memItemLeft"><a id="aab773aa4d432c0b39562d3c91f17e437" name="aab773aa4d432c0b39562d3c91f17e437"></a>
using&#160;</td><td class="memItemRight"><b>difference_type</b> = std::ptrdiff_t</td></tr>
<tr class="memdesc:aab773aa4d432c0b39562d3c91f17e437"><td class="mdescLeft">&#160;</td><td class="mdescRight">Difference type alias. <br /></td></tr>
<tr class="memitem:a906ccd2e6efdd6f9dea8247b02ef046c" id="r_a906ccd2e6efdd6f9dea8247b02ef046c"><td class="memItemLeft"><a id="a906ccd2e6efdd6f9dea8247b02ef046c" name="a906ccd2e6efdd6f9dea8247b02ef046c"></a>
using&#160;</td><td class="memItemRight"><b>reference</b> = <a class="el" href="#a97517148237e3df1e3bcc062e648aaf6">value_type</a> &amp;</td></tr>
<tr class="memdesc:a906ccd2e6efdd6f9dea8247b02ef046c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference type. <br /></td></tr>
<tr class="memitem:a035fb9232d8d89abdb7a2cb9bc1629c4" id="r_a035fb9232d8d89abdb7a2cb9bc1629c4"><td class="memItemLeft"><a id="a035fb9232d8d89abdb7a2cb9bc1629c4" name="a035fb9232d8d89abdb7a2cb9bc1629c4"></a>
using&#160;</td><td class="memItemRight"><b>const_reference</b> = const <a class="el" href="#a97517148237e3df1e3bcc062e648aaf6">value_type</a> &amp;</td></tr>
<tr class="memdesc:a035fb9232d8d89abdb7a2cb9bc1629c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const reference type. <br /></td></tr>
<tr class="memitem:aa7a9136db1823b8dd65f07ca9779a5c1" id="r_aa7a9136db1823b8dd65f07ca9779a5c1"><td class="memItemLeft"><a id="aa7a9136db1823b8dd65f07ca9779a5c1" name="aa7a9136db1823b8dd65f07ca9779a5c1"></a>
using&#160;</td><td class="memItemRight"><b>pointer</b> = <a class="el" href="#a97517148237e3df1e3bcc062e648aaf6">value_type</a> *</td></tr>
<tr class="memdesc:aa7a9136db1823b8dd65f07ca9779a5c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer type. <br /></td></tr>
<tr class="memitem:a90b40d1b38338b0de98e9a6bf245a2b0" id="r_a90b40d1b38338b0de98e9a6bf245a2b0"><td class="memItemLeft"><a id="a90b40d1b38338b0de98e9a6bf245a2b0" name="a90b40d1b38338b0de98e9a6bf245a2b0"></a>
using&#160;</td><td class="memItemRight"><b>const_pointer</b> = const <a class="el" href="#a97517148237e3df1e3bcc062e648aaf6">value_type</a> *</td></tr>
<tr class="memdesc:a90b40d1b38338b0de98e9a6bf245a2b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const pointer type. <br /></td></tr>
<tr class="memitem:aaf4e27aada733365e84ec68378fe0737" id="r_aaf4e27aada733365e84ec68378fe0737"><td class="memItemLeft"><a id="aaf4e27aada733365e84ec68378fe0737" name="aaf4e27aada733365e84ec68378fe0737"></a>
using&#160;</td><td class="memItemRight"><b>iterator</b> = <a class="el" href="#aa7a9136db1823b8dd65f07ca9779a5c1">pointer</a></td></tr>
<tr class="memitem:a9909fb8e8809f41f3180e569533652fe" id="r_a9909fb8e8809f41f3180e569533652fe"><td class="memItemLeft"><a id="a9909fb8e8809f41f3180e569533652fe" name="a9909fb8e8809f41f3180e569533652fe"></a>
using&#160;</td><td class="memItemRight"><b>const_iterator</b> = <a class="el" href="#a90b40d1b38338b0de98e9a6bf245a2b0">const_pointer</a></td></tr>
<tr class="memitem:a9601a63c341606c910915f7a1242ad6e" id="r_a9601a63c341606c910915f7a1242ad6e"><td class="memItemLeft"><a id="a9601a63c341606c910915f7a1242ad6e" name="a9601a63c341606c910915f7a1242ad6e"></a>
using&#160;</td><td class="memItemRight"><b>allocator_type</b> = detail::rt_arr_alloc_t&lt;T, Alloc&gt;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac3863058778516c1e4c23b7e09d1afc4" id="r_ac3863058778516c1e4c23b7e09d1afc4"><td class="memItemLeft">&#160;</td><td class="memItemRight"><a class="el" href="#ac3863058778516c1e4c23b7e09d1afc4">runtime_arr</a> (const std::uint64_t <a class="el" href="#a7e594d60b00921524830179b3caa1373">size</a>, <a class="el" href="structjh_1_1runtime__arr_1_1uninitialized__t.html">uninitialized_t</a>)</td></tr>
<tr class="memdesc:ac3863058778516c1e4c23b7e09d1afc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an uninitialized array of POD-like elements.  <br /></td></tr>
<tr class="memitem:aa2d0d2b9a4f0c25b995ce60833a320ac" id="r_aa2d0d2b9a4f0c25b995ce60833a320ac"><td class="memItemLeft">&#160;</td><td class="memItemRight"><a class="el" href="#aa2d0d2b9a4f0c25b995ce60833a320ac">runtime_arr</a> (std::initializer_list&lt; T &gt; init)</td></tr>
<tr class="memdesc:aa2d0d2b9a4f0c25b995ce60833a320ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a fixed-size runtime array from an initializer list.  <br /></td></tr>
<tr class="memitem:a5e3744d04e9851bbcb49e04151e5163c" id="r_a5e3744d04e9851bbcb49e04151e5163c"><td class="memItemLeft">&#160;</td><td class="memItemRight"><a class="el" href="#a5e3744d04e9851bbcb49e04151e5163c">runtime_arr</a> (std::uint64_t <a class="el" href="#a7e594d60b00921524830179b3caa1373">size</a>)</td></tr>
<tr class="memdesc:a5e3744d04e9851bbcb49e04151e5163c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a zero-initialized array using the default allocation strategy.  <br /></td></tr>
<tr class="memitem:abc72122d7177a615f027f7e94ac394a0" id="r_abc72122d7177a615f027f7e94ac394a0"><td class="memItemLeft">&#160;</td><td class="memItemRight"><a class="el" href="#abc72122d7177a615f027f7e94ac394a0">runtime_arr</a> (std::initializer_list&lt; T &gt; init, const Alloc &amp;alloc)</td></tr>
<tr class="memdesc:abc72122d7177a615f027f7e94ac394a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a fixed-size runtime array from an initializer list using a custom allocator.  <br /></td></tr>
<tr class="memitem:aec5d640b75d6b0c6c27cc33ab2ee3649" id="r_aec5d640b75d6b0c6c27cc33ab2ee3649"><td class="memItemLeft">&#160;</td><td class="memItemRight"><a class="el" href="#aec5d640b75d6b0c6c27cc33ab2ee3649">runtime_arr</a> (std::uint64_t <a class="el" href="#a7e594d60b00921524830179b3caa1373">size</a>, const Alloc &amp;alloc)</td></tr>
<tr class="memdesc:aec5d640b75d6b0c6c27cc33ab2ee3649"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a runtime array using a movable allocator instance.  <br /></td></tr>
<tr class="memitem:ae524b53bf6db1141c965cbee7f55ca36" id="r_ae524b53bf6db1141c965cbee7f55ca36"><td class="memItemLeft">&#160;</td><td class="memItemRight"><a class="el" href="#ae524b53bf6db1141c965cbee7f55ca36">runtime_arr</a> (std::vector&lt; T &gt; &amp;&amp;vec)</td></tr>
<tr class="memdesc:ae524b53bf6db1141c965cbee7f55ca36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <code>runtime_arr&lt;T&gt;</code> by moving from a <code>std::vector&lt;T&gt;</code> (only when <code>Alloc</code> is <code><a class="el" href="structjh_1_1typed_1_1monostate.html" title="Trivial empty type representing &quot;no value&quot;.">typed::monostate</a></code>).  <br /></td></tr>
<tr class="memitem:a1f7aafb0e3297ca61f5c130f53d8cc36" id="r_a1f7aafb0e3297ca61f5c130f53d8cc36"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIt&gt; <br />
requires (typed::monostate_t&lt;Alloc&gt; &amp;&amp; <a class="el" href="conceptjh_1_1concepts_1_1forward__iterator.html">jh::concepts::forward_iterator</a>&lt;ForwardIt&gt; &amp;&amp; std::convertible_to&lt;typename ForwardIt::value_type, <a class="el" href="#a97517148237e3df1e3bcc062e648aaf6">value_type</a>&gt; &amp;&amp; std::is_copy_constructible_v&lt;T&gt;)</td></tr>
<tr class="memitem:a1f7aafb0e3297ca61f5c130f53d8cc36 template"><td class="memItemLeft">&#160;</td><td class="memItemRight"><a class="el" href="#a1f7aafb0e3297ca61f5c130f53d8cc36">runtime_arr</a> (ForwardIt first, ForwardIt last)</td></tr>
<tr class="memdesc:a1f7aafb0e3297ca61f5c130f53d8cc36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <code>runtime_arr&lt;T&gt;</code> from any valid forward iterator range.  <br /></td></tr>
<tr class="memitem:afb0609f7782bdb288a2001368a9bae44" id="r_afb0609f7782bdb288a2001368a9bae44"><td class="memItemLeft"><a id="afb0609f7782bdb288a2001368a9bae44" name="afb0609f7782bdb288a2001368a9bae44"></a>
iterator&#160;</td><td class="memItemRight"><b>begin</b> () noexcept</td></tr>
<tr class="memdesc:afb0609f7782bdb288a2001368a9bae44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns iterator to the beginning. <br /></td></tr>
<tr class="memitem:a51ac658582013fa92a51848832957762" id="r_a51ac658582013fa92a51848832957762"><td class="memItemLeft"><a id="a51ac658582013fa92a51848832957762" name="a51ac658582013fa92a51848832957762"></a>
const_iterator&#160;</td><td class="memItemRight"><b>begin</b> () const noexcept</td></tr>
<tr class="memdesc:a51ac658582013fa92a51848832957762"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns const iterator to the beginning. <br /></td></tr>
<tr class="memitem:ac233f61cca033075c9997b5dbe16d9d5" id="r_ac233f61cca033075c9997b5dbe16d9d5"><td class="memItemLeft"><a id="ac233f61cca033075c9997b5dbe16d9d5" name="ac233f61cca033075c9997b5dbe16d9d5"></a>
iterator&#160;</td><td class="memItemRight"><b>end</b> () noexcept</td></tr>
<tr class="memdesc:ac233f61cca033075c9997b5dbe16d9d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns iterator to the end (past-the-last element). <br /></td></tr>
<tr class="memitem:a6bbfc35cdc3e61524b10df245eb45196" id="r_a6bbfc35cdc3e61524b10df245eb45196"><td class="memItemLeft"><a id="a6bbfc35cdc3e61524b10df245eb45196" name="a6bbfc35cdc3e61524b10df245eb45196"></a>
const_iterator&#160;</td><td class="memItemRight"><b>end</b> () const noexcept</td></tr>
<tr class="memdesc:a6bbfc35cdc3e61524b10df245eb45196"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns const iterator to the end (past-the-last element). <br /></td></tr>
<tr class="memitem:a056bfd2083e740b7b5dc063d67801f85" id="r_a056bfd2083e740b7b5dc063d67801f85"><td class="memItemLeft"><a id="a056bfd2083e740b7b5dc063d67801f85" name="a056bfd2083e740b7b5dc063d67801f85"></a>
const_iterator&#160;</td><td class="memItemRight"><b>cbegin</b> () const noexcept</td></tr>
<tr class="memdesc:a056bfd2083e740b7b5dc063d67801f85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns const iterator to the beginning. <br /></td></tr>
<tr class="memitem:a8da802f84d4fa04018b70f40f46cfd88" id="r_a8da802f84d4fa04018b70f40f46cfd88"><td class="memItemLeft"><a id="a8da802f84d4fa04018b70f40f46cfd88" name="a8da802f84d4fa04018b70f40f46cfd88"></a>
const_iterator&#160;</td><td class="memItemRight"><b>cend</b> () const noexcept</td></tr>
<tr class="memdesc:a8da802f84d4fa04018b70f40f46cfd88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns const iterator to the end (past-the-last element). <br /></td></tr>
<tr class="memitem:aea6ba1c1e5af369a2329c8ec06c9bd52" id="r_aea6ba1c1e5af369a2329c8ec06c9bd52"><td class="memItemLeft"><a class="el" href="#a906ccd2e6efdd6f9dea8247b02ef046c">reference</a>&#160;</td><td class="memItemRight"><a class="el" href="#aea6ba1c1e5af369a2329c8ec06c9bd52">operator[]</a> (std::uint64_t index) noexcept</td></tr>
<tr class="memdesc:aea6ba1c1e5af369a2329c8ec06c9bd52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unchecked element access.  <br /></td></tr>
<tr class="memitem:a29f9fd3200c645fdd170cba56a913020" id="r_a29f9fd3200c645fdd170cba56a913020"><td class="memItemLeft"><a class="el" href="#a035fb9232d8d89abdb7a2cb9bc1629c4">const_reference</a>&#160;</td><td class="memItemRight"><a class="el" href="#a29f9fd3200c645fdd170cba56a913020">operator[]</a> (std::uint64_t index) const noexcept</td></tr>
<tr class="memdesc:a29f9fd3200c645fdd170cba56a913020"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unchecked const element access.  <br /></td></tr>
<tr class="memitem:a2654858f9372bd281bcd387478aa4783" id="r_a2654858f9372bd281bcd387478aa4783"><td class="memItemLeft"><a class="el" href="#a906ccd2e6efdd6f9dea8247b02ef046c">reference</a>&#160;</td><td class="memItemRight"><a class="el" href="#a2654858f9372bd281bcd387478aa4783">at</a> (std::uint64_t index)</td></tr>
<tr class="memdesc:a2654858f9372bd281bcd387478aa4783"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bounds-checked element access.  <br /></td></tr>
<tr class="memitem:a65523a8630e922ef4c4cdb9a223e321d" id="r_a65523a8630e922ef4c4cdb9a223e321d"><td class="memItemLeft"><a class="el" href="#a035fb9232d8d89abdb7a2cb9bc1629c4">const_reference</a>&#160;</td><td class="memItemRight"><a class="el" href="#a65523a8630e922ef4c4cdb9a223e321d">at</a> (std::uint64_t index) const</td></tr>
<tr class="memdesc:a65523a8630e922ef4c4cdb9a223e321d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const bounds-checked element access.  <br /></td></tr>
<tr class="memitem:a0bc8f08ae6499a915e14526ba648ff6e" id="r_a0bc8f08ae6499a915e14526ba648ff6e"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a0bc8f08ae6499a915e14526ba648ff6e template"><td class="memItemLeft">void&#160;</td><td class="memItemRight"><a class="el" href="#a0bc8f08ae6499a915e14526ba648ff6e">set</a> (std::uint64_t i, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a0bc8f08ae6499a915e14526ba648ff6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value at given index using constructor arguments.  <br /></td></tr>
<tr class="memitem:afadcdd48a2f76c5d3b3db29a4691b2ed" id="r_afadcdd48a2f76c5d3b3db29a4691b2ed"><td class="memTemplParams" colspan="2">template&lt;typename U = T&gt; </td></tr>
<tr class="memitem:afadcdd48a2f76c5d3b3db29a4691b2ed template"><td class="memItemLeft">void&#160;</td><td class="memItemRight"><a class="el" href="#afadcdd48a2f76c5d3b3db29a4691b2ed">reset_all</a> () noexcept</td></tr>
<tr class="memdesc:afadcdd48a2f76c5d3b3db29a4691b2ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets all elements to their default-initialized state.  <br /></td></tr>
<tr class="memitem:a7e594d60b00921524830179b3caa1373" id="r_a7e594d60b00921524830179b3caa1373"><td class="memItemLeft"><a class="el" href="#ab912d4806390f4876a456096780ff139">size_type</a>&#160;</td><td class="memItemRight"><a class="el" href="#a7e594d60b00921524830179b3caa1373">size</a> () const noexcept</td></tr>
<tr class="memdesc:a7e594d60b00921524830179b3caa1373"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in the array.  <br /></td></tr>
<tr class="memitem:adaa69a50e8f42fd488f3f0d57c50040d" id="r_adaa69a50e8f42fd488f3f0d57c50040d"><td class="memItemLeft">bool&#160;</td><td class="memItemRight"><a class="el" href="#adaa69a50e8f42fd488f3f0d57c50040d">empty</a> () const noexcept</td></tr>
<tr class="memdesc:adaa69a50e8f42fd488f3f0d57c50040d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the array is empty.  <br /></td></tr>
<tr class="memitem:acb17565fd5d1e165b66ffc74fc7fed9e" id="r_acb17565fd5d1e165b66ffc74fc7fed9e"><td class="memItemLeft"><a class="el" href="#aa7a9136db1823b8dd65f07ca9779a5c1">pointer</a>&#160;</td><td class="memItemRight"><a class="el" href="#acb17565fd5d1e165b66ffc74fc7fed9e">data</a> () noexcept</td></tr>
<tr class="memdesc:acb17565fd5d1e165b66ffc74fc7fed9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides raw pointer access to the underlying storage.  <br /></td></tr>
<tr class="memitem:af5159969eb2185c729307ea8338163eb" id="r_af5159969eb2185c729307ea8338163eb"><td class="memItemLeft"><a class="el" href="#a90b40d1b38338b0de98e9a6bf245a2b0">const_pointer</a>&#160;</td><td class="memItemRight"><a class="el" href="#af5159969eb2185c729307ea8338163eb">data</a> () const noexcept</td></tr>
<tr class="memdesc:af5159969eb2185c729307ea8338163eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides const raw pointer access to the underlying storage.  <br /></td></tr>
<tr class="memitem:a3a070a80c26d67cfde0f1a0c2744260b" id="r_a3a070a80c26d67cfde0f1a0c2744260b"><td class="memItemLeft">&#160;</td><td class="memItemRight"><a class="el" href="#a3a070a80c26d67cfde0f1a0c2744260b">runtime_arr</a> (runtime_arr &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:a3a070a80c26d67cfde0f1a0c2744260b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new <code><a class="el" href="classjh_1_1runtime__arr.html" title="A move-only, fixed-capacity array with runtime-determined length and RAII-based ownership.">runtime_arr</a></code> by taking ownership of another instance's data.  <br /></td></tr>
<tr class="memitem:a750d749fa833692e3c45a27586cadc5f" id="r_a750d749fa833692e3c45a27586cadc5f"><td class="memItemLeft"><a class="el" href="#ac3863058778516c1e4c23b7e09d1afc4">runtime_arr</a> &amp;&#160;</td><td class="memItemRight"><a class="el" href="#a750d749fa833692e3c45a27586cadc5f">operator=</a> (<a class="el" href="#ac3863058778516c1e4c23b7e09d1afc4">runtime_arr</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:a750d749fa833692e3c45a27586cadc5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the contents of this <code><a class="el" href="classjh_1_1runtime__arr.html" title="A move-only, fixed-capacity array with runtime-determined length and RAII-based ownership.">runtime_arr</a></code> with those of another, transferring ownership.  <br /></td></tr>
<tr class="memitem:ac811ed28b9b1aef06521b90a3c6e2988" id="r_ac811ed28b9b1aef06521b90a3c6e2988"><td class="memItemLeft">&#160;</td><td class="memItemRight"><a class="el" href="#ac811ed28b9b1aef06521b90a3c6e2988">operator std::vector&lt; T &gt;</a> () &amp;&amp;</td></tr>
<tr class="memdesc:ac811ed28b9b1aef06521b90a3c6e2988"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the array into a <code>std::vector&lt;T&gt;</code> by moving its contents.  <br /></td></tr>
<tr class="memitem:af51bf6ce71b7696cfcb1389743ead1c0" id="r_af51bf6ce71b7696cfcb1389743ead1c0"><td class="memItemLeft">&#160;</td><td class="memItemRight"><a class="el" href="#af51bf6ce71b7696cfcb1389743ead1c0">runtime_arr</a> (const runtime_arr &amp;)=delete</td></tr>
<tr class="memdesc:af51bf6ce71b7696cfcb1389743ead1c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor is explicitly deleted.  <br /></td></tr>
<tr class="memitem:a24fc509c8a69f3874383b7e7066bf754" id="r_a24fc509c8a69f3874383b7e7066bf754"><td class="memItemLeft"><a class="el" href="#ac3863058778516c1e4c23b7e09d1afc4">runtime_arr</a> &amp;&#160;</td><td class="memItemRight"><a class="el" href="#a24fc509c8a69f3874383b7e7066bf754">operator=</a> (const <a class="el" href="#ac3863058778516c1e4c23b7e09d1afc4">runtime_arr</a> &amp;)=delete</td></tr>
<tr class="memdesc:a24fc509c8a69f3874383b7e7066bf754"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator is explicitly deleted.  <br /></td></tr>
<tr class="memitem:abd21982bacc0b7e2f9d84eb09219d841" id="r_abd21982bacc0b7e2f9d84eb09219d841"><td class="memItemLeft"><a id="abd21982bacc0b7e2f9d84eb09219d841" name="abd21982bacc0b7e2f9d84eb09219d841"></a>
std::span&lt; <a class="el" href="#a97517148237e3df1e3bcc062e648aaf6">value_type</a> &gt;&#160;</td><td class="memItemRight"><b>as_span</b> () noexcept</td></tr>
<tr class="memitem:ad5a0e49b7fbd36aecd33430f0a498463" id="r_ad5a0e49b7fbd36aecd33430f0a498463"><td class="memItemLeft"><a id="ad5a0e49b7fbd36aecd33430f0a498463" name="ad5a0e49b7fbd36aecd33430f0a498463"></a>
std::span&lt; const <a class="el" href="#a97517148237e3df1e3bcc062e648aaf6">value_type</a> &gt;&#160;</td><td class="memItemRight"><b>as_span</b> () const noexcept</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-static-methods" class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a0a2bdfd278468ab03fbfcbd59e3dbfb9" id="r_a0a2bdfd278468ab03fbfcbd59e3dbfb9"><td class="memItemLeft"><a id="a0a2bdfd278468ab03fbfcbd59e3dbfb9" name="a0a2bdfd278468ab03fbfcbd59e3dbfb9"></a>
static bool&#160;</td><td class="memItemRight"><b>is_static_built</b> ()</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-static-attribs" class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:aae396ba33982ab1802bbcc3350b8436a" id="r_aae396ba33982ab1802bbcc3350b8436a"><td class="memItemLeft"><a id="aae396ba33982ab1802bbcc3350b8436a" name="aae396ba33982ab1802bbcc3350b8436a"></a>
static constexpr <a class="el" href="structjh_1_1runtime__arr_1_1uninitialized__t.html">uninitialized_t</a>&#160;</td><td class="memItemRight"><b>uninitialized</b> {}</td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename T, typename Alloc = typed::monostate&gt;<br />
requires detail::valid_rt_arr_allocator&lt;T, Alloc&gt;<br />
class jh::runtime_arr&lt; T, Alloc &gt;</div><p>A move-only, fixed-capacity array with runtime-determined length and RAII-based ownership. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Element type. </td></tr>
    <tr><td class="paramname">Alloc</td><td>Allocator type — defaults to <code><a class="el" href="structjh_1_1typed_1_1monostate.html" title="Trivial empty type representing &quot;no value&quot;.">typed::monostate</a></code> (uses <code>new[]</code> / <code>delete[]</code>).</td></tr>
  </table>
  </dd>
</dl>
<h4>Overview</h4>
<p>Short for <b>"runtime-sized array"</b>, this class models a <b>heap-allocated, non-resizable container</b> designed as a safe and expressive replacement for manual heap buffers (<code>new T[n]</code>). </p>
<p>Unlike <code>std::vector</code>, it forbids resizing, shrinking, or growth semantics. It focuses on <b>semantic clarity</b> rather than raw performance — making buffer lifetime and capacity constraints explicit.</p>
<h4>Core Features</h4>
<ul>
<li>
Move-only: eliminates accidental copies and aliasing. </li>
<li>
RAII-managed heap buffer (via <code>unique_ptr&lt;T[], deleter&gt;</code>). </li>
<li>
Optional zero-initialized or uninitialized construction. </li>
<li>
STL/ranges compatible (<code>view_interface</code> inheritance). </li>
<li>
<code><a class="el" href="#afadcdd48a2f76c5d3b3db29a4691b2ed" title="Resets all elements to their default-initialized state.">reset_all()</a></code> for fast POD reset using <code>memset</code>. </li>
<li>
Allocator parameterization for custom memory control. </li>
<li>
<code>as_span()</code> helper for safe interop with <code>std::span&lt;T&gt;</code>. </li>
</ul>
<h4>Default Allocation Model</h4>
<ul>
<li>
If <code>Alloc = <a class="el" href="structjh_1_1typed_1_1monostate.html" title="Trivial empty type representing &quot;no value&quot;.">typed::monostate</a></code> (default): <ul>
<li>
Memory is allocated via <code>new[]</code> and released via <code>delete[]</code>. </li>
<li>
No external allocator is required. </li>
</ul>
</li>
<li>
If <code>Alloc</code> provides <code>allocate(n)</code> / <code>deallocate(ptr, n)</code>: <ul>
<li>
Runtime allocation will use the provided allocator instance. </li>
</ul>
</li>
</ul>
<h4>When to Use</h4>
<ul>
<li>
As a fixed-capacity buffer with dynamic runtime length. </li>
<li>
When <code>std::vector</code>'s resizing semantics are undesired. </li>
<li>
As a safer RAII alternative to <code>T* arr = new T[n]</code>. </li>
</ul>
<h4>When <em>Not</em> to Use</h4>
<ul>
<li>
If dynamic resizing, push/pop semantics, or polymorphic behavior is required. </li>
<li>
If compile-time fixed capacity (<code>std::array</code>) suffices. </li>
</ul>
<h4>Interop Notes</h4>
<ul>
<li>
Contiguous and <code>std::span</code>-compatible. </li>
<li>
Supports range-for iteration, STL algorithms, and <code>std::ranges::views</code>. </li>
<li>
<code><a class="el" href="classjh_1_1runtime__arr_3_01bool_01_4.html" title="Specialized implementation of jh::runtime_arr&lt;bool&gt; — a compact, bit-packed boolean array.">runtime_arr&lt;bool&gt;</a></code> provides bit-packed specialization (see below). </li>
</ul>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>
Use <code><a class="el" href="#afadcdd48a2f76c5d3b3db29a4691b2ed" title="Resets all elements to their default-initialized state.">reset_all()</a></code> instead of <code>clear()</code>. </li>
<li>
Use <code>runtime_arr&lt;T&gt;::uninitialized</code> to skip default construction (POD only). </li>
<li>
Copy operations are deleted; moves are noexcept. </li>
</ul>
</dd></dl>
</div><a name="doc-constructors" id="doc-constructors"></a><h2 id="header-doc-constructors" class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ac3863058778516c1e4c23b7e09d1afc4" name="ac3863058778516c1e4c23b7e09d1afc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3863058778516c1e4c23b7e09d1afc4">&#9670;&#160;</a></span>runtime_arr() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = typed::monostate&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classjh_1_1runtime__arr.html">jh::runtime_arr</a>&lt; T, Alloc &gt;::runtime_arr </td>
          <td>(</td>
          <td class="paramtype">const std::uint64_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structjh_1_1runtime__arr_1_1uninitialized__t.html">uninitialized_t</a></td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel explicit">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an uninitialized array of POD-like elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="#a7e594d60b00921524830179b3caa1373" title="Returns the number of elements in the array.">size</a></td><td>The number of elements to allocate.</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>
Enabled only when <code>jh::pod_like&lt;T&gt;</code> and <code>Alloc</code> is <code><a class="el" href="structjh_1_1typed_1_1monostate.html" title="Trivial empty type representing &quot;no value&quot;.">typed::monostate</a></code>. </li>
<li>
Uses <code>operator new[]</code> to allocate raw storage — the memory is <b>completely uninitialized</b> (no zero-fill, no constructor calls). </li>
<li>
For <b>POD-like</b> types, such uninitialized allocation is semantically safe: their lifetime is bound directly to the allocated storage, and no constructor/destructor side effects are required. </li>
<li>
Intended for performance-critical contexts such as bulk I/O buffers, custom serialization, or explicit zero-fill via <code>std::memset</code>. </li>
<li>
In practice, this behaves similarly to <code>std::vector::reserve()</code> — capacity is guaranteed, but elements are not value-initialized. </li>
<li>
Unlike <code>std::vector</code>, however, <code><a class="el" href="classjh_1_1runtime__arr.html" title="A move-only, fixed-capacity array with runtime-determined length and RAII-based ownership.">runtime_arr</a></code> does not incur large penalties when default-initializing POD types: its "initialized" and "uninitialized" paths compile to nearly identical code for trivial objects (difference &lt;1%). </li>
</ul>
<p><b>Performance note</b> </p>
<p>For POD and trivially constructible types, both initialized and uninitialized variants of <code><a class="el" href="classjh_1_1runtime__arr.html" title="A move-only, fixed-capacity array with runtime-determined length and RAII-based ownership.">runtime_arr</a></code> achieve equivalent performance. The <code>uninitialized</code> form primarily exists to express intent — much like calling <code>std::vector::reserve()</code> — signaling intent that the elements will be explicitly initialized later, and thus avoiding redundant zero-fills or value-initialization writes that compilers may otherwise emit. For <b>POD</b> and trivially constructible types, however, both forms typically compile to identical machine code, since their constructors are effectively no-ops. </p>
<p><b>Note:</b> The content of the allocated memory is indeterminate until written to. Accessing any element before explicit initialization results in undefined behavior.</p>

</div>
</div>
<a id="aa2d0d2b9a4f0c25b995ce60833a320ac" name="aa2d0d2b9a4f0c25b995ce60833a320ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2d0d2b9a4f0c25b995ce60833a320ac">&#9670;&#160;</a></span>runtime_arr() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = typed::monostate&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classjh_1_1runtime__arr.html">jh::runtime_arr</a>&lt; T, Alloc &gt;::runtime_arr </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; T &gt;</td>          <td class="paramname"><span class="paramname"><em>init</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a fixed-size runtime array from an initializer list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">init</td><td>Initializer list providing the values for each element.</td></tr>
  </table>
  </dd>
</dl>
<p>Allocates a contiguous buffer of <code>init.size()</code> elements and performs <code>std::uninitialized_copy</code> to populate the storage. The array owns its memory and manages lifetime automatically. </p>
<ul>
<li>
Enabled only when <code>Alloc == <a class="el" href="structjh_1_1typed_1_1monostate.html" title="Trivial empty type representing &quot;no value&quot;.">typed::monostate</a></code>. </li>
<li>
Allocates <code>new T[init.size()]</code> and copies or moves elements from <code>init</code>. </li>
<li>
Ownership is managed via <code>std::unique_ptr</code> with default deleter. </li>
<li>
Move-only type; copy operations are disabled. </li>
</ul>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>If allocation fails. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5e3744d04e9851bbcb49e04151e5163c" name="a5e3744d04e9851bbcb49e04151e5163c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e3744d04e9851bbcb49e04151e5163c">&#9670;&#160;</a></span>runtime_arr() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = typed::monostate&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classjh_1_1runtime__arr.html">jh::runtime_arr</a>&lt; T, Alloc &gt;::runtime_arr </td>
          <td>(</td>
          <td class="paramtype">std::uint64_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel explicit">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a zero-initialized array using the default allocation strategy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="#a7e594d60b00921524830179b3caa1373" title="Returns the number of elements in the array.">size</a></td><td>Number of elements to allocate and value-initialize.</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>
Requires <code>is_valid_allocator&lt;Alloc&gt;</code>. </li>
<li>
If <code>Alloc</code> is <code><a class="el" href="structjh_1_1typed_1_1monostate.html" title="Trivial empty type representing &quot;no value&quot;.">typed::monostate</a></code>, storage is obtained via <code>new T[size]</code> and automatically released by the default deleter. </li>
<li>
Otherwise, a user-provided allocator type is instantiated and used to allocate <em>exactly</em> <code>size</code> elements, with lifetime managed through a bound deleter lambda that captures both the allocator and allocation size. </li>
<li>
All elements are <b>zero-initialized</b> (for PODs) or <b>default-constructed</b> (for non-PODs) immediately after allocation. </li>
<li>
Semantically, this behaves like <code>std::vector&lt;T&gt;(size)</code> but without growth capacity or <code>allocator_traits</code> overhead. </li>
</ul>
<p><b>Performance characteristics</b> </p><ul>
<li>
For <b>POD-like</b> types, this path compiles down to a single contiguous allocation followed by a <code>memset</code> or equivalent zero-fill. </li>
<li>
For non-trivial types, it performs element-wise default construction with strong exception safety guarantees. </li>
<li>
No dynamic resizing or capacity growth is performed — the array size is fixed for the lifetime of the object. </li>
<li>
In microbenchmarks, this constructor matches or slightly outperforms <code>std::vector&lt;T&gt;(size)</code> due to the absence of allocator-layer indirection. </li>
</ul>
<p><b>Allocator semantics</b> </p><ul>
<li>
When using a custom allocator, a lambda deleter is bound that correctly invokes <code>alloc.deallocate(ptr, size)</code> upon destruction. </li>
<li>
This preserves RAII semantics and guarantees proper cleanup even in the presence of exceptions. </li>
<li>
The allocator is captured by value, ensuring deterministic deallocation. </li>
</ul>
<dl class="section note"><dt>Note</dt><dd>This constructor is the canonical entry point for creating safe, fixed-size runtime arrays. It offers predictable initialization and deallocation behavior, suitable for both POD and non-POD types.</dd></dl>

</div>
</div>
<a id="abc72122d7177a615f027f7e94ac394a0" name="abc72122d7177a615f027f7e94ac394a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc72122d7177a615f027f7e94ac394a0">&#9670;&#160;</a></span>runtime_arr() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = typed::monostate&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classjh_1_1runtime__arr.html">jh::runtime_arr</a>&lt; T, Alloc &gt;::runtime_arr </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; T &gt;</td>          <td class="paramname"><span class="paramname"><em>init</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Alloc &amp;</td>          <td class="paramname"><span class="paramname"><em>alloc</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a fixed-size runtime array from an initializer list using a custom allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">init</td><td>Initializer list providing the values for each element. </td></tr>
    <tr><td class="paramname">alloc</td><td>Allocator instance used for allocation and deallocation.</td></tr>
  </table>
  </dd>
</dl>
<p>Allocates <code>init.size()</code> elements via the provided allocator and performs <code>std::uninitialized_copy</code> to populate the buffer. The allocator is stored within a bound deleter lambda for correct deallocation. </p>
<ul>
<li>
Enabled only when <code>Alloc != <a class="el" href="structjh_1_1typed_1_1monostate.html" title="Trivial empty type representing &quot;no value&quot;.">typed::monostate</a></code>. </li>
<li>
Performs <code>alloc.allocate(size)</code> and binds <code>alloc.deallocate(ptr, size)</code> as deleter. </li>
<li>
Ensures allocator-aware destruction and exception safety. </li>
<li>
Move-only type; copy operations are deleted. </li>
</ul>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>If allocator fails to provide storage. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aec5d640b75d6b0c6c27cc33ab2ee3649" name="aec5d640b75d6b0c6c27cc33ab2ee3649"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec5d640b75d6b0c6c27cc33ab2ee3649">&#9670;&#160;</a></span>runtime_arr() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = typed::monostate&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classjh_1_1runtime__arr.html">jh::runtime_arr</a>&lt; T, Alloc &gt;::runtime_arr </td>
          <td>(</td>
          <td class="paramtype">std::uint64_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Alloc &amp;</td>          <td class="paramname"><span class="paramname"><em>alloc</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel explicit">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a runtime array using a movable allocator instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="#a7e594d60b00921524830179b3caa1373" title="Returns the number of elements in the array.">size</a></td><td>Number of elements to allocate. </td></tr>
    <tr><td class="paramname">alloc</td><td>Allocator instance (may be lvalue or rvalue).</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>
Enabled only when <code>Alloc</code> is not <code><a class="el" href="structjh_1_1typed_1_1monostate.html" title="Trivial empty type representing &quot;no value&quot;.">typed::monostate</a></code>. </li>
<li>
Accepts both lvalue and rvalue allocators; the allocator instance is captured by value (moved if possible) inside the deleter closure. </li>
<li>
Provides full support for <code>std::pmr::polymorphic_allocator&lt;T&gt;</code> and other stateful allocators. </li>
</ul>
<p><b>Design notes</b> </p><ul>
<li>
This overload avoids unnecessary allocator copies and preserves resource binding. </li>
<li>
Equivalent to the by-value form for trivially copyable allocators. </li>
<li>
Ensures allocator lifetime and destruction safety via lambda capture semantics. </li>
</ul>

</div>
</div>
<a id="ae524b53bf6db1141c965cbee7f55ca36" name="ae524b53bf6db1141c965cbee7f55ca36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae524b53bf6db1141c965cbee7f55ca36">&#9670;&#160;</a></span>runtime_arr() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = typed::monostate&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classjh_1_1runtime__arr.html">jh::runtime_arr</a>&lt; T, Alloc &gt;::runtime_arr </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>vec</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel explicit">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a <code>runtime_arr&lt;T&gt;</code> by moving from a <code>std::vector&lt;T&gt;</code> (only when <code>Alloc</code> is <code><a class="el" href="structjh_1_1typed_1_1monostate.html" title="Trivial empty type representing &quot;no value&quot;.">typed::monostate</a></code>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>Rvalue reference to a <code>std::vector&lt;T&gt;</code> whose contents will be moved.</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>
Enabled only when <code>Alloc == <a class="el" href="structjh_1_1typed_1_1monostate.html" title="Trivial empty type representing &quot;no value&quot;.">typed::monostate</a></code>, ensuring consistent <code>new[]</code>/<code>delete[]</code> semantics. </li>
<li>
Allocates a new contiguous buffer of <code>vec.size()</code> elements via <code>operator new[]</code>. </li>
<li>
Performs an element-wise move from <code>vec</code> into the internal storage. </li>
<li>
The source vector remains in a valid but unspecified state after construction (per standard move semantics). </li>
<li>
The resulting <code><a class="el" href="classjh_1_1runtime__arr.html" title="A move-only, fixed-capacity array with runtime-determined length and RAII-based ownership.">runtime_arr</a></code> owns its own independent storage and does not alias <code>vec</code>'s memory. </li>
</ul>
<p><b>Rationale</b> </p><ul>
<li>
This constructor provides a convenient transition path from STL containers to fixed-size <code><a class="el" href="classjh_1_1runtime__arr.html" title="A move-only, fixed-capacity array with runtime-determined length and RAII-based ownership.">runtime_arr</a></code> semantics. </li>
<li>
Unlike <code>std::vector::reserve()</code> or <code>shrink_to_fit()</code>, this operation guarantees immutability of capacity and clear ownership transfer. </li>
<li>
It is intentionally limited to <code><a class="el" href="structjh_1_1typed_1_1monostate.html" title="Trivial empty type representing &quot;no value&quot;.">typed::monostate</a></code> allocators to ensure predictable <code>operator new[]</code> / <code>operator delete[]</code> lifetime management without allocator-specific behavior. </li>
</ul>
<p><b>Performance Notes</b> </p><ul>
<li>
For trivially movable POD types, the move loop is typically optimized to a single <code>memcpy</code> by the compiler. </li>
<li>
For non-trivial types, each element's move constructor is invoked individually. </li>
<li>
Construction cost is proportional to <code>O(n)</code> moves, matching <code>std::vector::move()</code> semantics but with fixed-size final storage. </li>
</ul>
<p><b>Example:</b></p>
<div class="fragment"><div class="line">std::vector&lt;MyPod&gt; <a class="code hl_function" href="#acb17565fd5d1e165b66ffc74fc7fed9e">data</a>(1024);</div>
<div class="line"><span class="comment">// Fill data...</span></div>
<div class="line"><a class="code hl_class" href="classjh_1_1runtime__arr.html">jh::runtime_arr&lt;MyPod&gt;</a> arr(std::move(<a class="code hl_function" href="#acb17565fd5d1e165b66ffc74fc7fed9e">data</a>));</div>
<div class="line"><span class="comment">// arr now owns a separate buffer containing the moved elements.</span></div>
<div class="ttc" id="aclassjh_1_1runtime__arr_html"><div class="ttname"><a href="classjh_1_1runtime__arr.html">jh::runtime_arr</a></div><div class="ttdoc">A move-only, fixed-capacity array with runtime-determined length and RAII-based ownership.</div><div class="ttdef"><b>Definition</b> runtime_arr.h:365</div></div>
<div class="ttc" id="aclassjh_1_1runtime__arr_html_acb17565fd5d1e165b66ffc74fc7fed9e"><div class="ttname"><a href="#acb17565fd5d1e165b66ffc74fc7fed9e">jh::runtime_arr::data</a></div><div class="ttdeci">pointer data() noexcept</div><div class="ttdoc">Provides raw pointer access to the underlying storage.</div><div class="ttdef"><b>Definition</b> runtime_arr.h:908</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a1f7aafb0e3297ca61f5c130f53d8cc36" name="a1f7aafb0e3297ca61f5c130f53d8cc36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f7aafb0e3297ca61f5c130f53d8cc36">&#9670;&#160;</a></span>runtime_arr() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = typed::monostate&gt; </div>
<div class="memtemplate">
template&lt;typename ForwardIt&gt; <br />
requires (typed::monostate_t&lt;Alloc&gt; &amp;&amp; <a class="el" href="conceptjh_1_1concepts_1_1forward__iterator.html">jh::concepts::forward_iterator</a>&lt;ForwardIt&gt; &amp;&amp; std::convertible_to&lt;typename ForwardIt::value_type, <a class="el" href="#a97517148237e3df1e3bcc062e648aaf6">value_type</a>&gt; &amp;&amp; std::is_copy_constructible_v&lt;T&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classjh_1_1runtime__arr.html">jh::runtime_arr</a>&lt; T, Alloc &gt;::runtime_arr </td>
          <td>(</td>
          <td class="paramtype">ForwardIt</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt</td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a <code>runtime_arr&lt;T&gt;</code> from any valid forward iterator range. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ForwardIt</td><td>Iterator type satisfying <code><a class="el" href="conceptjh_1_1concepts_1_1forward__iterator.html" title="Concept for multi-pass, readable, and self-sentinel iterators.">jh::concepts::forward_iterator</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Beginning of the input range. </td></tr>
    <tr><td class="paramname">last</td><td>End of the input range.</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>
Enabled only when <code>Alloc == <a class="el" href="structjh_1_1typed_1_1monostate.html" title="Trivial empty type representing &quot;no value&quot;.">typed::monostate</a></code> and <code>T</code> is copy-constructible. </li>
<li>
Allocates a contiguous buffer large enough to hold <code>std::distance(first, last)</code> elements. </li>
<li>
Copies (or moves, if wrapped with <code>std::make_move_iterator</code>) elements from the source range into internal storage. </li>
<li>
Ownership is managed via RAII (<code>std::unique_ptr</code> with custom deleter). </li>
</ul>
<p><b>Behavior</b> </p><ul>
<li>
If the range is empty, the resulting array is empty (<code><a class="el" href="#a7e594d60b00921524830179b3caa1373" title="Returns the number of elements in the array.">size()</a> == 0</code>). </li>
<li>
If <code>std::distance(first, last) &lt; 0</code>, an <code>std::invalid_argument</code> exception is thrown. </li>
<li>
Otherwise, <code>new[]</code> is used to allocate storage and <code>std::copy()</code> (or <code>std::move()</code>) to fill it. </li>
</ul>
<p><b>Examples</b> </p>
<p><b>From STL containers:</b></p>
<div class="fragment"><div class="line">std::vector&lt;int&gt; v = {1, 2, 3};</div>
<div class="line"><a class="code hl_class" href="classjh_1_1runtime__arr.html">jh::runtime_arr&lt;int&gt;</a> a(v.begin(), v.end());   <span class="comment">// copy</span></div>
<div class="line"> </div>
<div class="line">std::deque&lt;int&gt; d = {4, 5, 6};</div>
<div class="line"><a class="code hl_class" href="classjh_1_1runtime__arr.html">jh::runtime_arr&lt;int&gt;</a> b(d.begin(), d.end());   <span class="comment">// copy</span></div>
<div class="line"> </div>
<div class="line">std::string s = <span class="stringliteral">&quot;Hello, world!&quot;</span>;</div>
<div class="line"><a class="code hl_class" href="classjh_1_1runtime__arr.html">jh::runtime_arr&lt;char&gt;</a> chars(</div>
<div class="line">    std::make_move_iterator(s.begin()),</div>
<div class="line">    std::make_move_iterator(s.end()));        <span class="comment">// moves underlying characters</span></div>
</div><!-- fragment --><p><b>From other iterator sources:</b></p>
<div class="fragment"><div class="line"><span class="comment">// Construct from raw array range</span></div>
<div class="line"><span class="keywordtype">int</span> raw[] = {10, 20, 30, 40};</div>
<div class="line"><a class="code hl_class" href="classjh_1_1runtime__arr.html">jh::runtime_arr&lt;int&gt;</a> arr(std::begin(raw), std::end(raw));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Construct from std::span</span></div>
<div class="line">std::span&lt;int&gt; sp(raw);</div>
<div class="line"><a class="code hl_class" href="classjh_1_1runtime__arr.html">jh::runtime_arr&lt;int&gt;</a> arr2(sp.begin(), sp.end());</div>
</div><!-- fragment --><p>Applicable to any iterator pair that defines a finite, measurable range — e.g., pointers, container iterators, or spans. <b>Single-pass input iterators</b> (like <code>std::istream_iterator</code>) are <b>not supported</b>, since <code>std::distance()</code> requires multiple passes to compute the range size. </p>
<p><b>Design rationale</b> </p><ul>
<li>
This constructor acts as a <b>universal range importer</b>, supporting all standard forward-iterable containers and algorithms. </li>
<li>
It mirrors <code>std::vector(ForwardIt, ForwardIt)</code> semantics, but without reallocation or capacity growth. </li>
<li>
Using <code><a class="el" href="conceptjh_1_1concepts_1_1forward__iterator.html" title="Concept for multi-pass, readable, and self-sentinel iterators.">jh::concepts::forward_iterator</a></code> ensures that <code>std::distance()</code> is non-destructive and efficient. </li>
<li>
When used with <code>std::make_move_iterator</code>, move-constructible elements are efficiently transferred without extra copies. </li>
</ul>

</div>
</div>
<a id="a3a070a80c26d67cfde0f1a0c2744260b" name="a3a070a80c26d67cfde0f1a0c2744260b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a070a80c26d67cfde0f1a0c2744260b">&#9670;&#160;</a></span>runtime_arr() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = typed::monostate&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classjh_1_1runtime__arr.html">jh::runtime_arr</a>&lt; T, Alloc &gt;::runtime_arr </td>
          <td>(</td>
          <td class="paramtype">runtime_arr&lt; T, Alloc &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a new <code><a class="el" href="classjh_1_1runtime__arr.html" title="A move-only, fixed-capacity array with runtime-determined length and RAII-based ownership.">runtime_arr</a></code> by taking ownership of another instance's data. </p>
<p>Transfers ownership of the underlying buffer from <code>other</code> to this instance. After the move, <code>other</code> is left in a valid but empty state (<code><a class="el" href="#a7e594d60b00921524830179b3caa1373" title="Returns the number of elements in the array.">size()</a> == 0</code>, <code><a class="el" href="#acb17565fd5d1e165b66ffc74fc7fed9e" title="Provides raw pointer access to the underlying storage.">data()</a> == nullptr</code>). </p>

</div>
</div>
<a id="af51bf6ce71b7696cfcb1389743ead1c0" name="af51bf6ce71b7696cfcb1389743ead1c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af51bf6ce71b7696cfcb1389743ead1c0">&#9670;&#160;</a></span>runtime_arr() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = typed::monostate&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classjh_1_1runtime__arr.html">jh::runtime_arr</a>&lt; T, Alloc &gt;::runtime_arr </td>
          <td>(</td>
          <td class="paramtype">const runtime_arr&lt; T, Alloc &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel delete">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor is explicitly deleted. </p>
<p>Copying a <code><a class="el" href="classjh_1_1runtime__arr.html" title="A move-only, fixed-capacity array with runtime-determined length and RAII-based ownership.">runtime_arr</a></code> is intentionally disallowed, as the class models a <b>fixed-size, region-bound buffer</b> — conceptually similar to a safe version of a <b>VLA (Variable Length Array)</b>.</p>
<p>Each <code><a class="el" href="classjh_1_1runtime__arr.html" title="A move-only, fixed-capacity array with runtime-determined length and RAII-based ownership.">runtime_arr</a></code> instance owns a unique contiguous memory block via <code>std::unique_ptr</code>. Allowing copy semantics would imply duplicating or aliasing this region, violating its design goal of <b>unique, region-local ownership</b>. </p>
<p>To share or pass an existing array, use references: <code><a class="el" href="classjh_1_1runtime__arr.html" title="A move-only, fixed-capacity array with runtime-determined length and RAII-based ownership.">runtime_arr</a>&amp;</code> or <code>std::reference_wrapper&lt;runtime_arr&gt;</code>. This preserves ownership while allowing safe, non-copy access across function boundaries. </p>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="a2654858f9372bd281bcd387478aa4783" name="a2654858f9372bd281bcd387478aa4783"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2654858f9372bd281bcd387478aa4783">&#9670;&#160;</a></span>at() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = typed::monostate&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a906ccd2e6efdd6f9dea8247b02ef046c">reference</a> <a class="el" href="classjh_1_1runtime__arr.html">jh::runtime_arr</a>&lt; T, Alloc &gt;::at </td>
          <td>(</td>
          <td class="paramtype">std::uint64_t</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bounds-checked element access. </p>
<p>Returns a reference to the element at the given index, performing explicit range checking. If <code>index &gt;= <a class="el" href="#a7e594d60b00921524830179b3caa1373" title="Returns the number of elements in the array.">size()</a></code>, an <code>std::out_of_range</code> exception is thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Element index within <code>[0, <a class="el" href="#a7e594d60b00921524830179b3caa1373" title="Returns the number of elements in the array.">size()</a>)</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the element at the specified index. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>If <code>index &gt;= <a class="el" href="#a7e594d60b00921524830179b3caa1373" title="Returns the number of elements in the array.">size()</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#aea6ba1c1e5af369a2329c8ec06c9bd52" title="Unchecked element access.">operator[]()</a> </dd></dl>

</div>
</div>
<a id="a65523a8630e922ef4c4cdb9a223e321d" name="a65523a8630e922ef4c4cdb9a223e321d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65523a8630e922ef4c4cdb9a223e321d">&#9670;&#160;</a></span>at() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = typed::monostate&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a035fb9232d8d89abdb7a2cb9bc1629c4">const_reference</a> <a class="el" href="classjh_1_1runtime__arr.html">jh::runtime_arr</a>&lt; T, Alloc &gt;::at </td>
          <td>(</td>
          <td class="paramtype">std::uint64_t</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Const bounds-checked element access. </p>
<p>Returns a const reference to the element at the given index, performing explicit range checking. If <code>index &gt;= <a class="el" href="#a7e594d60b00921524830179b3caa1373" title="Returns the number of elements in the array.">size()</a></code>, an <code>std::out_of_range</code> exception is thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Element index within <code>[0, <a class="el" href="#a7e594d60b00921524830179b3caa1373" title="Returns the number of elements in the array.">size()</a>)</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Const reference to the element at the specified index. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>If <code>index &gt;= <a class="el" href="#a7e594d60b00921524830179b3caa1373" title="Returns the number of elements in the array.">size()</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#aea6ba1c1e5af369a2329c8ec06c9bd52" title="Unchecked element access.">operator[]()</a> </dd></dl>

</div>
</div>
<a id="af5159969eb2185c729307ea8338163eb" name="af5159969eb2185c729307ea8338163eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5159969eb2185c729307ea8338163eb">&#9670;&#160;</a></span>data() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = typed::monostate&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a90b40d1b38338b0de98e9a6bf245a2b0">const_pointer</a> <a class="el" href="classjh_1_1runtime__arr.html">jh::runtime_arr</a>&lt; T, Alloc &gt;::data </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides const raw pointer access to the underlying storage. </p>
<dl class="section return"><dt>Returns</dt><dd>Const pointer to the first element, or <code>nullptr</code> if empty. </dd></dl>

</div>
</div>
<a id="acb17565fd5d1e165b66ffc74fc7fed9e" name="acb17565fd5d1e165b66ffc74fc7fed9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb17565fd5d1e165b66ffc74fc7fed9e">&#9670;&#160;</a></span>data() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = typed::monostate&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#aa7a9136db1823b8dd65f07ca9779a5c1">pointer</a> <a class="el" href="classjh_1_1runtime__arr.html">jh::runtime_arr</a>&lt; T, Alloc &gt;::data </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides raw pointer access to the underlying storage. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the first element, or <code>nullptr</code> if empty. </dd></dl>

</div>
</div>
<a id="adaa69a50e8f42fd488f3f0d57c50040d" name="adaa69a50e8f42fd488f3f0d57c50040d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaa69a50e8f42fd488f3f0d57c50040d">&#9670;&#160;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = typed::monostate&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classjh_1_1runtime__arr.html">jh::runtime_arr</a>&lt; T, Alloc &gt;::empty </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether the array is empty. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code><a class="el" href="#a7e594d60b00921524830179b3caa1373" title="Returns the number of elements in the array.">size()</a> == 0</code>, otherwise <code>false</code>. </dd></dl>

</div>
</div>
<a id="ac811ed28b9b1aef06521b90a3c6e2988" name="ac811ed28b9b1aef06521b90a3c6e2988"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac811ed28b9b1aef06521b90a3c6e2988">&#9670;&#160;</a></span>operator std::vector&lt; T &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = typed::monostate&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classjh_1_1runtime__arr.html">jh::runtime_arr</a>&lt; T, Alloc &gt;::operator std::vector&lt; T &gt; </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel explicit">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts the array into a <code>std::vector&lt;T&gt;</code> by moving its contents. </p>
<p>This conversion performs a one-way ownership transfer from <code>runtime_arr&lt;T&gt;</code> to <code>std::vector&lt;T&gt;</code>, consuming the source in the process. After the conversion, the original <code><a class="el" href="classjh_1_1runtime__arr.html" title="A move-only, fixed-capacity array with runtime-determined length and RAII-based ownership.">runtime_arr</a></code> becomes an empty, valid but unspecified object (<code><a class="el" href="#a7e594d60b00921524830179b3caa1373" title="Returns the number of elements in the array.">size()</a> == 0</code>, <code><a class="el" href="#acb17565fd5d1e165b66ffc74fc7fed9e" title="Provides raw pointer access to the underlying storage.">data()</a> == nullptr</code>).</p>
<p><b>Behavior</b> </p><ul>
<li>
<b>POD-like types (<code>jh::pod_like&lt;T&gt;</code>):</b> Performs a raw <code>std::memcpy</code> for maximal performance. The operation is equivalent to copying a contiguous byte buffer. </li>
<li>
<b>Non-POD types:</b> Uses <code>std::make_move_iterator</code> to move-construct each element into the target vector, ensuring proper object semantics. </li>
</ul>
<p><b>Symmetry</b> </p>
<p>This operator complements the constructor <code><a class="el" href="#ae524b53bf6db1141c965cbee7f55ca36" title="Constructs a runtime_arr&lt;T&gt; by moving from a std::vector&lt;T&gt; (only when Alloc is typed::monostate).">runtime_arr(std::vector&lt;T&gt;&amp;&amp;)</a></code>, enabling seamless two-way transfer between <code>std::vector&lt;T&gt;</code> and <code>runtime_arr&lt;T&gt;</code> with full move semantics. Both conversions leave the source container in a valid but empty state, ensuring safe RAII destruction. </p>
<dl class="section note"><dt>Note</dt><dd>This operator is only available on rvalues (<code>runtime_arr&lt;T&gt;&amp;&amp;</code>), preventing accidental copies. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ae524b53bf6db1141c965cbee7f55ca36" title="Constructs a runtime_arr&lt;T&gt; by moving from a std::vector&lt;T&gt; (only when Alloc is typed::monostate).">runtime_arr(std::vector&lt;T&gt;&amp;&amp;)</a> </dd></dl>

</div>
</div>
<a id="a24fc509c8a69f3874383b7e7066bf754" name="a24fc509c8a69f3874383b7e7066bf754"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24fc509c8a69f3874383b7e7066bf754">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = typed::monostate&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ac3863058778516c1e4c23b7e09d1afc4">runtime_arr</a> &amp; <a class="el" href="classjh_1_1runtime__arr.html">jh::runtime_arr</a>&lt; T, Alloc &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#ac3863058778516c1e4c23b7e09d1afc4">runtime_arr</a>&lt; T, Alloc &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel delete">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator is explicitly deleted. </p>
<p>Like the copy constructor, copy assignment is disabled to prevent unintended duplication of the underlying buffer. This enforces strict RAII-style ownership and guarantees deterministic lifetime management.</p>
<p>When sharing a buffer between scopes or functions, pass by reference (<code><a class="el" href="classjh_1_1runtime__arr.html" title="A move-only, fixed-capacity array with runtime-determined length and RAII-based ownership.">runtime_arr</a>&amp;</code>) or wrap in <code>std::reference_wrapper&lt;runtime_arr&gt;</code> instead of copying. </p>

</div>
</div>
<a id="a750d749fa833692e3c45a27586cadc5f" name="a750d749fa833692e3c45a27586cadc5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a750d749fa833692e3c45a27586cadc5f">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = typed::monostate&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ac3863058778516c1e4c23b7e09d1afc4">runtime_arr</a> &amp; <a class="el" href="classjh_1_1runtime__arr.html">jh::runtime_arr</a>&lt; T, Alloc &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ac3863058778516c1e4c23b7e09d1afc4">runtime_arr</a>&lt; T, Alloc &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the contents of this <code><a class="el" href="classjh_1_1runtime__arr.html" title="A move-only, fixed-capacity array with runtime-determined length and RAII-based ownership.">runtime_arr</a></code> with those of another, transferring ownership. </p>
<p>Releases any existing data owned by this instance and takes ownership of <code>other</code>'s buffer. The source <code>other</code> becomes empty and remains safely destructible.</p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the updated <code>*this</code>. </dd></dl>

</div>
</div>
<a id="a29f9fd3200c645fdd170cba56a913020" name="a29f9fd3200c645fdd170cba56a913020"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29f9fd3200c645fdd170cba56a913020">&#9670;&#160;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = typed::monostate&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a035fb9232d8d89abdb7a2cb9bc1629c4">const_reference</a> <a class="el" href="classjh_1_1runtime__arr.html">jh::runtime_arr</a>&lt; T, Alloc &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">std::uint64_t</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unchecked const element access. </p>
<p>Const overload providing read-only access to the element at the given index (undefined behavior if out of range).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Element index within <code>[0, <a class="el" href="#a7e594d60b00921524830179b3caa1373" title="Returns the number of elements in the array.">size()</a>)</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Const reference to the element. </dd></dl>

</div>
</div>
<a id="aea6ba1c1e5af369a2329c8ec06c9bd52" name="aea6ba1c1e5af369a2329c8ec06c9bd52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea6ba1c1e5af369a2329c8ec06c9bd52">&#9670;&#160;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = typed::monostate&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a906ccd2e6efdd6f9dea8247b02ef046c">reference</a> <a class="el" href="classjh_1_1runtime__arr.html">jh::runtime_arr</a>&lt; T, Alloc &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">std::uint64_t</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unchecked element access. </p>
<p>Returns a reference to the element at the given index without performing bounds checking (undefined behavior if out of range). Equivalent to <code>*(<a class="el" href="#acb17565fd5d1e165b66ffc74fc7fed9e" title="Provides raw pointer access to the underlying storage.">data()</a> + index)</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Element index within <code>[0, <a class="el" href="#a7e594d60b00921524830179b3caa1373" title="Returns the number of elements in the array.">size()</a>)</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the element. </dd></dl>

</div>
</div>
<a id="afadcdd48a2f76c5d3b3db29a4691b2ed" name="afadcdd48a2f76c5d3b3db29a4691b2ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afadcdd48a2f76c5d3b3db29a4691b2ed">&#9670;&#160;</a></span>reset_all()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = typed::monostate&gt; </div>
<div class="memtemplate">
template&lt;typename U = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classjh_1_1runtime__arr.html">jh::runtime_arr</a>&lt; T, Alloc &gt;::reset_all </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resets all elements to their default-initialized state. </p>
<p>Reinitializes every element in the array as if assigned with <code>T{}</code>. The actual strategy depends on the structural properties of <code>T</code>:</p>
<ul>
<li>
<b>POD-like types</b> — memory is cleared with <code>std::memset()</code> for maximal performance and determinism. </li>
<li>
<b>Trivially destructible types</b> — reinitialized in-place using placement-new (<code>new(p) T{}</code>), without invoking destructors. </li>
<li>
<b>Non-trivial types</b> — each element is explicitly assigned <code>T{}</code>, invoking both destructor and constructor logic. </li>
</ul>
<p><b>Implementation Notes</b> </p><ul>
<li>
<b>Flatten attribute:</b> Explicit compiler flattening (e.g. <code>[[gnu::flatten]]</code>) was experimentally tested and removed. On <b>LLVM Clang 20</b> with <code>-O3</code> or higher, <code>flatten</code> introduced micro-jitter and inhibited certain inliner heuristics. Modern LLVM optimizers already perform ideal unrolling and hoisting automatically. </li>
<li>
<b>Template parameter <code>U</code>:</b> This indirection allows SFINAE-based disabling via <code>requires(std::is_default_constructible_v&lt;U&gt;)</code> without interfering with specialized overloads — such as the <code><a class="el" href="classjh_1_1runtime__arr_3_01bool_01_4.html" title="Specialized implementation of jh::runtime_arr&lt;bool&gt; — a compact, bit-packed boolean array.">runtime_arr&lt;bool&gt;</a></code> specialization, which defines its own <code><a class="el" href="#afadcdd48a2f76c5d3b3db29a4691b2ed" title="Resets all elements to their default-initialized state.">reset_all()</a></code>. </li>
</ul>
<dl class="section note"><dt>Note</dt><dd>This function is <code>noexcept</code> for all valid <code>T</code>. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Accessing elements before reset on uninitialized memory results in undefined behavior. </dd></dl>

</div>
</div>
<a id="a0bc8f08ae6499a915e14526ba648ff6e" name="a0bc8f08ae6499a915e14526ba648ff6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bc8f08ae6499a915e14526ba648ff6e">&#9670;&#160;</a></span>set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = typed::monostate&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classjh_1_1runtime__arr.html">jh::runtime_arr</a>&lt; T, Alloc &gt;::set </td>
          <td>(</td>
          <td class="paramtype">std::uint64_t</td>          <td class="paramname"><span class="paramname"><em>i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the value at given index using constructor arguments. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Index to write to </td></tr>
    <tr><td class="paramname">args</td><td>Arguments to construct T </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7e594d60b00921524830179b3caa1373" name="a7e594d60b00921524830179b3caa1373"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e594d60b00921524830179b3caa1373">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Alloc = typed::monostate&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ab912d4806390f4876a456096780ff139">size_type</a> <a class="el" href="classjh_1_1runtime__arr.html">jh::runtime_arr</a>&lt; T, Alloc &gt;::size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements in the array. </p>
<dl class="section return"><dt>Returns</dt><dd>Number of elements currently stored. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/jh/core/<a class="el" href="">runtime_arr.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
</div> <!-- top -->
<hr class="footer"/>
<div class="footer">
    <img class="footer-logo" src="Ojing.svg" alt="Ojing"/>
    <div class="footer-text">
        JH-Toolkit v1.4.0 · Generated by Doxygen
    </div>
    <div class="footer-note">
        We primarily support embedded documentation views in IDEs (classic CLion).
        To ensure compatibility with embedded rendering, some example code in this
        documentation intentionally contains HTML entities.
        In certain cases, Doxygen does not unescape these entities correctly.
        This is a known limitation and currently has no workaround.
    </div>
</div>
</body>
</html>
