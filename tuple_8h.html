<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.16.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>JH-Toolkit: include/jh/pods/tuple.h File Reference</title>
<link rel="icon" href="Jindallae.svg" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="Oree.svg"/></td>
  <td id="projectalign">
   <div id="projectname">JH-Toolkit<span id="projectnumber">&#160;v1.4.0</span>
   </div>
   <div id="projectbrief">An engineering-oriented C++20 toolkit with duck-typed concepts, static design, async coroutines, and semantic containers — header-only, RTTI-free, and concurrency-friendly.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.16.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('tuple_8h.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">tuple.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Implementation of POD-compatible tuple, pair and array bindings.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;tuple&gt;</code><br />
<code>#include &lt;utility&gt;</code><br />
<code>#include &lt;type_traits&gt;</code><br />
<code>#include &lt;iostream&gt;</code><br />
<code>#include &quot;<a class="el" href="">jh/pods/pod_like.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="">jh/pods/pair.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="">jh/pods/array.h</a>&quot;</code><br />
</div>
<p><a href="">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:jh_3A_3Apod_3A_3Atuple_3C_20Ts_20_3E" id="r_jh_3A_3Apod_3A_3Atuple_3C_20Ts_20_3E"><td class="memItemLeft">struct &#160;</td><td class="memItemRight"><a class="el" href="structjh_1_1pod_1_1tuple.html">jh::pod::tuple&lt; Ts &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">POD-compatible tuple type supporting structured bindings and tuple-like utilities.  <a href="structjh_1_1pod_1_1tuple.html#details">More...</a><br /></td></tr>
<tr class="memitem:std_3A_3Atuple_5Fsize_3C_20jh_3A_3Apod_3A_3Atuple_3C_20Ts_2E_2E_2E_20_3E_20_3E" id="r_std_3A_3Atuple_5Fsize_3C_20jh_3A_3Apod_3A_3Atuple_3C_20Ts_2E_2E_2E_20_3E_20_3E"><td class="memItemLeft">struct &#160;</td><td class="memItemRight"><a class="el" href="structstd_1_1tuple__size_3_01jh_1_1pod_1_1tuple_3_01Ts_8_8_8_01_4_01_4.html">std::tuple_size&lt; jh::pod::tuple&lt; Ts... &gt; &gt;</a></td></tr>
<tr class="memitem:std_3A_3Atuple_5Felement_3C_20I_2C_20jh_3A_3Apod_3A_3Atuple_3C_20Ts_2E_2E_2E_20_3E_20_3E" id="r_std_3A_3Atuple_5Felement_3C_20I_2C_20jh_3A_3Apod_3A_3Atuple_3C_20Ts_2E_2E_2E_20_3E_20_3E"><td class="memItemLeft">struct &#160;</td><td class="memItemRight"><a class="el" href="structstd_1_1tuple__element_3_01I_00_01jh_1_1pod_1_1tuple_3_01Ts_8_8_8_01_4_01_4.html">std::tuple_element&lt; I, jh::pod::tuple&lt; Ts... &gt; &gt;</a></td></tr>
<tr class="memitem:std_3A_3Atuple_5Fsize_3C_20jh_3A_3Apod_3A_3Apair_3C_20T1_2C_20T2_20_3E_20_3E" id="r_std_3A_3Atuple_5Fsize_3C_20jh_3A_3Apod_3A_3Apair_3C_20T1_2C_20T2_20_3E_20_3E"><td class="memItemLeft">struct &#160;</td><td class="memItemRight"><a class="el" href="structstd_1_1tuple__size_3_01jh_1_1pod_1_1pair_3_01T1_00_01T2_01_4_01_4.html">std::tuple_size&lt; jh::pod::pair&lt; T1, T2 &gt; &gt;</a></td></tr>
<tr class="memitem:std_3A_3Atuple_5Felement_3C_20I_2C_20jh_3A_3Apod_3A_3Apair_3C_20T1_2C_20T2_20_3E_20_3E" id="r_std_3A_3Atuple_5Felement_3C_20I_2C_20jh_3A_3Apod_3A_3Apair_3C_20T1_2C_20T2_20_3E_20_3E"><td class="memItemLeft">struct &#160;</td><td class="memItemRight"><a class="el" href="structstd_1_1tuple__element_3_01I_00_01jh_1_1pod_1_1pair_3_01T1_00_01T2_01_4_01_4.html">std::tuple_element&lt; I, jh::pod::pair&lt; T1, T2 &gt; &gt;</a></td></tr>
<tr class="memitem:std_3A_3Atuple_5Fsize_3C_20jh_3A_3Apod_3A_3Aarray_3C_20T_2C_20N_20_3E_20_3E" id="r_std_3A_3Atuple_5Fsize_3C_20jh_3A_3Apod_3A_3Aarray_3C_20T_2C_20N_20_3E_20_3E"><td class="memItemLeft">struct &#160;</td><td class="memItemRight"><a class="el" href="structstd_1_1tuple__size_3_01jh_1_1pod_1_1array_3_01T_00_01N_01_4_01_4.html">std::tuple_size&lt; jh::pod::array&lt; T, N &gt; &gt;</a></td></tr>
<tr class="memitem:std_3A_3Atuple_5Felement_3C_20I_2C_20jh_3A_3Apod_3A_3Aarray_3C_20T_2C_20N_20_3E_20_3E" id="r_std_3A_3Atuple_5Felement_3C_20I_2C_20jh_3A_3Apod_3A_3Aarray_3C_20T_2C_20N_20_3E_20_3E"><td class="memItemLeft">struct &#160;</td><td class="memItemRight"><a class="el" href="structstd_1_1tuple__element_3_01I_00_01jh_1_1pod_1_1array_3_01T_00_01N_01_4_01_4.html">std::tuple_element&lt; I, jh::pod::array&lt; T, N &gt; &gt;</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ae1bd6e506220f11404194937e2be1cce" id="r_ae1bd6e506220f11404194937e2be1cce"><td class="memTemplParams" colspan="2"><a id="ae1bd6e506220f11404194937e2be1cce" name="ae1bd6e506220f11404194937e2be1cce"></a>
template&lt;std::size_t I, typename... Ts&gt; </td></tr>
<tr class="memitem:ae1bd6e506220f11404194937e2be1cce template"><td class="memItemLeft">constexpr decltype(auto)&#160;</td><td class="memItemRight"><b>jh::pod::get</b> (<a class="el" href="structjh_1_1pod_1_1tuple.html">tuple</a>&lt; Ts... &gt; &amp;t) noexcept</td></tr>
<tr class="memitem:a2c842a88452f24dd8d08839a2405f368" id="r_a2c842a88452f24dd8d08839a2405f368"><td class="memTemplParams" colspan="2"><a id="a2c842a88452f24dd8d08839a2405f368" name="a2c842a88452f24dd8d08839a2405f368"></a>
template&lt;std::size_t I, typename... Ts&gt; </td></tr>
<tr class="memitem:a2c842a88452f24dd8d08839a2405f368 template"><td class="memItemLeft">constexpr auto&#160;</td><td class="memItemRight"><b>jh::pod::get</b> (const <a class="el" href="structjh_1_1pod_1_1tuple.html">tuple</a>&lt; Ts... &gt; &amp;t) noexcept</td></tr>
<tr class="memitem:abf3360f159d9d476d3096d51599cce69" id="r_abf3360f159d9d476d3096d51599cce69"><td class="memTemplParams" colspan="2"><a id="abf3360f159d9d476d3096d51599cce69" name="abf3360f159d9d476d3096d51599cce69"></a>
template&lt;std::size_t I, typename T1, typename T2&gt; </td></tr>
<tr class="memitem:abf3360f159d9d476d3096d51599cce69 template"><td class="memItemLeft">constexpr decltype(auto)&#160;</td><td class="memItemRight"><b>jh::pod::get</b> (<a class="el" href="structjh_1_1pod_1_1pair.html">jh::pod::pair</a>&lt; T1, T2 &gt; &amp;p) noexcept</td></tr>
<tr class="memitem:affeb6a5b6a13a9f06730906d72b561cf" id="r_affeb6a5b6a13a9f06730906d72b561cf"><td class="memTemplParams" colspan="2"><a id="affeb6a5b6a13a9f06730906d72b561cf" name="affeb6a5b6a13a9f06730906d72b561cf"></a>
template&lt;std::size_t I, typename T1, typename T2&gt; </td></tr>
<tr class="memitem:affeb6a5b6a13a9f06730906d72b561cf template"><td class="memItemLeft">constexpr decltype(auto)&#160;</td><td class="memItemRight"><b>jh::pod::get</b> (const <a class="el" href="structjh_1_1pod_1_1pair.html">jh::pod::pair</a>&lt; T1, T2 &gt; &amp;p) noexcept</td></tr>
<tr class="memitem:ac623c9763124cea99b74690cf5c4ff07" id="r_ac623c9763124cea99b74690cf5c4ff07"><td class="memTemplParams" colspan="2"><a id="ac623c9763124cea99b74690cf5c4ff07" name="ac623c9763124cea99b74690cf5c4ff07"></a>
template&lt;std::size_t I, typename T, std::uint16_t N&gt; </td></tr>
<tr class="memitem:ac623c9763124cea99b74690cf5c4ff07 template"><td class="memItemLeft">constexpr decltype(auto)&#160;</td><td class="memItemRight"><b>jh::pod::get</b> (<a class="el" href="structjh_1_1pod_1_1array.html">jh::pod::array</a>&lt; T, N &gt; &amp;a) noexcept</td></tr>
<tr class="memitem:a6408a3a12eb5e743d20ea9d51c34a7c9" id="r_a6408a3a12eb5e743d20ea9d51c34a7c9"><td class="memTemplParams" colspan="2"><a id="a6408a3a12eb5e743d20ea9d51c34a7c9" name="a6408a3a12eb5e743d20ea9d51c34a7c9"></a>
template&lt;std::size_t I, typename T, std::uint16_t N&gt; </td></tr>
<tr class="memitem:a6408a3a12eb5e743d20ea9d51c34a7c9 template"><td class="memItemLeft">constexpr decltype(auto)&#160;</td><td class="memItemRight"><b>jh::pod::get</b> (const <a class="el" href="structjh_1_1pod_1_1array.html">jh::pod::array</a>&lt; T, N &gt; &amp;a) noexcept</td></tr>
<tr class="memitem:a9feeff694ec7515b0c23c78aa7ada0f4" id="r_a9feeff694ec7515b0c23c78aa7ada0f4"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:a9feeff694ec7515b0c23c78aa7ada0f4 template"><td class="memItemLeft">constexpr auto&#160;</td><td class="memItemRight"><a class="el" href="namespacejh_1_1pod.html#a9feeff694ec7515b0c23c78aa7ada0f4">jh::pod::make_tuple</a> (Ts &amp;&amp;... args) noexcept</td></tr>
<tr class="memdesc:a9feeff694ec7515b0c23c78aa7ada0f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a POD-compatible tuple from given arguments.  <br /></td></tr>
<tr class="memitem:a72c322f015f289981d0fb6afcf46b7aa" id="r_a72c322f015f289981d0fb6afcf46b7aa"><td class="memTemplParams" colspan="2"><a id="a72c322f015f289981d0fb6afcf46b7aa" name="a72c322f015f289981d0fb6afcf46b7aa"></a>
template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:a72c322f015f289981d0fb6afcf46b7aa template"><td class="memItemLeft">constexpr bool&#160;</td><td class="memItemRight"><b>jh::pod::operator==</b> (const <a class="el" href="structjh_1_1pod_1_1tuple.html">tuple</a>&lt; Ts... &gt; &amp;lhs, const <a class="el" href="structjh_1_1pod_1_1tuple.html">tuple</a>&lt; Ts... &gt; &amp;rhs) noexcept</td></tr>
<tr class="memitem:ab9e38a6121efa1d1b0ecf1ce98839ebf" id="r_ab9e38a6121efa1d1b0ecf1ce98839ebf"><td class="memTemplParams" colspan="2"><a id="ab9e38a6121efa1d1b0ecf1ce98839ebf" name="ab9e38a6121efa1d1b0ecf1ce98839ebf"></a>
template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:ab9e38a6121efa1d1b0ecf1ce98839ebf template"><td class="memItemLeft">constexpr bool&#160;</td><td class="memItemRight"><b>jh::pod::operator!=</b> (const <a class="el" href="structjh_1_1pod_1_1tuple.html">tuple</a>&lt; Ts... &gt; &amp;lhs, const <a class="el" href="structjh_1_1pod_1_1tuple.html">tuple</a>&lt; Ts... &gt; &amp;rhs) noexcept</td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Implementation of POD-compatible tuple, pair and array bindings. </p>
<dl class="section copyright"><dt>Copyright</dt><dd>Copyright 2025 JeongHan-Bae &lt;mastropseudo@gmail.com&gt; <br  />
 Licensed under the Apache License, Version 2.0 (the "License"); <br  />
 you may not use this file except in compliance with the License.<br  />
 You may obtain a copy of the License at<br  />
 <br  />
 <a href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a><br  />
 <br  />
 Unless required by applicable law or agreed to in writing, software<br  />
 distributed under the License is distributed on an "AS IS" BASIS,<br  />
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.<br  />
 See the License for the specific language governing permissions and<br  />
 limitations under the License.<br  />
 <br  />
 Full license: <a href="https://github.com/JeongHan-Bae/JH-Toolkit?tab=Apache-2.0-1-ov-file#readme">GitHub</a></dd></dl>
<p>This header defines <code><a class="el" href="structjh_1_1pod_1_1tuple.html" title="POD-compatible tuple type supporting structured bindings and tuple-like utilities.">jh::pod::tuple&lt;Ts...&gt;</a></code> and its interoperability with <code>std::tuple_size</code> and <code>std::tuple_element</code>. It also provides <code>jh::pod::get</code> overloads for <code>tuple</code>, <code>pair</code>, and <code>array</code> so that they can participate in structured bindings and tuple-like generic programming. </p>
<p>The implementation is based on recursive aggregate composition: every element is stored inside a trivial wrapper <code>tuple_field&lt;I, T&gt;</code>, and each layer of <code>tuple_impl</code> provides one field and a sublayer for the rest. This ensures that the resulting type remains a true POD while supporting element-wise access. </p>
<h3>Design Philosophy &amp; Principles</h3>
<p>The <code><a class="el" href="structjh_1_1pod_1_1tuple.html" title="POD-compatible tuple type supporting structured bindings and tuple-like utilities.">jh::pod::tuple</a></code> in version <b>1.3.4</b> and later is a <b>true POD-based tuple</b>, replacing the transitional implementation used between 1.3.0-1.3.3.</p>
<p>It achieves <b>std::tuple-like behavior</b> — supporting <code>make_tuple</code>, <code>get&lt;&gt;</code>, packing, and unpacking — through <b>composition instead of inheritance</b>. Each element is recursively composed inside a <code>tuple_field&lt;I, T&gt;</code> wrapper, ensuring complete triviality and standard layout. </p>
<p>Because every layer is a deducible aggregate, the resulting <code>tuple</code> is a <b>pure POD type</b>. Optimizers can often treat <code>get&lt;I&gt;(tuple)</code> as a direct <b>offset-based access</b> into a contiguous memory block. In effect, the memory layout of <code><a class="el" href="structjh_1_1pod_1_1tuple.html" title="POD-compatible tuple type supporting structured bindings and tuple-like utilities.">jh::pod::tuple</a></code> is equivalent to a manually defined POD struct with unnamed, ordered fields. </p>
<p>Note that this version uses <b>ADL-based</b> access: <code>get&lt;I&gt;(tuple)</code> rather than <code>tuple.get&lt;I&gt;()</code>. </p>
<h4>Value and Reference Unpacking</h4>
<ul>
<li>
When unpacked as <code>auto</code> or <code>const auto&amp;</code>, elements are accessed <b>by value</b>. This design prevents unsafe aliasing; <code>const_cast</code> tricks cannot modify internal data. </li>
<li>
When unpacked as <code>auto&amp;</code>, elements are accessed <b>by reference</b> and can be safely modified. </li>
</ul>
<p>These semantics provide safe and predictable structured bindings fully aligned with standard tuple-like behavior while maintaining strict POD guarantees. </p>
<h4>Example</h4>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="pod.html">jh/pod</a>&gt;</span></div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacejh_1_1pod.html">jh::pod</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="keyword">auto</span> t = <a class="code hl_function" href="namespacejh_1_1pod.html#a9feeff694ec7515b0c23c78aa7ada0f4">make_tuple</a>(7, 3.14f);</div>
<div class="line">    std::cout &lt;&lt; t &lt;&lt; std::endl;     <span class="comment">// prints: (7, 3.14)</span></div>
<div class="line">}</div>
<div class="ttc" id="anamespacejh_1_1pod_html"><div class="ttname"><a href="namespacejh_1_1pod.html">jh::pod</a></div><div class="ttdef"><b>Definition</b> array.h:30</div></div>
<div class="ttc" id="anamespacejh_1_1pod_html_a9feeff694ec7515b0c23c78aa7ada0f4"><div class="ttname"><a href="namespacejh_1_1pod.html#a9feeff694ec7515b0c23c78aa7ada0f4">jh::pod::make_tuple</a></div><div class="ttdeci">constexpr auto make_tuple(Ts &amp;&amp;... args) noexcept</div><div class="ttdoc">Constructs a POD-compatible tuple from given arguments.</div><div class="ttdef"><b>Definition</b> tuple.h:301</div></div>
<div class="ttc" id="apod_html"><div class="ttname"><a href="pod.html">pod</a></div><div class="ttdoc">Forward-aggregator header for jh::pod — the Plain-Old-Data utilities.</div></div>
</div><!-- fragment --><h4>Important Notes on Initialization</h4>
<p>Clang (C++20 and later) fully supports direct aggregate initialization: </p><div class="fragment"><div class="line"><a class="code hl_struct" href="structjh_1_1pod_1_1tuple.html">jh::pod::tuple&lt;int, float&gt;</a> t{7, 3.14f}; <span class="comment">// valid in Clang</span></div>
<div class="ttc" id="astructjh_1_1pod_1_1tuple_html"><div class="ttname"><a href="structjh_1_1pod_1_1tuple.html">jh::pod::tuple</a></div><div class="ttdoc">POD-compatible tuple type supporting structured bindings and tuple-like utilities.</div><div class="ttdef"><b>Definition</b> tuple.h:198</div></div>
</div><!-- fragment --><p> However, GCC may reject the same form with an error such as "too many initializers". This is due to stricter handling of aggregate inheritance.</p>
<dl class="section warning"><dt>Warning</dt><dd>For GCC (especially ≤ 13), prefer one of the following forms: <div class="fragment"><div class="line"><span class="comment">// Explicit nested braces</span></div>
<div class="line"><a class="code hl_struct" href="structjh_1_1pod_1_1tuple.html">jh::pod::tuple&lt;int, float&gt;</a> t{{ {7}, {{3.14f}, {}} }};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// or, recommended portable helper</span></div>
<div class="line"><span class="keyword">auto</span> t = <a class="code hl_function" href="namespacejh_1_1pod.html#a9feeff694ec7515b0c23c78aa7ada0f4">jh::pod::make_tuple</a>(7, 3.14f);</div>
</div><!-- fragment --></dd></dl>
<dl class="section note"><dt>Note</dt><dd>The output operator (<code>operator&lt;&lt;</code>) for <code>tuple</code>, <code>pair</code> and <code>array</code> is provided in <code>&lt;<a class="el" href="stringify_8h.html" title="Stream output adapters (operator&lt;&lt;) for POD containers and utilities.">jh/pods/stringify.h</a>&gt;</code>. After including it, all these POD containers can be directly printed using <code>std::ostream</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structjh_1_1pod_1_1pair.html" title="POD-compatible aggregate of two values, equivalent in layout to a plain struct.">jh::pod::pair</a> </dd>
<dd>
<a class="el" href="structjh_1_1pod_1_1array.html" title="POD-compatible fixed-size array, similar in shape to std::array, but simpler and fully POD.">jh::pod::array</a> </dd></dl>
</div></div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
</div> <!-- top -->
<hr class="footer"/>
<div class="footer">
    <img class="footer-logo" src="Ojing.svg" alt="Ojing"/>
    <div class="footer-text">
        JH-Toolkit v1.4.0 · Generated by Doxygen
    </div>
    <div class="footer-note">
        We primarily support embedded documentation views in IDEs (classic CLion).
        To ensure compatibility with embedded rendering, some example code in this
        documentation intentionally contains HTML entities.
        In certain cases, Doxygen does not unescape these entities correctly.
        This is a known limitation and currently has no workaround.
    </div>
</div>
</body>
</html>
