<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.16.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>JH-Toolkit: jh::conc::occ_box&lt; T &gt; Class Template Reference</title>
<link rel="icon" href="Jindallae.svg" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="Oree.svg"/></td>
  <td id="projectalign">
   <div id="projectname">JH-Toolkit<span id="projectnumber">&#160;v1.4.0</span>
   </div>
   <div id="projectbrief">An engineering-oriented C++20 toolkit with duck-typed concepts, static design, async coroutines, and semantic containers — header-only, RTTI-free, and concurrency-friendly.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.16.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('classjh_1_1conc_1_1occ__box.html','','classjh_1_1conc_1_1occ__box-members'); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">jh::conc::occ_box&lt; T &gt; Class Template Reference<span class="mlabels"><span class="mlabel final">final</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>Generic container providing <b>Optimistic Concurrency Control (OCC)</b>.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="">jh/concurrent/occ_box.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-types" class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a576058650714c30e99a2c2ab74fe6bdf" id="r_a576058650714c30e99a2c2ab74fe6bdf"><td class="memItemLeft"><a id="a576058650714c30e99a2c2ab74fe6bdf" name="a576058650714c30e99a2c2ab74fe6bdf"></a>
using&#160;</td><td class="memItemRight"><b>value_type</b> = T</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1968df0ad7b31725dcc7883f07db2095" id="r_a1968df0ad7b31725dcc7883f07db2095"><td class="memItemLeft"><a id="a1968df0ad7b31725dcc7883f07db2095" name="a1968df0ad7b31725dcc7883f07db2095"></a>
&#160;</td><td class="memItemRight"><b>occ_box</b> (const occ_box &amp;other) noexcept</td></tr>
<tr class="memdesc:a1968df0ad7b31725dcc7883f07db2095"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor: manually resets flag_ to false, cannot use =default. <br /></td></tr>
<tr class="memitem:a0aa1917136da6e4136eae7647e9e57fe" id="r_a0aa1917136da6e4136eae7647e9e57fe"><td class="memItemLeft"><a id="a0aa1917136da6e4136eae7647e9e57fe" name="a0aa1917136da6e4136eae7647e9e57fe"></a>
<a class="el" href="#a1968df0ad7b31725dcc7883f07db2095">occ_box</a> &amp;&#160;</td><td class="memItemRight"><b>operator=</b> (const <a class="el" href="#a1968df0ad7b31725dcc7883f07db2095">occ_box</a> &amp;other) noexcept</td></tr>
<tr class="memdesc:a0aa1917136da6e4136eae7647e9e57fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment: manually resets flag_ to false, cannot use =default. <br /></td></tr>
<tr class="memitem:a5da39294f0dd158b7ab581646237751a" id="r_a5da39294f0dd158b7ab581646237751a"><td class="memItemLeft"><a id="a5da39294f0dd158b7ab581646237751a" name="a5da39294f0dd158b7ab581646237751a"></a>
&#160;</td><td class="memItemRight"><b>occ_box</b> (occ_box &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:a5da39294f0dd158b7ab581646237751a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor: transfers state but resets flag_ to false, cannot use =default. <br /></td></tr>
<tr class="memitem:a7e57004c201a8b82c78355269efb0af4" id="r_a7e57004c201a8b82c78355269efb0af4"><td class="memItemLeft"><a id="a7e57004c201a8b82c78355269efb0af4" name="a7e57004c201a8b82c78355269efb0af4"></a>
<a class="el" href="#a1968df0ad7b31725dcc7883f07db2095">occ_box</a> &amp;&#160;</td><td class="memItemRight"><b>operator=</b> (<a class="el" href="#a1968df0ad7b31725dcc7883f07db2095">occ_box</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:a7e57004c201a8b82c78355269efb0af4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment: transfers state but resets flag_ to false, cannot use =default. <br /></td></tr>
<tr class="memitem:a137a09d2af55e102457f9f896dad040a" id="r_a137a09d2af55e102457f9f896dad040a"><td class="memItemLeft">&#160;</td><td class="memItemRight"><a class="el" href="#a137a09d2af55e102457f9f896dad040a">occ_box</a> (std::shared_ptr&lt; T &gt; ptr)</td></tr>
<tr class="memdesc:a137a09d2af55e102457f9f896dad040a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new <a class="el" href="classjh_1_1conc_1_1occ__box.html" title="Generic container providing Optimistic Concurrency Control (OCC).">occ_box</a> from an existing shared_ptr&lt;T&gt;.  <br /></td></tr>
<tr class="memitem:a89bb267b2407f5646f7c1de77acc0fdb" id="r_a89bb267b2407f5646f7c1de77acc0fdb"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a89bb267b2407f5646f7c1de77acc0fdb template"><td class="memItemLeft">&#160;</td><td class="memItemRight"><a class="el" href="#a89bb267b2407f5646f7c1de77acc0fdb">occ_box</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a89bb267b2407f5646f7c1de77acc0fdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new <a class="el" href="classjh_1_1conc_1_1occ__box.html" title="Generic container providing Optimistic Concurrency Control (OCC).">occ_box</a> by forwarding arguments to T.  <br /></td></tr>
<tr class="memitem:a9ab312016bedb9e360d9daf98bb2aa35" id="r_a9ab312016bedb9e360d9daf98bb2aa35"><td class="memTemplParams" colspan="2">template&lt;typename F, typename... Args&gt; </td></tr>
<tr class="memitem:a9ab312016bedb9e360d9daf98bb2aa35 template"><td class="memItemLeft">auto&#160;</td><td class="memItemRight"><a class="el" href="#a9ab312016bedb9e360d9daf98bb2aa35">read</a> (F &amp;&amp;f, Args &amp;&amp;... args) const</td></tr>
<tr class="memdesc:a9ab312016bedb9e360d9daf98bb2aa35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocking read with optimistic validation.  <br /></td></tr>
<tr class="memitem:a324d20b30e99a33fb0062f38027fdb51" id="r_a324d20b30e99a33fb0062f38027fdb51"><td class="memTemplParams" colspan="2">template&lt;typename F, typename... Args&gt; </td></tr>
<tr class="memitem:a324d20b30e99a33fb0062f38027fdb51 template"><td class="memItemLeft">auto&#160;</td><td class="memItemRight"><a class="el" href="#a324d20b30e99a33fb0062f38027fdb51">try_read</a> (F &amp;&amp;f, std::uint16_t retries=1, Args &amp;&amp;... args) const -&gt; std::optional&lt; std::invoke_result_t&lt; F, const T &amp;, Args... &gt; &gt;</td></tr>
<tr class="memdesc:a324d20b30e99a33fb0062f38027fdb51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-blocking read with limited retries.  <br /></td></tr>
<tr class="memitem:ab49f10f2e86d56c68ad1791db15f0089" id="r_ab49f10f2e86d56c68ad1791db15f0089"><td class="memTemplParams" colspan="2">template&lt;typename F, typename... Args&gt; </td></tr>
<tr class="memitem:ab49f10f2e86d56c68ad1791db15f0089 template"><td class="memItemLeft">void&#160;</td><td class="memItemRight"><a class="el" href="#ab49f10f2e86d56c68ad1791db15f0089">write</a> (F &amp;&amp;f, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ab49f10f2e86d56c68ad1791db15f0089"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocking write with optimistic commit-replace semantics.  <br /></td></tr>
<tr class="memitem:ad8d392e5c26e1a940ca4ed692a4b7f9b" id="r_ad8d392e5c26e1a940ca4ed692a4b7f9b"><td class="memTemplParams" colspan="2">template&lt;typename F, typename... Args&gt; </td></tr>
<tr class="memitem:ad8d392e5c26e1a940ca4ed692a4b7f9b template"><td class="memItemLeft">bool&#160;</td><td class="memItemRight"><a class="el" href="#ad8d392e5c26e1a940ca4ed692a4b7f9b">try_write</a> (F &amp;&amp;f, std::uint16_t retries=1, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ad8d392e5c26e1a940ca4ed692a4b7f9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-blocking write with limited retries.  <br /></td></tr>
<tr class="memitem:a85f7a4099f93460b39fb7f2685ee0dd9" id="r_a85f7a4099f93460b39fb7f2685ee0dd9"><td class="memTemplParams" colspan="2">template&lt;typename F, typename... Args&gt; </td></tr>
<tr class="memitem:a85f7a4099f93460b39fb7f2685ee0dd9 template"><td class="memItemLeft">void&#160;</td><td class="memItemRight"><a class="el" href="#a85f7a4099f93460b39fb7f2685ee0dd9">write_ptr</a> (F &amp;&amp;f, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a85f7a4099f93460b39fb7f2685ee0dd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocking write using pointer replacement.  <br /></td></tr>
<tr class="memitem:a97188a596609a027b9f497fb196de220" id="r_a97188a596609a027b9f497fb196de220"><td class="memTemplParams" colspan="2">template&lt;typename F, typename... Args&gt; </td></tr>
<tr class="memitem:a97188a596609a027b9f497fb196de220 template"><td class="memItemLeft">bool&#160;</td><td class="memItemRight"><a class="el" href="#a97188a596609a027b9f497fb196de220">try_write_ptr</a> (F &amp;&amp;f, std::uint16_t retries=1, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a97188a596609a027b9f497fb196de220"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-blocking pointer-based write with limited retries.  <br /></td></tr>
<tr class="memitem:a1012c88f376c403fb84f6d3ef2e1f2f6" id="r_a1012c88f376c403fb84f6d3ef2e1f2f6"><td class="memItemLeft">std::uint64_t&#160;</td><td class="memItemRight"><a class="el" href="#a1012c88f376c403fb84f6d3ef2e1f2f6">get_version</a> () const noexcept</td></tr>
<tr class="memdesc:a1012c88f376c403fb84f6d3ef2e1f2f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current version counter of the box.  <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename T&gt;<br />
requires (std::is_copy_constructible_v&lt;T&gt; &amp;&amp; std::is_move_constructible_v&lt;T&gt;)<br />
class jh::conc::occ_box&lt; T &gt;</div><p>Generic container providing <b>Optimistic Concurrency Control (OCC)</b>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Value type, must be copy- and move-constructible.</td></tr>
  </table>
  </dd>
</dl>
<h4>Semantics</h4>
<ul>
<li>
Encapsulates a value of type <code>T</code> with atomic versioned state. </li>
<li>
Reads are wait-free: they either succeed with a consistent snapshot or retry internally. </li>
<li>
Writes are commit-replace: each update creates a fresh state and replaces atomically via CAS. </li>
<li>
No reader ever observes a partially written value. </li>
</ul>
<h4>Retry model</h4>
<ul>
<li>
All <code>try_*()</code> APIs attempt once outside the loop, then retry up to N-1 times. </li>
<li>
<code>retries == 0</code> is equivalent to one attempt. </li>
<li>
Backoff and jitter strategies can be layered on top (see examples). </li>
</ul>
<dl class="section note"><dt>Note</dt><dd>When <code>JH_OCC_ENABLE_MULTI_COMMIT == 1</code> (default), boxes under <code><a class="el" href="namespacejh_1_1conc.html#aa02474715e5cc5c411005fdf6ad06071" title="Apply functions to multiple occ_boxes atomically.">apply_to()</a></code> are given priority over single writes and reads, ensuring that multi-box transactions cannot be broken by concurrent commits. </dd></dl>
</div><a name="doc-constructors" id="doc-constructors"></a><h2 id="header-doc-constructors" class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a137a09d2af55e102457f9f896dad040a" name="a137a09d2af55e102457f9f896dad040a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a137a09d2af55e102457f9f896dad040a">&#9670;&#160;</a></span>occ_box() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classjh_1_1conc_1_1occ__box.html">jh::conc::occ_box</a>&lt; T &gt;::occ_box </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; T &gt;</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel explicit">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a new <a class="el" href="classjh_1_1conc_1_1occ__box.html" title="Generic container providing Optimistic Concurrency Control (OCC).">occ_box</a> from an existing shared_ptr&lt;T&gt;. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Shared pointer to an already-constructed T.</td></tr>
  </table>
  </dd>
</dl>
<p>Takes ownership by wrapping it into the initial state with version = 0. </p>

</div>
</div>
<a id="a89bb267b2407f5646f7c1de77acc0fdb" name="a89bb267b2407f5646f7c1de77acc0fdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89bb267b2407f5646f7c1de77acc0fdb">&#9670;&#160;</a></span>occ_box() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classjh_1_1conc_1_1occ__box.html">jh::conc::occ_box</a>&lt; T &gt;::occ_box </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel explicit">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a new <a class="el" href="classjh_1_1conc_1_1occ__box.html" title="Generic container providing Optimistic Concurrency Control (OCC).">occ_box</a> by forwarding arguments to T. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Args</td><td>Argument types for T's constructor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>Arguments perfectly forwarded to T's constructor.</td></tr>
  </table>
  </dd>
</dl>
<p>Initializes the internal state with version = 0 and a freshly constructed <code>std::shared_ptr&lt;T&gt;</code>. </p>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="a1012c88f376c403fb84f6d3ef2e1f2f6" name="a1012c88f376c403fb84f6d3ef2e1f2f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1012c88f376c403fb84f6d3ef2e1f2f6">&#9670;&#160;</a></span>get_version()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::uint64_t <a class="el" href="classjh_1_1conc_1_1occ__box.html">jh::conc::occ_box</a>&lt; T &gt;::get_version </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the current version counter of the box. </p>
<dl class="section return"><dt>Returns</dt><dd>The version number associated with the current state.</dd></dl>
<h4>Semantics</h4>
<ul>
<li>
Each successful commit increments the version counter. </li>
<li>
The counter is of type <code>std::uint64_t</code> and may wrap around on overflow. </li>
<li>
To detect change, compare versions with <code>!=</code> rather than ordering (<code>&gt;</code>/<code>&lt;</code>). </li>
<li>
The version counter advances exactly once per successful commit, with no data races or partial state exposure. </li>
</ul>

</div>
</div>
<a id="a9ab312016bedb9e360d9daf98bb2aa35" name="a9ab312016bedb9e360d9daf98bb2aa35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ab312016bedb9e360d9daf98bb2aa35">&#9670;&#160;</a></span>read()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename F, typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classjh_1_1conc_1_1occ__box.html">jh::conc::occ_box</a>&lt; T &gt;::read </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Blocking read with optimistic validation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>Callable type, must accept <code>const T&amp;</code> and optional extra args. </td></tr>
    <tr><td class="paramname">Args</td><td>Additional argument types.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>User-provided callable, invoked with the current value. </td></tr>
    <tr><td class="paramname">args</td><td>Optional extra arguments forwarded to the callable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>R</code>, the value returned by the callable, provided the read passes optimistic validation (snapshot is consistent).</dd></dl>
<h4>Semantics</h4>
<ul>
<li>
Performs a load-invoke-validate sequence under optimistic concurrency. </li>
<li>
If the state changes between two atomic loads, the read retries internally. </li>
<li>
Wait-free for readers: never blocks writers. </li>
</ul>
<h4>Why void is disallowed</h4>
<p>Returning <code>void</code> is forbidden because <code><a class="el" href="#a9ab312016bedb9e360d9daf98bb2aa35" title="Blocking read with optimistic validation.">read()</a></code> must conceptually produce a value from the snapshot. Allowing <code>void</code> would encourage using this API solely for side effects, which violates the read model. </p>
<h4>Permitted side effects</h4>
<p>Minor auxiliary effects (e.g. updating a <code>duration&amp;</code> for backoff logic, or writing to a log) are acceptable, provided they do not alter application state or depend on non-idempotent behavior. </p>
<p>For output purposes, prefer returning a value (e.g. a <code>std::string</code> built from an <code>ostringstream</code>) instead of directly printing inside <code><a class="el" href="#a9ab312016bedb9e360d9daf98bb2aa35" title="Blocking read with optimistic validation.">read()</a></code>. </p>

</div>
</div>
<a id="a324d20b30e99a33fb0062f38027fdb51" name="a324d20b30e99a33fb0062f38027fdb51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a324d20b30e99a33fb0062f38027fdb51">&#9670;&#160;</a></span>try_read()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename F, typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classjh_1_1conc_1_1occ__box.html">jh::conc::occ_box</a>&lt; T &gt;::try_read </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint16_t</td>          <td class="paramname"><span class="paramname"><em>retries</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;) const -&gt; std::optional&lt; std::invoke_result_t&lt; F, const T &amp;, Args... &gt; &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Non-blocking read with limited retries. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>Callable type, must accept <code>const T&amp;</code> and optional extra args. </td></tr>
    <tr><td class="paramname">Args</td><td>Additional argument types.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>User-provided callable, invoked with the current value. </td></tr>
    <tr><td class="paramname">retries</td><td>Maximum number of attempts (0 treated as 1). </td></tr>
    <tr><td class="paramname">args</td><td>Optional extra arguments forwarded to the callable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>std::optional&lt;R&gt;</code>, where <code>R</code> is the callable's return type. Returns <code>std::nullopt</code> if all retries fail validation.</dd></dl>
<h4>Semantics</h4>
<ul>
<li>
Performs optimistic load-invoke-validate like <code><a class="el" href="#a9ab312016bedb9e360d9daf98bb2aa35" title="Blocking read with optimistic validation.">read()</a></code>. </li>
<li>
Unlike <code><a class="el" href="#a9ab312016bedb9e360d9daf98bb2aa35" title="Blocking read with optimistic validation.">read()</a></code>, it gives up after at most <code>retries</code> attempts. </li>
<li>
Retry count <code>0</code> is normalized to one attempt. </li>
</ul>
<h4>Purity rule</h4>
<p>Pure side-effect-only operations are disallowed: this method must conceptually produce a value from the snapshot. Minor auxiliary effects (e.g. backoff instrumentation, logging) are acceptable if they do not alter application state. </p>
<dl class="section note"><dt>Note</dt><dd><code>retries</code> must be explicitly specified if extra <code>args...</code> are provided, since <code>args</code> always follow it in the parameter list.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a9ab312016bedb9e360d9daf98bb2aa35" title="Blocking read with optimistic validation.">read()</a> </dd></dl>

</div>
</div>
<a id="ad8d392e5c26e1a940ca4ed692a4b7f9b" name="ad8d392e5c26e1a940ca4ed692a4b7f9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8d392e5c26e1a940ca4ed692a4b7f9b">&#9670;&#160;</a></span>try_write()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename F, typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classjh_1_1conc_1_1occ__box.html">jh::conc::occ_box</a>&lt; T &gt;::try_write </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint16_t</td>          <td class="paramname"><span class="paramname"><em>retries</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Non-blocking write with limited retries. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>Callable type, must accept <code>T&amp;</code> and optional extra args. </td></tr>
    <tr><td class="paramname">Args</td><td>Additional argument types.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>User-provided callable, applied to a freshly copied value. </td></tr>
    <tr><td class="paramname">retries</td><td>Maximum number of attempts (0 treated as 1). </td></tr>
    <tr><td class="paramname">args</td><td>Optional extra arguments forwarded to the callable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the update is committed successfully, <code>false</code> if all attempts fail due to contention.</dd></dl>
<h4>Semantics</h4>
<ul>
<li>
Each attempt loads the current state, copies the value, applies the user function, and tries to commit via CAS. </li>
<li>
Fails if another writer replaces the state before CAS succeeds. </li>
<li>
Unlike <code><a class="el" href="#ab49f10f2e86d56c68ad1791db15f0089" title="Blocking write with optimistic commit-replace semantics.">write()</a></code>, this method does not spin indefinitely: it retries at most <code>retries</code> times. </li>
</ul>
<h4>Copy semantics</h4>
<p>Each attempt deep-copies the underlying value. If deep copies are undesirable, consider <code><a class="el" href="#a97188a596609a027b9f497fb196de220" title="Non-blocking pointer-based write with limited retries.">try_write_ptr()</a></code> to construct and install a new object directly. </p>
<h4>Usage note</h4>
<p>For retryable operations or performance-sensitive paths, prefer <code><a class="el" href="#ad8d392e5c26e1a940ca4ed692a4b7f9b" title="Non-blocking write with limited retries.">try_write()</a></code> or <code><a class="el" href="#a97188a596609a027b9f497fb196de220" title="Non-blocking pointer-based write with limited retries.">try_write_ptr()</a></code> over their blocking counterparts, since they allow graceful failure handling under contention. </p>
<dl class="section note"><dt>Note</dt><dd><code>retries</code> must be explicitly specified if extra <code>args...</code> are provided, since <code>args</code> always follow it in the parameter list.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ab49f10f2e86d56c68ad1791db15f0089" title="Blocking write with optimistic commit-replace semantics.">write()</a> </dd></dl>

</div>
</div>
<a id="a97188a596609a027b9f497fb196de220" name="a97188a596609a027b9f497fb196de220"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97188a596609a027b9f497fb196de220">&#9670;&#160;</a></span>try_write_ptr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename F, typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classjh_1_1conc_1_1occ__box.html">jh::conc::occ_box</a>&lt; T &gt;::try_write_ptr </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint16_t</td>          <td class="paramname"><span class="paramname"><em>retries</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Non-blocking pointer-based write with limited retries. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>Callable type, must accept <code>const std::shared_ptr&lt;T&gt;&amp;</code> and optional extra args, and return a new <code>std::shared_ptr&lt;T&gt;</code>. </td></tr>
    <tr><td class="paramname">Args</td><td>Additional argument types.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>User-provided callable, invoked with the old shared_ptr. Must return a new <code>shared_ptr</code> holding the replacement object. </td></tr>
    <tr><td class="paramname">retries</td><td>Maximum number of attempts (0 treated as 1). </td></tr>
    <tr><td class="paramname">args</td><td>Optional extra arguments forwarded to the callable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the update is committed successfully, <code>false</code> if all attempts fail due to contention.</dd></dl>
<h4>Semantics</h4>
<ul>
<li>
Similar to <code><a class="el" href="#ad8d392e5c26e1a940ca4ed692a4b7f9b" title="Non-blocking write with limited retries.">try_write()</a></code>, but avoids copying the old object. </li>
<li>
Each attempt calls the user function to produce a fresh object and tries to commit it with CAS. </li>
<li>
Stops after at most <code>retries</code> attempts. </li>
</ul>
<h4>Recommended scenarios</h4>
<ul>
<li>
When replacing large objects where copying is wasteful. </li>
<li>
When constructing a new object directly is cheaper than mutating a copy (e.g. resizing a string or vector before applying logic). </li>
</ul>
<dl class="section note"><dt>Note</dt><dd><code>retries</code> must be explicitly specified if extra <code>args...</code> are provided, since <code>args</code> always follow it in the parameter list.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ad8d392e5c26e1a940ca4ed692a4b7f9b" title="Non-blocking write with limited retries.">try_write()</a>, <a class="el" href="#a85f7a4099f93460b39fb7f2685ee0dd9" title="Blocking write using pointer replacement.">write_ptr()</a> </dd></dl>

</div>
</div>
<a id="ab49f10f2e86d56c68ad1791db15f0089" name="ab49f10f2e86d56c68ad1791db15f0089"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab49f10f2e86d56c68ad1791db15f0089">&#9670;&#160;</a></span>write()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename F, typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classjh_1_1conc_1_1occ__box.html">jh::conc::occ_box</a>&lt; T &gt;::write </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Blocking write with optimistic commit-replace semantics. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>Callable type, must accept <code>T&amp;</code> and optional extra args. </td></tr>
    <tr><td class="paramname">Args</td><td>Additional argument types.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>User-provided callable, applied to a fresh copy of the object. </td></tr>
    <tr><td class="paramname">args</td><td>Optional extra arguments forwarded to the callable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<h4>Semantics</h4>
<ul>
<li>
Performs a load-copy-invoke-CAS loop until commit succeeds. </li>
<li>
Always copies the current object before applying <code>f</code>. </li>
<li>
Guarantees atomic replacement: readers never see a partially written object. </li>
</ul>
<h4>Performance notes</h4>
<ul>
<li>
Safe under high contention: even if writes are very frequent, each commit is strictly atomic and never exposes torn or inconsistent states. </li>
<li>
Excessive use may hurt performance due to repeated deep copies and CAS retries, but correctness and race-freedom are guaranteed. </li>
<li>
Prefer embedding repeated logic inside <code>f</code> rather than invoking <code><a class="el" href="#ab49f10f2e86d56c68ad1791db15f0089" title="Blocking write with optimistic commit-replace semantics.">write()</a></code> repeatedly in a loop. </li>
<li>
If deep copies are undesirable, consider <code><a class="el" href="#a85f7a4099f93460b39fb7f2685ee0dd9" title="Blocking write using pointer replacement.">write_ptr()</a></code> to construct and install a new object directly. </li>
</ul>
<h4>Return semantics</h4>
<p>This method always returns <code>void</code>. The write is guaranteed to complete before returning. It is best suited for critical update paths where completion is mandatory. </p>
<h4>Fairness</h4>
<p>On most POSIX platforms, the scheduler tends to grant forward progress, so livelock is practically avoided. However, applications should not over-rely on this property. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a85f7a4099f93460b39fb7f2685ee0dd9" title="Blocking write using pointer replacement.">write_ptr()</a> </dd></dl>

</div>
</div>
<a id="a85f7a4099f93460b39fb7f2685ee0dd9" name="a85f7a4099f93460b39fb7f2685ee0dd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85f7a4099f93460b39fb7f2685ee0dd9">&#9670;&#160;</a></span>write_ptr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename F, typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classjh_1_1conc_1_1occ__box.html">jh::conc::occ_box</a>&lt; T &gt;::write_ptr </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Blocking write using pointer replacement. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>Callable type, must accept <code>const std::shared_ptr&lt;T&gt;&amp;</code> and optional extra args, and return a new <code>std::shared_ptr&lt;T&gt;</code>. </td></tr>
    <tr><td class="paramname">Args</td><td>Additional argument types.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>User-provided callable, invoked with the old shared_ptr. Must return a new <code>shared_ptr</code> holding the replacement object. </td></tr>
    <tr><td class="paramname">args</td><td>Optional extra arguments forwarded to the callable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<h4>Semantics</h4>
<ul>
<li>
Mechanism is the same as <code><a class="el" href="#ab49f10f2e86d56c68ad1791db15f0089" title="Blocking write with optimistic commit-replace semantics.">write()</a></code>, but avoids deep copies. </li>
<li>
Each attempt invokes the user function to construct a brand-new object and commits it atomically via CAS. </li>
<li>
Retries indefinitely until success. </li>
</ul>
<h4>Recommended scenarios</h4>
<ul>
<li>
When the object contains fields that can be safely discarded (e.g. large buffers or caches you don't need to preserve). </li>
<li>
When the object has resizable members (like <code>std::vector</code> or <code>std::string</code>), and constructing directly at the new size is cheaper than copying and then resizing. </li>
</ul>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ab49f10f2e86d56c68ad1791db15f0089" title="Blocking write with optimistic commit-replace semantics.">write()</a>, <a class="el" href="#a97188a596609a027b9f497fb196de220" title="Non-blocking pointer-based write with limited retries.">try_write_ptr()</a> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/jh/concurrent/<a class="el" href="">occ_box.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
</div> <!-- top -->
<hr class="footer"/>
<div class="footer">
    <img class="footer-logo" src="Ojing.svg" alt="Ojing"/>
    <div class="footer-text">
        JH-Toolkit v1.4.0 · Generated by Doxygen
    </div>
    <div class="footer-note">
        We primarily support embedded documentation views in IDEs (classic CLion).
        To ensure compatibility with embedded rendering, some example code in this
        documentation intentionally contains HTML entities.
        In certain cases, Doxygen does not unescape these entities correctly.
        This is a known limitation and currently has no workaround.
    </div>
</div>
</body>
</html>
