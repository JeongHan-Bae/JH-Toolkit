<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.16.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>JH-Toolkit: jh::pod::string_view Struct Reference</title>
<link rel="icon" href="Jindallae.svg" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="Oree.svg"/></td>
  <td id="projectalign">
   <div id="projectname">JH-Toolkit<span id="projectnumber">&#160;v1.4.0</span>
   </div>
   <div id="projectbrief">An engineering-oriented C++20 toolkit with duck-typed concepts, static design, async coroutines, and semantic containers — header-only, RTTI-free, and concurrency-friendly.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.16.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('structjh_1_1pod_1_1string__view.html','','structjh_1_1pod_1_1string__view-members'); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">jh::pod::string_view Struct Reference<span class="mlabels"><span class="mlabel final">final</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>Read-only string view with POD layout.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="">jh/pods/string_view.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-types" class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:af1df21d706e60e747fdeed6e73bb0a6e" id="r_af1df21d706e60e747fdeed6e73bb0a6e"><td class="memItemLeft"><a id="af1df21d706e60e747fdeed6e73bb0a6e" name="af1df21d706e60e747fdeed6e73bb0a6e"></a>
using&#160;</td><td class="memItemRight"><b>value_type</b> = char</td></tr>
<tr class="memdesc:af1df21d706e60e747fdeed6e73bb0a6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Character type. <br /></td></tr>
<tr class="memitem:a6094cb18101f7a085d23544dd8ba4f65" id="r_a6094cb18101f7a085d23544dd8ba4f65"><td class="memItemLeft"><a id="a6094cb18101f7a085d23544dd8ba4f65" name="a6094cb18101f7a085d23544dd8ba4f65"></a>
using&#160;</td><td class="memItemRight"><b>size_type</b> = std::uint64_t</td></tr>
<tr class="memdesc:a6094cb18101f7a085d23544dd8ba4f65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size type (64-bit). <br /></td></tr>
<tr class="memitem:a73c88307b1ccb3aade168488418a3abb" id="r_a73c88307b1ccb3aade168488418a3abb"><td class="memItemLeft"><a id="a73c88307b1ccb3aade168488418a3abb" name="a73c88307b1ccb3aade168488418a3abb"></a>
using&#160;</td><td class="memItemRight"><b>difference_type</b> = std::ptrdiff_t</td></tr>
<tr class="memdesc:a73c88307b1ccb3aade168488418a3abb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Difference type. <br /></td></tr>
<tr class="memitem:ab8f13cd95860d49c12dc491448222f18" id="r_ab8f13cd95860d49c12dc491448222f18"><td class="memItemLeft"><a id="ab8f13cd95860d49c12dc491448222f18" name="ab8f13cd95860d49c12dc491448222f18"></a>
using&#160;</td><td class="memItemRight"><b>reference</b> = <a class="el" href="#af1df21d706e60e747fdeed6e73bb0a6e">value_type</a> &amp;</td></tr>
<tr class="memdesc:ab8f13cd95860d49c12dc491448222f18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference to character. <br /></td></tr>
<tr class="memitem:ac5c169e6cddfc29d0a4a20d3705b3140" id="r_ac5c169e6cddfc29d0a4a20d3705b3140"><td class="memItemLeft"><a id="ac5c169e6cddfc29d0a4a20d3705b3140" name="ac5c169e6cddfc29d0a4a20d3705b3140"></a>
using&#160;</td><td class="memItemRight"><b>const_reference</b> = const <a class="el" href="#af1df21d706e60e747fdeed6e73bb0a6e">value_type</a> &amp;</td></tr>
<tr class="memdesc:ac5c169e6cddfc29d0a4a20d3705b3140"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const reference to character. <br /></td></tr>
<tr class="memitem:a8b94e5a063624da44b5da679dbf3587a" id="r_a8b94e5a063624da44b5da679dbf3587a"><td class="memItemLeft"><a id="a8b94e5a063624da44b5da679dbf3587a" name="a8b94e5a063624da44b5da679dbf3587a"></a>
using&#160;</td><td class="memItemRight"><b>pointer</b> = <a class="el" href="#af1df21d706e60e747fdeed6e73bb0a6e">value_type</a> *</td></tr>
<tr class="memdesc:a8b94e5a063624da44b5da679dbf3587a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to character. <br /></td></tr>
<tr class="memitem:ac305bbe850297db0dcf49af92cf162d2" id="r_ac305bbe850297db0dcf49af92cf162d2"><td class="memItemLeft"><a id="ac305bbe850297db0dcf49af92cf162d2" name="ac305bbe850297db0dcf49af92cf162d2"></a>
using&#160;</td><td class="memItemRight"><b>const_pointer</b> = const <a class="el" href="#af1df21d706e60e747fdeed6e73bb0a6e">value_type</a> *</td></tr>
<tr class="memdesc:ac305bbe850297db0dcf49af92cf162d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const pointer to character. <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa9d23555fb2a2bd22c82f214765cd008" id="r_aa9d23555fb2a2bd22c82f214765cd008"><td class="memItemLeft"><a id="aa9d23555fb2a2bd22c82f214765cd008" name="aa9d23555fb2a2bd22c82f214765cd008"></a>
constexpr <a class="el" href="#ac5c169e6cddfc29d0a4a20d3705b3140">const_reference</a>&#160;</td><td class="memItemRight"><b>operator[]</b> (const std::uint64_t index) const noexcept</td></tr>
<tr class="memdesc:aa9d23555fb2a2bd22c82f214765cd008"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index access (no bounds checking). <br /></td></tr>
<tr class="memitem:a43c488878e177bd406e64f31283f09b8" id="r_a43c488878e177bd406e64f31283f09b8"><td class="memItemLeft"><a id="a43c488878e177bd406e64f31283f09b8" name="a43c488878e177bd406e64f31283f09b8"></a>
constexpr <a class="el" href="#ac305bbe850297db0dcf49af92cf162d2">const_pointer</a>&#160;</td><td class="memItemRight"><b>begin</b> () const noexcept</td></tr>
<tr class="memdesc:a43c488878e177bd406e64f31283f09b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to the beginning of data. <br /></td></tr>
<tr class="memitem:a6013829a0bbc40b68dcaafe6f8480077" id="r_a6013829a0bbc40b68dcaafe6f8480077"><td class="memItemLeft">constexpr <a class="el" href="#ac305bbe850297db0dcf49af92cf162d2">const_pointer</a>&#160;</td><td class="memItemRight"><a class="el" href="#a6013829a0bbc40b68dcaafe6f8480077">end</a> () const noexcept</td></tr>
<tr class="memdesc:a6013829a0bbc40b68dcaafe6f8480077"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to the end of data (<code>data + len</code>).  <br /></td></tr>
<tr class="memitem:a0989e0e8f944e415a6d95d184379af5b" id="r_a0989e0e8f944e415a6d95d184379af5b"><td class="memItemLeft"><a id="a0989e0e8f944e415a6d95d184379af5b" name="a0989e0e8f944e415a6d95d184379af5b"></a>
constexpr <a class="el" href="#a6094cb18101f7a085d23544dd8ba4f65">size_type</a>&#160;</td><td class="memItemRight"><b>size</b> () const noexcept</td></tr>
<tr class="memdesc:a0989e0e8f944e415a6d95d184379af5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">View length in bytes. <br /></td></tr>
<tr class="memitem:a096428d73c97df991ecf520b7da56d33" id="r_a096428d73c97df991ecf520b7da56d33"><td class="memItemLeft"><a id="a096428d73c97df991ecf520b7da56d33" name="a096428d73c97df991ecf520b7da56d33"></a>
constexpr bool&#160;</td><td class="memItemRight"><b>empty</b> () const noexcept</td></tr>
<tr class="memdesc:a096428d73c97df991ecf520b7da56d33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the view is empty (<code>len == 0</code>). <br /></td></tr>
<tr class="memitem:aaae7bf17195d062b0b48d4aa9a918157" id="r_aaae7bf17195d062b0b48d4aa9a918157"><td class="memItemLeft">constexpr bool&#160;</td><td class="memItemRight"><a class="el" href="#aaae7bf17195d062b0b48d4aa9a918157">operator==</a> (const <a class="el" href="#a2421ae3aa0b3d5f7baa021a2a39edee0">string_view</a> &amp;rhs) const noexcept</td></tr>
<tr class="memdesc:aaae7bf17195d062b0b48d4aa9a918157"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two views for byte-wise equality.  <br /></td></tr>
<tr class="memitem:abad86270cff2bc8bf0008f96ae07a914" id="r_abad86270cff2bc8bf0008f96ae07a914"><td class="memItemLeft">constexpr <a class="el" href="#a2421ae3aa0b3d5f7baa021a2a39edee0">string_view</a>&#160;</td><td class="memItemRight"><a class="el" href="#abad86270cff2bc8bf0008f96ae07a914">sub</a> (const std::uint64_t offset, const std::uint64_t length=0) const noexcept</td></tr>
<tr class="memdesc:abad86270cff2bc8bf0008f96ae07a914"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a substring starting at <code>offset</code>, for <code>length</code> bytes.  <br /></td></tr>
<tr class="memitem:a6de4d05806a5854cad1f3d6bd0c3ec78" id="r_a6de4d05806a5854cad1f3d6bd0c3ec78"><td class="memItemLeft">constexpr int&#160;</td><td class="memItemRight"><a class="el" href="#a6de4d05806a5854cad1f3d6bd0c3ec78">compare</a> (const <a class="el" href="#a2421ae3aa0b3d5f7baa021a2a39edee0">string_view</a> &amp;rhs) const noexcept</td></tr>
<tr class="memdesc:a6de4d05806a5854cad1f3d6bd0c3ec78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lexical comparison (similar to <code>strcmp()</code>).  <br /></td></tr>
<tr class="memitem:aa40dbe134dbbbdd7c5c7de02a015416b" id="r_aa40dbe134dbbbdd7c5c7de02a015416b"><td class="memItemLeft"><a id="aa40dbe134dbbbdd7c5c7de02a015416b" name="aa40dbe134dbbbdd7c5c7de02a015416b"></a>
constexpr bool&#160;</td><td class="memItemRight"><b>starts_with</b> (const <a class="el" href="#a2421ae3aa0b3d5f7baa021a2a39edee0">string_view</a> &amp;prefix) const noexcept</td></tr>
<tr class="memdesc:aa40dbe134dbbbdd7c5c7de02a015416b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether this view starts with the given <code>prefix</code>. <br /></td></tr>
<tr class="memitem:ad005294ef3b5ac91ff7e4d86490c83aa" id="r_ad005294ef3b5ac91ff7e4d86490c83aa"><td class="memItemLeft"><a id="ad005294ef3b5ac91ff7e4d86490c83aa" name="ad005294ef3b5ac91ff7e4d86490c83aa"></a>
constexpr bool&#160;</td><td class="memItemRight"><b>ends_with</b> (const <a class="el" href="#a2421ae3aa0b3d5f7baa021a2a39edee0">string_view</a> &amp;suffix) const noexcept</td></tr>
<tr class="memdesc:ad005294ef3b5ac91ff7e4d86490c83aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether this view ends with the given <code>suffix</code>. <br /></td></tr>
<tr class="memitem:a8d1c2b9310d9c3428e016cad211e2d5f" id="r_a8d1c2b9310d9c3428e016cad211e2d5f"><td class="memItemLeft">constexpr std::uint64_t&#160;</td><td class="memItemRight"><a class="el" href="#a8d1c2b9310d9c3428e016cad211e2d5f">find</a> (const char ch) const noexcept</td></tr>
<tr class="memdesc:a8d1c2b9310d9c3428e016cad211e2d5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the first occurrence of a character.  <br /></td></tr>
<tr class="memitem:a4639b25ffee452db15d155c8b57800da" id="r_a4639b25ffee452db15d155c8b57800da"><td class="memItemLeft">constexpr std::uint64_t&#160;</td><td class="memItemRight"><a class="el" href="#a4639b25ffee452db15d155c8b57800da">hash</a> (<a class="el" href="namespacejh_1_1meta.html#a7ea475ab0421edb9edb93189740da707">jh::meta::c_hash</a> hash_method=<a class="el" href="namespacejh_1_1meta.html#a7ea475ab0421edb9edb93189740da707aca0466d3124e039f7442eccafc2fd891">jh::meta::c_hash::fnv1a64</a>) const noexcept</td></tr>
<tr class="memdesc:a4639b25ffee452db15d155c8b57800da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash the view content using a selectable non-cryptographic algorithm.  <br /></td></tr>
<tr class="memitem:ad14c970dc95604200da187860bff5e39" id="r_ad14c970dc95604200da187860bff5e39"><td class="memItemLeft">void&#160;</td><td class="memItemRight"><a class="el" href="#ad14c970dc95604200da187860bff5e39">copy_to</a> (char *buffer, const std::uint64_t max_len) const noexcept</td></tr>
<tr class="memdesc:ad14c970dc95604200da187860bff5e39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the view into a C-style null-terminated buffer.  <br /></td></tr>
<tr class="memitem:a2421ae3aa0b3d5f7baa021a2a39edee0" id="r_a2421ae3aa0b3d5f7baa021a2a39edee0"><td class="memItemLeft">constexpr&#160;</td><td class="memItemRight"><a class="el" href="#a2421ae3aa0b3d5f7baa021a2a39edee0">operator std::string_view</a> () const noexcept</td></tr>
<tr class="memdesc:a2421ae3aa0b3d5f7baa021a2a39edee0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicit conversion to <code>std::string_view</code>.  <br /></td></tr>
<tr class="memitem:a209ab16ddb2543cf437a00b023e9c61b" id="r_a209ab16ddb2543cf437a00b023e9c61b"><td class="memItemLeft">constexpr std::string_view&#160;</td><td class="memItemRight"><a class="el" href="#a209ab16ddb2543cf437a00b023e9c61b">to_std</a> () const noexcept</td></tr>
<tr class="memdesc:a209ab16ddb2543cf437a00b023e9c61b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Named conversion helper to obtain a <code>std::string_view</code>.  <br /></td></tr>
<tr class="memitem:aa973df23961f6da1a9c8d53a0f707a10" id="r_aa973df23961f6da1a9c8d53a0f707a10"><td class="memItemLeft">constexpr std::strong_ordering&#160;</td><td class="memItemRight"><a class="el" href="#aa973df23961f6da1a9c8d53a0f707a10">operator&lt;=&gt;</a> (const <a class="el" href="#a2421ae3aa0b3d5f7baa021a2a39edee0">string_view</a> &amp;rhs) const noexcept</td></tr>
<tr class="memdesc:aa973df23961f6da1a9c8d53a0f707a10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Three-way comparison operator (spaceship operator).  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-static-methods" class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ada66e4d9f29726311cd96d79bc38d42e" id="r_ada66e4d9f29726311cd96d79bc38d42e"><td class="memTemplParams" colspan="2">template&lt;std::size_t N&gt; </td></tr>
<tr class="memitem:ada66e4d9f29726311cd96d79bc38d42e template"><td class="memItemLeft">static constexpr <a class="el" href="#a2421ae3aa0b3d5f7baa021a2a39edee0">string_view</a>&#160;</td><td class="memItemRight"><a class="el" href="#ada66e4d9f29726311cd96d79bc38d42e">from_literal</a> (const char(&amp;lit)[N]) noexcept</td></tr>
<tr class="memdesc:ada66e4d9f29726311cd96d79bc38d42e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <code><a class="el" href="structjh_1_1pod_1_1string__view.html" title="Read-only string view with POD layout.">string_view</a></code> from a string literal.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-attribs" class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ab8063f15c0fe2562058a5925d7cb8516" id="r_ab8063f15c0fe2562058a5925d7cb8516"><td class="memItemLeft"><a id="ab8063f15c0fe2562058a5925d7cb8516" name="ab8063f15c0fe2562058a5925d7cb8516"></a>
const char *&#160;</td><td class="memItemRight"><b>data</b></td></tr>
<tr class="memdesc:ab8063f15c0fe2562058a5925d7cb8516"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to string data (not null-terminated). <br /></td></tr>
<tr class="memitem:ab8eab6cfec0eda4d32f8fbabfcc49eac" id="r_ab8eab6cfec0eda4d32f8fbabfcc49eac"><td class="memItemLeft"><a id="ab8eab6cfec0eda4d32f8fbabfcc49eac" name="ab8eab6cfec0eda4d32f8fbabfcc49eac"></a>
std::uint64_t&#160;</td><td class="memItemRight"><b>len</b></td></tr>
<tr class="memdesc:ab8eab6cfec0eda4d32f8fbabfcc49eac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of valid bytes in the view. <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Read-only string view with POD layout. </p>
<p>Holds a raw pointer and a length (not null-terminated). Provides slicing, comparison, and constexpr hashing, all while remaining fully POD (<code>const char* + uint64_t</code>).</p>
<h4>Key differences from std::string_view:</h4>
<ul>
<li>
Always POD layout (aggregate struct, no constructors) </li>
<li>
<code>operator==</code> performs <b>deep comparison</b> (memcmp) </li>
<li>
<code><a class="el" href="#a4639b25ffee452db15d155c8b57800da" title="Hash the view content using a selectable non-cryptographic algorithm.">hash()</a></code> is <b>constexpr-safe</b> and usable in consteval contexts </li>
<li>
No exceptions, no allocator awareness </li>
</ul>
<h4>Initialization semantics:</h4>
<ul>
<li>
This type is an aggregate; initialization normally requires both a <code>const char*</code> and an explicit length. </li>
<li>
If only a <code>const char*</code> is provided (without <code>len</code>), then <code>len</code> defaults to <code>0</code>, producing an empty view. </li>
<li>
A special helper <code><a class="el" href="#ada66e4d9f29726311cd96d79bc38d42e" title="Construct a string_view from a string literal.">from_literal()</a></code> exists for string literals: it deduces the array size at compile time and creates a view of length <code>N-1</code> (excluding the null terminator). </li>
<li>
At runtime, you must always provide both pointer and size explicitly — this class never computes length automatically. </li>
</ul>
<h4>Usage Model:</h4>
<ul>
<li>
Typically used as a safe view for <code><a class="el" href="classjh_1_1immutable__str.html" title="Immutable string with optional automatic trimming and thread-safe hash caching.">immutable_str</a></code> </li>
<li>
Can represent string literals or arena-allocated strings </li>
<li>
Compile-time hashing supports <code><a class="el" href="structjh_1_1meta_1_1t__str.html" title="Compile-time string wrapper for use as a non-type template parameter (NTTP).">jh::meta::t_str</a></code> </li>
</ul>
</div><a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="a6de4d05806a5854cad1f3d6bd0c3ec78" name="a6de4d05806a5854cad1f3d6bd0c3ec78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6de4d05806a5854cad1f3d6bd0c3ec78">&#9670;&#160;</a></span>compare()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int jh::pod::string_view::compare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a2421ae3aa0b3d5f7baa021a2a39edee0">string_view</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lexical comparison (similar to <code>strcmp()</code>). </p>
<dl class="section return"><dt>Returns</dt><dd><code>&lt;0</code> if <span class="tt">this &lt; rhs</span>, <code>0</code> if <span class="tt">equal</span>, <code>&gt;0</code> if <span class="tt">this &gt; rhs</span>. </dd></dl>

</div>
</div>
<a id="ad14c970dc95604200da187860bff5e39" name="ad14c970dc95604200da187860bff5e39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad14c970dc95604200da187860bff5e39">&#9670;&#160;</a></span>copy_to()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void jh::pod::string_view::copy_to </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::uint64_t</td>          <td class="paramname"><span class="paramname"><em>max_len</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy the view into a C-style null-terminated buffer. </p>
<dl class="section warning"><dt>Warning</dt><dd>This is not POD-safe. Intended for debugging or interop only.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>Output character buffer. </td></tr>
    <tr><td class="paramname">max_len</td><td>Maximum bytes to write (including null terminator). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6013829a0bbc40b68dcaafe6f8480077" name="a6013829a0bbc40b68dcaafe6f8480077"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6013829a0bbc40b68dcaafe6f8480077">&#9670;&#160;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ac305bbe850297db0dcf49af92cf162d2">const_pointer</a> jh::pod::string_view::end </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pointer to the end of data (<code>data + len</code>). </p>
<dl class="section note"><dt>Note</dt><dd>This is not null-terminated. Use <code>len</code> for bounds. </dd></dl>

</div>
</div>
<a id="a8d1c2b9310d9c3428e016cad211e2d5f" name="a8d1c2b9310d9c3428e016cad211e2d5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d1c2b9310d9c3428e016cad211e2d5f">&#9670;&#160;</a></span>find()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::uint64_t jh::pod::string_view::find </td>
          <td>(</td>
          <td class="paramtype">const char</td>          <td class="paramname"><span class="paramname"><em>ch</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index of the first occurrence of a character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>Target character to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Offset index if found, or <code>-1</code> (as <code>uint64_t</code>) if not found. </dd></dl>

</div>
</div>
<a id="ada66e4d9f29726311cd96d79bc38d42e" name="ada66e4d9f29726311cd96d79bc38d42e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada66e4d9f29726311cd96d79bc38d42e">&#9670;&#160;</a></span>from_literal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="#a2421ae3aa0b3d5f7baa021a2a39edee0">string_view</a> jh::pod::string_view::from_literal </td>
          <td>(</td>
          <td class="paramtype">const char(&amp;)</td>          <td class="paramname"><span class="paramname"><em>lit</em></span>[N]</td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a <code><a class="el" href="structjh_1_1pod_1_1string__view.html" title="Read-only string view with POD layout.">string_view</a></code> from a string literal. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>Size of the string literal including the null terminator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lit</td><td>Reference to the string literal (must be null-terminated). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="structjh_1_1pod_1_1string__view.html" title="Read-only string view with POD layout.">string_view</a></code> pointing to the literal characters with <code><a class="el" href="#a0989e0e8f944e415a6d95d184379af5b" title="View length in bytes.">size()</a> == N - 1</code>.</dd></dl>
<h4>Semantics:</h4>
<ul>
<li>
<code>N</code> always counts the null terminator. </li>
<li>
The resulting view excludes the null terminator, so length is <code>N - 1</code>. </li>
<li>
Empty string literal <code>""</code> is valid (<code>N == 1</code>, view <span class="tt">length = 0</span>). </li>
</ul>
<dl class="section note"><dt>Note</dt><dd>This overload guarantees constexpr evaluation and can be used in <code>consteval</code> contexts. </dd></dl>

</div>
</div>
<a id="a4639b25ffee452db15d155c8b57800da" name="a4639b25ffee452db15d155c8b57800da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4639b25ffee452db15d155c8b57800da">&#9670;&#160;</a></span>hash()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::uint64_t jh::pod::string_view::hash </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacejh_1_1meta.html#a7ea475ab0421edb9edb93189740da707">jh::meta::c_hash</a></td>          <td class="paramname"><span class="paramname"><em>hash_method</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespacejh_1_1meta.html#a7ea475ab0421edb9edb93189740da707aca0466d3124e039f7442eccafc2fd891">jh::meta::c_hash::fnv1a64</a></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hash the view content using a selectable non-cryptographic algorithm. </p>
<p>Provides stable 64-bit hashing over the view contents.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hash_method</td><td>Algorithm to use for hashing (default: <code>fnv1a64</code>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>64-bit hash of the view data, or <code>-1</code> if <code>data == nullptr</code>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>
This is <b>not cryptographic</b>; do not use it for security-sensitive logic. </li>
<li>
If <code>data</code> is null, the return value is <code>-1</code> (sentinel). </li>
<li>
Hashing is based only on contents and length, not on pointer identity. </li>
<li>
Unlike <code><a class="el" href="structjh_1_1pod_1_1bytes__view.html#acfcdb6f4e5ab057f76a6ef9e90adaa88" title="Compute a deterministic 64-bit hash of the view contents.">bytes_view::hash</a></code>, this function is <b>valid in consteval contexts</b>. <ul>
<li>
<code><a class="el" href="structjh_1_1pod_1_1bytes__view.html" title="A read-only view over a block of raw bytes.">bytes_view</a></code> relies on <code>reinterpret_cast</code>, so it cannot be evaluated at compile time. </li>
<li>
<code><a class="el" href="structjh_1_1pod_1_1string__view.html" title="Read-only string view with POD layout.">string_view</a></code> operates directly on characters, so compile-time hashing of string literals is both <b>well-defined</b> and <b>semantically meaningful</b>. </li>
<li>
This design enables features such as <code><a class="el" href="structjh_1_1meta_1_1t__str.html" title="Compile-time string wrapper for use as a non-type template parameter (NTTP).">jh::meta::t_str</a></code> to compute hashes fully at compile time. </li>
</ul>
</li>
</ul>
</dd></dl>

</div>
</div>
<a id="a2421ae3aa0b3d5f7baa021a2a39edee0" name="a2421ae3aa0b3d5f7baa021a2a39edee0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2421ae3aa0b3d5f7baa021a2a39edee0">&#9670;&#160;</a></span>operator std::string_view()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">jh::pod::string_view::operator std::string_view </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel explicit">explicit</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Explicit conversion to <code>std::string_view</code>. </p>
<p>Provides safe, zero-overhead interoperability with the standard library. This conversion preserves both pointer and length semantics without affecting POD compatibility.</p>
<p><b>Semantics:</b> </p>
<ul>
<li>
Conversion is <b>explicit</b> — requires <code>static_cast</code> or brace-init form. </li>
<li>
Performs no allocation or copy; simply wraps existing data. </li>
<li>
Pointer and size are preserved exactly (1:1 mapping). </li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Explicit to avoid unintended implicit conversions in overload resolution. See also: <code><a class="el" href="#a209ab16ddb2543cf437a00b023e9c61b" title="Named conversion helper to obtain a std::string_view.">to_std()</a></code> for named equivalent. </dd></dl>

</div>
</div>
<a id="aa973df23961f6da1a9c8d53a0f707a10" name="aa973df23961f6da1a9c8d53a0f707a10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa973df23961f6da1a9c8d53a0f707a10">&#9670;&#160;</a></span>operator&lt;=&gt;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::strong_ordering jh::pod::string_view::operator&lt;=&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a2421ae3aa0b3d5f7baa021a2a39edee0">string_view</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Three-way comparison operator (spaceship operator). </p>
<p>Performs a <b>lexicographical three-way comparison</b> between two <code><a class="el" href="structjh_1_1pod_1_1string__view.html" title="Read-only string view with POD layout.">string_view</a></code> instances, returning a value of type <code>std::strong_ordering</code>.</p>
<h4>Semantics:</h4>
<ul>
<li>
Returns <code>std::strong_ordering::less</code> if <span class="tt">*this &lt; rhs</span> </li>
<li>
Returns <code>std::strong_ordering::equal</code> if <span class="tt">*this == rhs</span> </li>
<li>
Returns <code>std::strong_ordering::greater</code> if <span class="tt">*this &gt; rhs</span> </li>
</ul>
<p>The comparison is implemented in terms of <code><a class="el" href="#a6de4d05806a5854cad1f3d6bd0c3ec78" title="Lexical comparison (similar to strcmp()).">compare()</a></code>, and therefore follows identical lexicographic ordering rules. This ensures <b>bitwise consistency</b> between <code><a class="el" href="#a6de4d05806a5854cad1f3d6bd0c3ec78" title="Lexical comparison (similar to strcmp()).">compare()</a></code>, <code>operator==</code>, and all derived relational operators.</p>
<h4>Properties:</h4>
<ul>
<li>
Guaranteed <b>constexpr</b> and <b>noexcept</b>. </li>
<li>
Implements a <b>strict total ordering</b> (same as <code>std::string_view</code>). </li>
<li>
Automatically enables all relational operators (<code>&lt;, &lt;=, &gt;, &gt;=</code>) via the compiler. </li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side <code><a class="el" href="structjh_1_1pod_1_1string__view.html" title="Read-only string view with POD layout.">string_view</a></code> to compare against. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>std::strong_ordering</code> value indicating the lexicographic relation.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a6de4d05806a5854cad1f3d6bd0c3ec78" title="Lexical comparison (similar to strcmp()).">compare()</a> </dd>
<dd>
<a class="el" href="#aaae7bf17195d062b0b48d4aa9a918157" title="Compare two views for byte-wise equality.">operator==()</a> </dd></dl>

</div>
</div>
<a id="aaae7bf17195d062b0b48d4aa9a918157" name="aaae7bf17195d062b0b48d4aa9a918157"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaae7bf17195d062b0b48d4aa9a918157">&#9670;&#160;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool jh::pod::string_view::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a2421ae3aa0b3d5f7baa021a2a39edee0">string_view</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare two views for byte-wise equality. </p>
<p>Performs a <b>deep comparison</b> of contents using <code>memcmp</code>, rather than checking pointer identity.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>Another <code><a class="el" href="structjh_1_1pod_1_1string__view.html" title="Read-only string view with POD layout.">string_view</a></code> to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if contents are equal, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="abad86270cff2bc8bf0008f96ae07a914" name="abad86270cff2bc8bf0008f96ae07a914"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abad86270cff2bc8bf0008f96ae07a914">&#9670;&#160;</a></span>sub()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a2421ae3aa0b3d5f7baa021a2a39edee0">string_view</a> jh::pod::string_view::sub </td>
          <td>(</td>
          <td class="paramtype">const std::uint64_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::uint64_t</td>          <td class="paramname"><span class="paramname"><em>length</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a substring starting at <code>offset</code>, for <code>length</code> bytes. </p>
<ul>
<li>
If <code>length == 0</code>, the view extends to the end. </li>
<li>
If <code>offset &gt; len</code>, returns an empty view. </li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>Starting byte index (0-based). </td></tr>
    <tr><td class="paramname">length</td><td>Number of bytes (<code>0</code> = sentinel = to end). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new <code><a class="el" href="structjh_1_1pod_1_1string__view.html" title="Read-only string view with POD layout.">string_view</a></code> into the specified subrange. </dd></dl>

</div>
</div>
<a id="a209ab16ddb2543cf437a00b023e9c61b" name="a209ab16ddb2543cf437a00b023e9c61b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a209ab16ddb2543cf437a00b023e9c61b">&#9670;&#160;</a></span>to_std()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string_view jh::pod::string_view::to_std </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Named conversion helper to obtain a <code>std::string_view</code>. </p>
<p>Functionally identical to <code>explicit operator std::string_view()</code>, but callable in normal expressions without <code>static_cast</code>.</p>
<p><b>Use cases:</b> </p>
<ul>
<li>
Improves readability in non-template or mixed API contexts. </li>
<li>
Convenient when passing to standard library functions expecting <code>std::string_view</code>. </li>
</ul>
<dl class="section see"><dt>See also</dt><dd>operator std::string_view() </dd></dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>include/jh/pods/<a class="el" href="">string_view.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
</div> <!-- top -->
<hr class="footer"/>
<div class="footer">
    <img class="footer-logo" src="Ojing.svg" alt="Ojing"/>
    <div class="footer-text">
        JH-Toolkit v1.4.0 · Generated by Doxygen
    </div>
    <div class="footer-note">
        We primarily support embedded documentation views in IDEs (classic CLion).
        To ensure compatibility with embedded rendering, some example code in this
        documentation intentionally contains HTML entities.
        In certain cases, Doxygen does not unescape these entities correctly.
        This is a known limitation and currently has no workaround.
    </div>
</div>
</body>
</html>
